/*! For license information please see main.9ff04849.js.LICENSE.txt */
(() => { var e = { 904: (e, t, n) => { "use strict"; n.r(t), n.d(t, { CountUp: () => i }); var r = function () { return r = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++)for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]); return e }, r.apply(this, arguments) }, i = function () { function e(e, t, n) { var i = this; this.endVal = t, this.options = n, this.version = "2.8.0", this.defaults = { startVal: 0, decimalPlaces: 0, duration: 2, useEasing: !0, useGrouping: !0, useIndianSeparators: !1, smartEasingThreshold: 999, smartEasingAmount: 333, separator: ",", decimal: ".", prefix: "", suffix: "", enableScrollSpy: !1, scrollSpyDelay: 200, scrollSpyOnce: !1 }, this.finalEndVal = null, this.useEasing = !0, this.countDown = !1, this.error = "", this.startVal = 0, this.paused = !0, this.once = !1, this.count = function (e) { i.startTime || (i.startTime = e); var t = e - i.startTime; i.remaining = i.duration - t, i.useEasing ? i.countDown ? i.frameVal = i.startVal - i.easingFn(t, 0, i.startVal - i.endVal, i.duration) : i.frameVal = i.easingFn(t, i.startVal, i.endVal - i.startVal, i.duration) : i.frameVal = i.startVal + (i.endVal - i.startVal) * (t / i.duration); var n = i.countDown ? i.frameVal < i.endVal : i.frameVal > i.endVal; i.frameVal = n ? i.endVal : i.frameVal, i.frameVal = Number(i.frameVal.toFixed(i.options.decimalPlaces)), i.printValue(i.frameVal), t < i.duration ? i.rAF = requestAnimationFrame(i.count) : null !== i.finalEndVal ? i.update(i.finalEndVal) : i.options.onCompleteCallback && i.options.onCompleteCallback() }, this.formatNumber = function (e) { var t, n, r, o, a = e < 0 ? "-" : ""; t = Math.abs(e).toFixed(i.options.decimalPlaces); var s = (t += "").split("."); if (n = s[0], r = s.length > 1 ? i.options.decimal + s[1] : "", i.options.useGrouping) { o = ""; for (var l = 3, c = 0, u = 0, d = n.length; u < d; ++u)i.options.useIndianSeparators && 4 === u && (l = 2, c = 1), 0 !== u && c % l == 0 && (o = i.options.separator + o), c++, o = n[d - u - 1] + o; n = o } return i.options.numerals && i.options.numerals.length && (n = n.replace(/[0-9]/g, (function (e) { return i.options.numerals[+e] })), r = r.replace(/[0-9]/g, (function (e) { return i.options.numerals[+e] }))), a + i.options.prefix + n + r + i.options.suffix }, this.easeOutExpo = function (e, t, n, r) { return n * (1 - Math.pow(2, -10 * e / r)) * 1024 / 1023 + t }, this.options = r(r({}, this.defaults), n), this.formattingFn = this.options.formattingFn ? this.options.formattingFn : this.formatNumber, this.easingFn = this.options.easingFn ? this.options.easingFn : this.easeOutExpo, this.startVal = this.validateValue(this.options.startVal), this.frameVal = this.startVal, this.endVal = this.validateValue(t), this.options.decimalPlaces = Math.max(this.options.decimalPlaces), this.resetDuration(), this.options.separator = String(this.options.separator), this.useEasing = this.options.useEasing, "" === this.options.separator && (this.options.useGrouping = !1), this.el = "string" == typeof e ? document.getElementById(e) : e, this.el ? this.printValue(this.startVal) : this.error = "[CountUp] target is null or undefined", "undefined" != typeof window && this.options.enableScrollSpy && (this.error ? console.error(this.error, e) : (window.onScrollFns = window.onScrollFns || [], window.onScrollFns.push((function () { return i.handleScroll(i) })), window.onscroll = function () { window.onScrollFns.forEach((function (e) { return e() })) }, this.handleScroll(this))) } return e.prototype.handleScroll = function (e) { if (e && window && !e.once) { var t = window.innerHeight + window.scrollY, n = e.el.getBoundingClientRect(), r = n.top + window.pageYOffset, i = n.top + n.height + window.pageYOffset; i < t && i > window.scrollY && e.paused ? (e.paused = !1, setTimeout((function () { return e.start() }), e.options.scrollSpyDelay), e.options.scrollSpyOnce && (e.once = !0)) : (window.scrollY > i || r > t) && !e.paused && e.reset() } }, e.prototype.determineDirectionAndSmartEasing = function () { var e = this.finalEndVal ? this.finalEndVal : this.endVal; this.countDown = this.startVal > e; var t = e - this.startVal; if (Math.abs(t) > this.options.smartEasingThreshold && this.options.useEasing) { this.finalEndVal = e; var n = this.countDown ? 1 : -1; this.endVal = e + n * this.options.smartEasingAmount, this.duration = this.duration / 2 } else this.endVal = e, this.finalEndVal = null; null !== this.finalEndVal ? this.useEasing = !1 : this.useEasing = this.options.useEasing }, e.prototype.start = function (e) { this.error || (this.options.onStartCallback && this.options.onStartCallback(), e && (this.options.onCompleteCallback = e), this.duration > 0 ? (this.determineDirectionAndSmartEasing(), this.paused = !1, this.rAF = requestAnimationFrame(this.count)) : this.printValue(this.endVal)) }, e.prototype.pauseResume = function () { this.paused ? (this.startTime = null, this.duration = this.remaining, this.startVal = this.frameVal, this.determineDirectionAndSmartEasing(), this.rAF = requestAnimationFrame(this.count)) : cancelAnimationFrame(this.rAF), this.paused = !this.paused }, e.prototype.reset = function () { cancelAnimationFrame(this.rAF), this.paused = !0, this.resetDuration(), this.startVal = this.validateValue(this.options.startVal), this.frameVal = this.startVal, this.printValue(this.startVal) }, e.prototype.update = function (e) { cancelAnimationFrame(this.rAF), this.startTime = null, this.endVal = this.validateValue(e), this.endVal !== this.frameVal && (this.startVal = this.frameVal, null == this.finalEndVal && this.resetDuration(), this.finalEndVal = null, this.determineDirectionAndSmartEasing(), this.rAF = requestAnimationFrame(this.count)) }, e.prototype.printValue = function (e) { var t; if (this.el) { var n = this.formattingFn(e); (null === (t = this.options.plugin) || void 0 === t ? void 0 : t.render) ? this.options.plugin.render(this.el, n) : "INPUT" === this.el.tagName ? this.el.value = n : "text" === this.el.tagName || "tspan" === this.el.tagName ? this.el.textContent = n : this.el.innerHTML = n } }, e.prototype.ensureNumber = function (e) { return "number" == typeof e && !isNaN(e) }, e.prototype.validateValue = function (e) { var t = Number(e); return this.ensureNumber(t) ? t : (this.error = "[CountUp] invalid start or end value: ".concat(e), null) }, e.prototype.resetDuration = function () { this.startTime = null, this.duration = 1e3 * Number(this.options.duration), this.remaining = this.duration }, e }() }, 240: e => { "use strict"; var t = Object.prototype.hasOwnProperty, n = Object.prototype.toString, r = Object.defineProperty, i = Object.getOwnPropertyDescriptor, o = function (e) { return "function" === typeof Array.isArray ? Array.isArray(e) : "[object Array]" === n.call(e) }, a = function (e) { if (!e || "[object Object]" !== n.call(e)) return !1; var r, i = t.call(e, "constructor"), o = e.constructor && e.constructor.prototype && t.call(e.constructor.prototype, "isPrototypeOf"); if (e.constructor && !i && !o) return !1; for (r in e); return "undefined" === typeof r || t.call(e, r) }, s = function (e, t) { r && "__proto__" === t.name ? r(e, t.name, { enumerable: !0, configurable: !0, value: t.newValue, writable: !0 }) : e[t.name] = t.newValue }, l = function (e, n) { if ("__proto__" === n) { if (!t.call(e, n)) return; if (i) return i(e, n).value } return e[n] }; e.exports = function e() { var t, n, r, i, c, u, d = arguments[0], h = 1, f = arguments.length, p = !1; for ("boolean" === typeof d && (p = d, d = arguments[1] || {}, h = 2), (null == d || "object" !== typeof d && "function" !== typeof d) && (d = {}); h < f; ++h)if (null != (t = arguments[h])) for (n in t) r = l(d, n), d !== (i = l(t, n)) && (p && i && (a(i) || (c = o(i))) ? (c ? (c = !1, u = r && o(r) ? r : []) : u = r && a(r) ? r : {}, s(d, { name: n, newValue: e(p, u, i) })) : "undefined" !== typeof i && s(d, { name: n, newValue: i })); return d } }, 403: e => { var t = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, n = /\n/g, r = /^\s*/, i = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, o = /^:\s*/, a = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, s = /^[;\s]*/, l = /^\s+|\s+$/g, c = ""; function u(e) { return e ? e.replace(l, c) : c } e.exports = function (e, l) { if ("string" !== typeof e) throw new TypeError("First argument must be a string"); if (!e) return []; l = l || {}; var d = 1, h = 1; function f(e) { var t = e.match(n); t && (d += t.length); var r = e.lastIndexOf("\n"); h = ~r ? e.length - r : h + e.length } function p() { var e = { line: d, column: h }; return function (t) { return t.position = new m(e), b(), t } } function m(e) { this.start = e, this.end = { line: d, column: h }, this.source = l.source } m.prototype.content = e; var g = []; function v(t) { var n = new Error(l.source + ":" + d + ":" + h + ": " + t); if (n.reason = t, n.filename = l.source, n.line = d, n.column = h, n.source = e, !l.silent) throw n; g.push(n) } function y(t) { var n = t.exec(e); if (n) { var r = n[0]; return f(r), e = e.slice(r.length), n } } function b() { y(r) } function x(e) { var t; for (e = e || []; t = w();)!1 !== t && e.push(t); return e } function w() { var t = p(); if ("/" == e.charAt(0) && "*" == e.charAt(1)) { for (var n = 2; c != e.charAt(n) && ("*" != e.charAt(n) || "/" != e.charAt(n + 1));)++n; if (n += 2, c === e.charAt(n - 1)) return v("End of comment missing"); var r = e.slice(2, n - 2); return h += 2, f(r), e = e.slice(n), h += 2, t({ type: "comment", comment: r }) } } function k() { var e = p(), n = y(i); if (n) { if (w(), !y(o)) return v("property missing ':'"); var r = y(a), l = e({ type: "declaration", property: u(n[0].replace(t, c)), value: r ? u(r[0].replace(t, c)) : c }); return y(s), l } } return b(), function () { var e, t = []; for (x(t); e = k();)!1 !== e && (t.push(e), x(t)); return t }() } }, 381: (e, t, n) => { var r = "Expected a function", i = NaN, o = "[object Symbol]", a = /^\s+|\s+$/g, s = /^[-+]0x[0-9a-f]+$/i, l = /^0b[01]+$/i, c = /^0o[0-7]+$/i, u = parseInt, d = "object" == typeof n.g && n.g && n.g.Object === Object && n.g, h = "object" == typeof self && self && self.Object === Object && self, f = d || h || Function("return this")(), p = Object.prototype.toString, m = Math.max, g = Math.min, v = function () { return f.Date.now() }; function y(e, t, n) { var i, o, a, s, l, c, u = 0, d = !1, h = !1, f = !0; if ("function" != typeof e) throw new TypeError(r); function p(t) { var n = i, r = o; return i = o = void 0, u = t, s = e.apply(r, n) } function y(e) { var n = e - c; return void 0 === c || n >= t || n < 0 || h && e - u >= a } function w() { var e = v(); if (y(e)) return k(e); l = setTimeout(w, function (e) { var n = t - (e - c); return h ? g(n, a - (e - u)) : n }(e)) } function k(e) { return l = void 0, f && i ? p(e) : (i = o = void 0, s) } function S() { var e = v(), n = y(e); if (i = arguments, o = this, c = e, n) { if (void 0 === l) return function (e) { return u = e, l = setTimeout(w, t), d ? p(e) : s }(c); if (h) return l = setTimeout(w, t), p(c) } return void 0 === l && (l = setTimeout(w, t)), s } return t = x(t) || 0, b(n) && (d = !!n.leading, a = (h = "maxWait" in n) ? m(x(n.maxWait) || 0, t) : a, f = "trailing" in n ? !!n.trailing : f), S.cancel = function () { void 0 !== l && clearTimeout(l), u = 0, i = c = o = l = void 0 }, S.flush = function () { return void 0 === l ? s : k(v()) }, S } function b(e) { var t = typeof e; return !!e && ("object" == t || "function" == t) } function x(e) { if ("number" == typeof e) return e; if (function (e) { return "symbol" == typeof e || function (e) { return !!e && "object" == typeof e }(e) && p.call(e) == o }(e)) return i; if (b(e)) { var t = "function" == typeof e.valueOf ? e.valueOf() : e; e = b(t) ? t + "" : t } if ("string" != typeof e) return 0 === e ? e : +e; e = e.replace(a, ""); var n = l.test(e); return n || c.test(e) ? u(e.slice(2), n ? 2 : 8) : s.test(e) ? i : +e } e.exports = function (e, t, n) { var i = !0, o = !0; if ("function" != typeof e) throw new TypeError(r); return b(n) && (i = "leading" in n ? !!n.leading : i, o = "trailing" in n ? !!n.trailing : o), y(e, t, { leading: i, maxWait: t, trailing: o }) } }, 497: (e, t, n) => { "use strict"; var r = n(218); function i() { } function o() { } o.resetWarningCache = i, e.exports = function () { function e(e, t, n, i, o, a) { if (a !== r) { var s = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw s.name = "Invariant Violation", s } } function t() { return e } e.isRequired = e; var n = { array: e, bigint: e, bool: e, func: e, number: e, object: e, string: e, symbol: e, any: e, arrayOf: t, element: e, elementType: e, instanceOf: t, node: e, objectOf: t, oneOf: t, oneOfType: t, shape: t, exact: t, checkPropTypes: o, resetWarningCache: i }; return n.PropTypes = n, n } }, 173: (e, t, n) => { e.exports = n(497)() }, 218: e => { "use strict"; e.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED" }, 751: (e, t, n) => { "use strict"; var r = n(43), i = n(904); function o(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, r) } return n } function a(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? o(Object(n), !0).forEach((function (t) { l(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } function s(e) { var t = function (e, t) { if ("object" != typeof e || !e) return e; var n = e[Symbol.toPrimitive]; if (void 0 !== n) { var r = n.call(e, t || "default"); if ("object" != typeof r) return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(e, "string"); return "symbol" == typeof t ? t : String(t) } function l(e, t, n) { return (t = s(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function c() { return c = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, c.apply(this, arguments) } function u(e, t) { if (null == e) return {}; var n, r, i = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n]) } return i } function d(e, t) { return function (e) { if (Array.isArray(e)) return e }(e) || function (e, t) { var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"]; if (null != n) { var r, i, o, a, s = [], l = !0, c = !1; try { if (o = (n = n.call(e)).next, 0 === t) { if (Object(n) !== n) return; l = !1 } else for (; !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); l = !0); } catch (e) { c = !0, i = e } finally { try { if (!l && null != n.return && (a = n.return(), Object(a) !== a)) return } finally { if (c) throw i } } return s } }(e, t) || function (e, t) { if (!e) return; if ("string" === typeof e) return h(e, t); var n = Object.prototype.toString.call(e).slice(8, -1); "Object" === n && e.constructor && (n = e.constructor.name); if ("Map" === n || "Set" === n) return Array.from(e); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return h(e, t) }(e, t) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function h(e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } var f = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement ? r.useLayoutEffect : r.useEffect; function p(e) { var t = r.useRef(e); return f((function () { t.current = e })), r.useCallback((function () { for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r]; return t.current.apply(void 0, n) }), []) } var m = ["ref", "startOnMount", "enableReinitialize", "delay", "onEnd", "onStart", "onPauseResume", "onReset", "onUpdate"], g = { decimal: ".", separator: ",", delay: null, prefix: "", suffix: "", duration: 2, start: 0, decimals: 0, startOnMount: !0, enableReinitialize: !0, useEasing: !0, useGrouping: !0, useIndianSeparators: !1 }, v = function (e) { var t = Object.fromEntries(Object.entries(e).filter((function (e) { return void 0 !== d(e, 2)[1] }))), n = r.useMemo((function () { return a(a({}, g), t) }), [e]), o = n.ref, s = n.startOnMount, l = n.enableReinitialize, c = n.delay, h = n.onEnd, f = n.onStart, v = n.onPauseResume, y = n.onReset, b = n.onUpdate, x = u(n, m), w = r.useRef(), k = r.useRef(), S = r.useRef(!1), A = p((function () { return function (e, t) { var n = t.decimal, r = t.decimals, o = t.duration, a = t.easingFn, s = t.end, l = t.formattingFn, c = t.numerals, u = t.prefix, d = t.separator, h = t.start, f = t.suffix, p = t.useEasing, m = t.useGrouping, g = t.useIndianSeparators, v = t.enableScrollSpy, y = t.scrollSpyDelay, b = t.scrollSpyOnce, x = t.plugin; return new i.CountUp(e, s, { startVal: h, duration: o, decimal: n, decimalPlaces: r, easingFn: a, formattingFn: l, numerals: c, separator: d, prefix: u, suffix: f, plugin: x, useEasing: p, useIndianSeparators: g, useGrouping: m, enableScrollSpy: v, scrollSpyDelay: y, scrollSpyOnce: b }) }("string" === typeof o ? o : o.current, x) })), E = p((function (e) { var t = w.current; if (t && !e) return t; var n = A(); return w.current = n, n })), C = p((function () { var e = function () { return E(!0).start((function () { null === h || void 0 === h || h({ pauseResume: P, reset: j, start: M, update: N }) })) }; c && c > 0 ? k.current = setTimeout(e, 1e3 * c) : e(), null === f || void 0 === f || f({ pauseResume: P, reset: j, update: N }) })), P = p((function () { E().pauseResume(), null === v || void 0 === v || v({ reset: j, start: M, update: N }) })), j = p((function () { E().el && (k.current && clearTimeout(k.current), E().reset(), null === y || void 0 === y || y({ pauseResume: P, start: M, update: N })) })), N = p((function (e) { E().update(e), null === b || void 0 === b || b({ pauseResume: P, reset: j, start: M }) })), M = p((function () { j(), C() })), T = p((function (e) { s && (e && j(), C()) })); return r.useEffect((function () { S.current ? l && T(!0) : (S.current = !0, T()) }), [l, S, T, c, e.start, e.suffix, e.prefix, e.duration, e.separator, e.decimals, e.decimal, e.formattingFn]), r.useEffect((function () { return function () { j() } }), [j]), { start: M, pauseResume: P, reset: j, update: N, getCountUp: E } }, y = ["className", "redraw", "containerProps", "children", "style"]; t.Ay = function (e) { var t = e.className, n = e.redraw, i = e.containerProps, o = e.children, s = e.style, l = u(e, y), d = r.useRef(null), h = r.useRef(!1), f = v(a(a({}, l), {}, { ref: d, startOnMount: "function" !== typeof o || 0 === e.delay, enableReinitialize: !1 })), m = f.start, g = f.reset, b = f.update, x = f.pauseResume, w = f.getCountUp, k = p((function () { m() })), S = p((function (t) { e.preserveValue || g(), b(t) })), A = p((function () { "function" !== typeof e.children || d.current instanceof Element ? w() : console.error('Couldn\'t find attached element to hook the CountUp instance into! Try to attach "containerRef" from the render prop to a an Element, eg. <span ref={containerRef} />.') })); r.useEffect((function () { A() }), [A]), r.useEffect((function () { h.current && S(e.end) }), [e.end, S]); var E = n && e; return r.useEffect((function () { n && h.current && k() }), [k, n, E]), r.useEffect((function () { !n && h.current && k() }), [k, n, e.start, e.suffix, e.prefix, e.duration, e.separator, e.decimals, e.decimal, e.className, e.formattingFn]), r.useEffect((function () { h.current = !0 }), []), "function" === typeof o ? o({ countUpRef: d, start: m, reset: g, update: b, pauseResume: x, getCountUp: w }) : r.createElement("span", c({ className: t, ref: d, style: s }, i), "undefined" !== typeof e.start ? w().formattingFn(e.start) : "") } }, 730: (e, t, n) => { "use strict"; var r = n(43), i = n(853); function o(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var a = new Set, s = {}; function l(e, t) { c(e, t), c(e + "Capture", t) } function c(e, t) { for (s[e] = t, e = 0; e < t.length; e++)a.add(t[e]) } var u = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), d = Object.prototype.hasOwnProperty, h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, f = {}, p = {}; function m(e, t, n, r, i, o, a) { this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = a } var g = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function (e) { g[e] = new m(e, 0, !1, e, null, !1, !1) })), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function (e) { var t = e[0]; g[t] = new m(t, 1, !1, e[1], null, !1, !1) })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function (e) { g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1) })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function (e) { g[e] = new m(e, 2, !1, e, null, !1, !1) })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function (e) { g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1) })), ["checked", "multiple", "muted", "selected"].forEach((function (e) { g[e] = new m(e, 3, !0, e, null, !1, !1) })), ["capture", "download"].forEach((function (e) { g[e] = new m(e, 4, !1, e, null, !1, !1) })), ["cols", "rows", "size", "span"].forEach((function (e) { g[e] = new m(e, 6, !1, e, null, !1, !1) })), ["rowSpan", "start"].forEach((function (e) { g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1) })); var v = /[\-:]([a-z])/g; function y(e) { return e[1].toUpperCase() } function b(e, t, n, r) { var i = g.hasOwnProperty(t) ? g[t] : null; (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function (e, t, n, r) { if (null === t || "undefined" === typeof t || function (e, t, n, r) { if (null !== n && 0 === n.type) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e); default: return !1 } }(e, t, n, r)) return !0; if (r) return !1; if (null !== n) switch (n.type) { case 3: return !t; case 4: return !1 === t; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 }(t, n, i, r) && (n = null), r || null === i ? function (e) { return !!d.call(p, e) || !d.call(f, e) && (h.test(e) ? p[e] = !0 : (f[e] = !0, !1)) }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function (e) { var t = e.replace(v, y); g[t] = new m(t, 1, !1, e, null, !1, !1) })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function (e) { var t = e.replace(v, y); g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) })), ["xml:base", "xml:lang", "xml:space"].forEach((function (e) { var t = e.replace(v, y); g[t] = new m(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) })), ["tabIndex", "crossOrigin"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1) })), g.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function (e) { g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0) })); var x = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, w = Symbol.for("react.element"), k = Symbol.for("react.portal"), S = Symbol.for("react.fragment"), A = Symbol.for("react.strict_mode"), E = Symbol.for("react.profiler"), C = Symbol.for("react.provider"), P = Symbol.for("react.context"), j = Symbol.for("react.forward_ref"), N = Symbol.for("react.suspense"), M = Symbol.for("react.suspense_list"), T = Symbol.for("react.memo"), I = Symbol.for("react.lazy"); Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode"); var L = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker"); var R = Symbol.iterator; function D(e) { return null === e || "object" !== typeof e ? null : "function" === typeof (e = R && e[R] || e["@@iterator"]) ? e : null } var z, O = Object.assign; function B(e) { if (void 0 === z) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); z = t && t[1] || "" } return "\n" + z + e } var F = !1; function V(e, t) { if (!e || F) return ""; F = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), "object" === typeof Reflect && Reflect.construct) { try { Reflect.construct(t, []) } catch (c) { var r = c } Reflect.construct(e, [], t) } else { try { t.call() } catch (c) { r = c } e.call(t.prototype) } else { try { throw Error() } catch (c) { r = c } e() } } catch (c) { if (c && r && "string" === typeof c.stack) { for (var i = c.stack.split("\n"), o = r.stack.split("\n"), a = i.length - 1, s = o.length - 1; 1 <= a && 0 <= s && i[a] !== o[s];)s--; for (; 1 <= a && 0 <= s; a--, s--)if (i[a] !== o[s]) { if (1 !== a || 1 !== s) do { if (a--, 0 > --s || i[a] !== o[s]) { var l = "\n" + i[a].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l } } while (1 <= a && 0 <= s); break } } } finally { F = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? B(e) : "" } function U(e) { switch (e.tag) { case 5: return B(e.type); case 16: return B("Lazy"); case 13: return B("Suspense"); case 19: return B("SuspenseList"); case 0: case 2: case 15: return e = V(e.type, !1); case 11: return e = V(e.type.render, !1); case 1: return e = V(e.type, !0); default: return "" } } function W(e) { if (null == e) return null; if ("function" === typeof e) return e.displayName || e.name || null; if ("string" === typeof e) return e; switch (e) { case S: return "Fragment"; case k: return "Portal"; case E: return "Profiler"; case A: return "StrictMode"; case N: return "Suspense"; case M: return "SuspenseList" }if ("object" === typeof e) switch (e.$$typeof) { case P: return (e.displayName || "Context") + ".Consumer"; case C: return (e._context.displayName || "Context") + ".Provider"; case j: var t = e.render; return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case T: return null !== (t = e.displayName || null) ? t : W(e.type) || "Memo"; case I: t = e._payload, e = e._init; try { return W(e(t)) } catch (n) { } }return null } function H(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return W(t); case 8: return t === A ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if ("function" === typeof t) return t.displayName || t.name || null; if ("string" === typeof t) return t }return null } function Y(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": case "object": return e; default: return "" } } function X(e) { var t = e.type; return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t) } function Q(e) { e._valueTracker || (e._valueTracker = function (e) { var t = X(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) { var i = n.get, o = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (e) { r = "" + e, o.call(this, e) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (e) { r = "" + e }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } }(e)) } function q(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = X(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0) } function Z(e) { if ("undefined" === typeof (e = e || ("undefined" !== typeof document ? document : void 0))) return null; try { return e.activeElement || e.body } catch (t) { return e.body } } function K(e, t) { var n = t.checked; return O({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != n ? n : e._wrapperState.initialChecked }) } function G(e, t) { var n = null == t.defaultValue ? "" : t.defaultValue, r = null != t.checked ? t.checked : t.defaultChecked; n = Y(null != t.value ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value } } function J(e, t) { null != (t = t.checked) && b(e, "checked", t, !1) } function _(e, t) { J(e, t); var n = Y(t.value), r = t.type; if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if ("submit" === r || "reset" === r) return void e.removeAttribute("value"); t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, Y(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked) } function $(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n) } function ee(e, t, n) { "number" === t && Z(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var te = Array.isArray; function ne(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + Y(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) return e[i].selected = !0, void (r && (e[i].defaultSelected = !0)); null !== t || e[i].disabled || (t = e[i]) } null !== t && (t.selected = !0) } } function re(e, t) { if (null != t.dangerouslySetInnerHTML) throw Error(o(91)); return O({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function ie(e, t) { var n = t.value; if (null == n) { if (n = t.children, t = t.defaultValue, null != n) { if (null != t) throw Error(o(92)); if (te(n)) { if (1 < n.length) throw Error(o(93)); n = n[0] } t = n } null == t && (t = ""), n = t } e._wrapperState = { initialValue: Y(n) } } function oe(e, t) { var n = Y(t.value), r = Y(t.defaultValue); null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r) } function ae(e) { var t = e.textContent; t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t) } function se(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function le(e, t) { return null == e || "http://www.w3.org/1999/xhtml" === e ? se(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e } var ce, ue, de = (ue = function (e, t) { if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t; else { for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ce.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }, "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (e, t, n, r) { MSApp.execUnsafeLocalFunction((function () { return ue(e, t) })) } : ue); function he(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && 3 === n.nodeType) return void (n.nodeValue = t) } e.textContent = t } var fe = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, pe = ["Webkit", "ms", "Moz", "O"]; function me(e, t, n) { return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || fe.hasOwnProperty(e) && fe[e] ? ("" + t).trim() : t + "px" } function ge(e, t) { for (var n in e = e.style, t) if (t.hasOwnProperty(n)) { var r = 0 === n.indexOf("--"), i = me(n, t[n], r); "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } Object.keys(fe).forEach((function (e) { pe.forEach((function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), fe[t] = fe[e] })) })); var ve = O({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function ye(e, t) { if (t) { if (ve[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(o(137, e)); if (null != t.dangerouslySetInnerHTML) { if (null != t.children) throw Error(o(60)); if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(o(61)) } if (null != t.style && "object" !== typeof t.style) throw Error(o(62)) } } function be(e, t) { if (-1 === e.indexOf("-")) return "string" === typeof t.is; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var xe = null; function we(e) { return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e } var ke = null, Se = null, Ae = null; function Ee(e) { if (e = bi(e)) { if ("function" !== typeof ke) throw Error(o(280)); var t = e.stateNode; t && (t = wi(t), ke(e.stateNode, e.type, t)) } } function Ce(e) { Se ? Ae ? Ae.push(e) : Ae = [e] : Se = e } function Pe() { if (Se) { var e = Se, t = Ae; if (Ae = Se = null, Ee(e), t) for (e = 0; e < t.length; e++)Ee(t[e]) } } function je(e, t) { return e(t) } function Ne() { } var Me = !1; function Te(e, t, n) { if (Me) return e(t, n); Me = !0; try { return je(e, t, n) } finally { Me = !1, (null !== Se || null !== Ae) && (Ne(), Pe()) } } function Ie(e, t) { var n = e.stateNode; if (null === n) return null; var r = wi(n); if (null === r) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r; break e; default: e = !1 }if (e) return null; if (n && "function" !== typeof n) throw Error(o(231, t, typeof n)); return n } var Le = !1; if (u) try { var Re = {}; Object.defineProperty(Re, "passive", { get: function () { Le = !0 } }), window.addEventListener("test", Re, Re), window.removeEventListener("test", Re, Re) } catch (ue) { Le = !1 } function De(e, t, n, r, i, o, a, s, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (u) { this.onError(u) } } var ze = !1, Oe = null, Be = !1, Fe = null, Ve = { onError: function (e) { ze = !0, Oe = e } }; function Ue(e, t, n, r, i, o, a, s, l) { ze = !1, Oe = null, De.apply(Ve, arguments) } function We(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do { 0 !== (4098 & (t = e).flags) && (n = t.return), e = t.return } while (e) } return 3 === t.tag ? n : null } function He(e) { if (13 === e.tag) { var t = e.memoizedState; if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)), null !== t) return t.dehydrated } return null } function Ye(e) { if (We(e) !== e) throw Error(o(188)) } function Xe(e) { return null !== (e = function (e) { var t = e.alternate; if (!t) { if (null === (t = We(e))) throw Error(o(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (null === i) break; var a = i.alternate; if (null === a) { if (null !== (r = i.return)) { n = r; continue } break } if (i.child === a.child) { for (a = i.child; a;) { if (a === n) return Ye(i), e; if (a === r) return Ye(i), t; a = a.sibling } throw Error(o(188)) } if (n.return !== r.return) n = i, r = a; else { for (var s = !1, l = i.child; l;) { if (l === n) { s = !0, n = i, r = a; break } if (l === r) { s = !0, r = i, n = a; break } l = l.sibling } if (!s) { for (l = a.child; l;) { if (l === n) { s = !0, n = a, r = i; break } if (l === r) { s = !0, r = a, n = i; break } l = l.sibling } if (!s) throw Error(o(189)) } } if (n.alternate !== r) throw Error(o(190)) } if (3 !== n.tag) throw Error(o(188)); return n.stateNode.current === n ? e : t }(e)) ? Qe(e) : null } function Qe(e) { if (5 === e.tag || 6 === e.tag) return e; for (e = e.child; null !== e;) { var t = Qe(e); if (null !== t) return t; e = e.sibling } return null } var qe = i.unstable_scheduleCallback, Ze = i.unstable_cancelCallback, Ke = i.unstable_shouldYield, Ge = i.unstable_requestPaint, Je = i.unstable_now, _e = i.unstable_getCurrentPriorityLevel, $e = i.unstable_ImmediatePriority, et = i.unstable_UserBlockingPriority, tt = i.unstable_NormalPriority, nt = i.unstable_LowPriority, rt = i.unstable_IdlePriority, it = null, ot = null; var at = Math.clz32 ? Math.clz32 : function (e) { return e >>>= 0, 0 === e ? 32 : 31 - (st(e) / lt | 0) | 0 }, st = Math.log, lt = Math.LN2; var ct = 64, ut = 4194304; function dt(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function ht(e, t) { var n = e.pendingLanes; if (0 === n) return 0; var r = 0, i = e.suspendedLanes, o = e.pingedLanes, a = 268435455 & n; if (0 !== a) { var s = a & ~i; 0 !== s ? r = dt(s) : 0 !== (o &= a) && (r = dt(o)) } else 0 !== (a = n & ~i) ? r = dt(a) : 0 !== o && (r = dt(o)); if (0 === r) return 0; if (0 !== t && t !== r && 0 === (t & i) && ((i = r & -r) >= (o = t & -t) || 16 === i && 0 !== (4194240 & o))) return t; if (0 !== (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes)) for (e = e.entanglements, t &= r; 0 < t;)i = 1 << (n = 31 - at(t)), r |= e[n], t &= ~i; return r } function ft(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; default: return -1 } } function pt(e) { return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0 } function mt() { var e = ct; return 0 === (4194240 & (ct <<= 1)) && (ct = 64), e } function gt(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function vt(e, t, n) { e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - at(t)] = n } function yt(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - at(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var bt = 0; function xt(e) { return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1 } var wt, kt, St, At, Et, Ct = !1, Pt = [], jt = null, Nt = null, Mt = null, Tt = new Map, It = new Map, Lt = [], Rt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Dt(e, t) { switch (e) { case "focusin": case "focusout": jt = null; break; case "dragenter": case "dragleave": Nt = null; break; case "mouseover": case "mouseout": Mt = null; break; case "pointerover": case "pointerout": Tt.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": It.delete(t.pointerId) } } function zt(e, t, n, r, i, o) { return null === e || e.nativeEvent !== o ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: o, targetContainers: [i] }, null !== t && (null !== (t = bi(t)) && kt(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e) } function Ot(e) { var t = yi(e.target); if (null !== t) { var n = We(t); if (null !== n) if (13 === (t = n.tag)) { if (null !== (t = He(n))) return e.blockedOn = t, void Et(e.priority, (function () { St(n) })) } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void (e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null) } e.blockedOn = null } function Bt(e) { if (null !== e.blockedOn) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = Kt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (null !== n) return null !== (t = bi(n)) && kt(t), e.blockedOn = n, !1; var r = new (n = e.nativeEvent).constructor(n.type, n); xe = r, n.target.dispatchEvent(r), xe = null, t.shift() } return !0 } function Ft(e, t, n) { Bt(e) && n.delete(t) } function Vt() { Ct = !1, null !== jt && Bt(jt) && (jt = null), null !== Nt && Bt(Nt) && (Nt = null), null !== Mt && Bt(Mt) && (Mt = null), Tt.forEach(Ft), It.forEach(Ft) } function Ut(e, t) { e.blockedOn === t && (e.blockedOn = null, Ct || (Ct = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, Vt))) } function Wt(e) { function t(t) { return Ut(t, e) } if (0 < Pt.length) { Ut(Pt[0], e); for (var n = 1; n < Pt.length; n++) { var r = Pt[n]; r.blockedOn === e && (r.blockedOn = null) } } for (null !== jt && Ut(jt, e), null !== Nt && Ut(Nt, e), null !== Mt && Ut(Mt, e), Tt.forEach(t), It.forEach(t), n = 0; n < Lt.length; n++)(r = Lt[n]).blockedOn === e && (r.blockedOn = null); for (; 0 < Lt.length && null === (n = Lt[0]).blockedOn;)Ot(n), null === n.blockedOn && Lt.shift() } var Ht = x.ReactCurrentBatchConfig, Yt = !0; function Xt(e, t, n, r) { var i = bt, o = Ht.transition; Ht.transition = null; try { bt = 1, qt(e, t, n, r) } finally { bt = i, Ht.transition = o } } function Qt(e, t, n, r) { var i = bt, o = Ht.transition; Ht.transition = null; try { bt = 4, qt(e, t, n, r) } finally { bt = i, Ht.transition = o } } function qt(e, t, n, r) { if (Yt) { var i = Kt(e, t, n, r); if (null === i) Yr(e, t, r, Zt, n), Dt(e, r); else if (function (e, t, n, r, i) { switch (t) { case "focusin": return jt = zt(jt, e, t, n, r, i), !0; case "dragenter": return Nt = zt(Nt, e, t, n, r, i), !0; case "mouseover": return Mt = zt(Mt, e, t, n, r, i), !0; case "pointerover": var o = i.pointerId; return Tt.set(o, zt(Tt.get(o) || null, e, t, n, r, i)), !0; case "gotpointercapture": return o = i.pointerId, It.set(o, zt(It.get(o) || null, e, t, n, r, i)), !0 }return !1 }(i, e, t, n, r)) r.stopPropagation(); else if (Dt(e, r), 4 & t && -1 < Rt.indexOf(e)) { for (; null !== i;) { var o = bi(i); if (null !== o && wt(o), null === (o = Kt(e, t, n, r)) && Yr(e, t, r, Zt, n), o === i) break; i = o } null !== i && r.stopPropagation() } else Yr(e, t, r, null, n) } } var Zt = null; function Kt(e, t, n, r) { if (Zt = null, null !== (e = yi(e = we(r)))) if (null === (t = We(e))) e = null; else if (13 === (n = t.tag)) { if (null !== (e = He(t))) return e; e = null } else if (3 === n) { if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Zt = e, null } function Gt(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (_e()) { case $e: return 1; case et: return 4; case tt: case nt: return 16; case rt: return 536870912; default: return 16 }default: return 16 } } var Jt = null, _t = null, $t = null; function en() { if ($t) return $t; var e, t, n = _t, r = n.length, i = "value" in Jt ? Jt.value : Jt.textContent, o = i.length; for (e = 0; e < r && n[e] === i[e]; e++); var a = r - e; for (t = 1; t <= a && n[r - t] === i[o - t]; t++); return $t = i.slice(e, 1 < t ? 1 - t : void 0) } function tn(e) { var t = e.keyCode; return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0 } function nn() { return !0 } function rn() { return !1 } function on(e) { function t(t, n, r, i, o) { for (var a in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = o, this.currentTarget = null, e) e.hasOwnProperty(a) && (t = e[a], this[a] = t ? t(i) : i[a]); return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn, this.isPropagationStopped = rn, this } return O(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var e = this.nativeEvent; e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn) }, stopPropagation: function () { var e = this.nativeEvent; e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn) }, persist: function () { }, isPersistent: nn }), t } var an, sn, ln, cn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, un = on(cn), dn = O({}, cn, { view: 0, detail: 0 }), hn = on(dn), fn = O({}, dn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: En, button: 0, buttons: 0, relatedTarget: function (e) { return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (an = e.screenX - ln.screenX, sn = e.screenY - ln.screenY) : sn = an = 0, ln = e), an) }, movementY: function (e) { return "movementY" in e ? e.movementY : sn } }), pn = on(fn), mn = on(O({}, fn, { dataTransfer: 0 })), gn = on(O({}, dn, { relatedTarget: 0 })), vn = on(O({}, cn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })), yn = O({}, cn, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), bn = on(yn), xn = on(O({}, cn, { data: 0 })), wn = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, kn = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Sn = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function An(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = Sn[e]) && !!t[e] } function En() { return An } var Cn = O({}, dn, { key: function (e) { if (e.key) { var t = wn[e.key] || e.key; if ("Unidentified" !== t) return t } return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? kn[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: En, charCode: function (e) { return "keypress" === e.type ? tn(e) : 0 }, keyCode: function (e) { return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 }, which: function (e) { return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 } }), Pn = on(Cn), jn = on(O({}, fn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 })), Nn = on(O({}, dn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: En })), Mn = on(O({}, cn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })), Tn = O({}, fn, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), In = on(Tn), Ln = [9, 13, 27, 32], Rn = u && "CompositionEvent" in window, Dn = null; u && "documentMode" in document && (Dn = document.documentMode); var zn = u && "TextEvent" in window && !Dn, On = u && (!Rn || Dn && 8 < Dn && 11 >= Dn), Bn = String.fromCharCode(32), Fn = !1; function Vn(e, t) { switch (e) { case "keyup": return -1 !== Ln.indexOf(t.keyCode); case "keydown": return 229 !== t.keyCode; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Un(e) { return "object" === typeof (e = e.detail) && "data" in e ? e.data : null } var Wn = !1; var Hn = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Yn(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return "input" === t ? !!Hn[e.type] : "textarea" === t } function Xn(e, t, n, r) { Ce(r), 0 < (t = Qr(t, "onChange")).length && (n = new un("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var Qn = null, qn = null; function Zn(e) { Br(e, 0) } function Kn(e) { if (q(xi(e))) return e } function Gn(e, t) { if ("change" === e) return t } var Jn = !1; if (u) { var _n; if (u) { var $n = "oninput" in document; if (!$n) { var er = document.createElement("div"); er.setAttribute("oninput", "return;"), $n = "function" === typeof er.oninput } _n = $n } else _n = !1; Jn = _n && (!document.documentMode || 9 < document.documentMode) } function tr() { Qn && (Qn.detachEvent("onpropertychange", nr), qn = Qn = null) } function nr(e) { if ("value" === e.propertyName && Kn(qn)) { var t = []; Xn(t, qn, e, we(e)), Te(Zn, t) } } function rr(e, t, n) { "focusin" === e ? (tr(), qn = n, (Qn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr() } function ir(e) { if ("selectionchange" === e || "keyup" === e || "keydown" === e) return Kn(qn) } function or(e, t) { if ("click" === e) return Kn(t) } function ar(e, t) { if ("input" === e || "change" === e) return Kn(t) } var sr = "function" === typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t }; function lr(e, t) { if (sr(e, t)) return !0; if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!d.call(t, i) || !sr(e[i], t[i])) return !1 } return !0 } function cr(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function ur(e, t) { var n, r = cr(e); for (e = 0; r;) { if (3 === r.nodeType) { if (n = e + r.textContent.length, e <= t && n >= t) return { node: r, offset: t - e }; e = n } e: { for (; r;) { if (r.nextSibling) { r = r.nextSibling; break e } r = r.parentNode } r = void 0 } r = cr(r) } } function dr(e, t) { return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? dr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))) } function hr() { for (var e = window, t = Z(); t instanceof e.HTMLIFrameElement;) { try { var n = "string" === typeof t.contentWindow.location.href } catch (r) { n = !1 } if (!n) break; t = Z((e = t.contentWindow).document) } return t } function fr(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable) } function pr(e) { var t = hr(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && dr(n.ownerDocument.documentElement, n)) { if (null !== r && fr(n)) if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) { e = e.getSelection(); var i = n.textContent.length, o = Math.min(r.start, i); r = void 0 === r.end ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = ur(n, o); var a = ur(n, r); i && a && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== a.node || e.focusOffset !== a.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(a.node, a.offset)) : (t.setEnd(a.node, a.offset), e.addRange(t))) } for (t = [], e = n; e = e.parentNode;)1 === e.nodeType && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for ("function" === typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top } } var mr = u && "documentMode" in document && 11 >= document.documentMode, gr = null, vr = null, yr = null, br = !1; function xr(e, t, n) { var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument; br || null == gr || gr !== Z(r) || ("selectionStart" in (r = gr) && fr(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : r = { anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }, yr && lr(yr, r) || (yr = r, 0 < (r = Qr(vr, "onSelect")).length && (t = new un("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = gr))) } function wr(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var kr = { animationend: wr("Animation", "AnimationEnd"), animationiteration: wr("Animation", "AnimationIteration"), animationstart: wr("Animation", "AnimationStart"), transitionend: wr("Transition", "TransitionEnd") }, Sr = {}, Ar = {}; function Er(e) { if (Sr[e]) return Sr[e]; if (!kr[e]) return e; var t, n = kr[e]; for (t in n) if (n.hasOwnProperty(t) && t in Ar) return Sr[e] = n[t]; return e } u && (Ar = document.createElement("div").style, "AnimationEvent" in window || (delete kr.animationend.animation, delete kr.animationiteration.animation, delete kr.animationstart.animation), "TransitionEvent" in window || delete kr.transitionend.transition); var Cr = Er("animationend"), Pr = Er("animationiteration"), jr = Er("animationstart"), Nr = Er("transitionend"), Mr = new Map, Tr = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Ir(e, t) { Mr.set(e, t), l(t, [e]) } for (var Lr = 0; Lr < Tr.length; Lr++) { var Rr = Tr[Lr]; Ir(Rr.toLowerCase(), "on" + (Rr[0].toUpperCase() + Rr.slice(1))) } Ir(Cr, "onAnimationEnd"), Ir(Pr, "onAnimationIteration"), Ir(jr, "onAnimationStart"), Ir("dblclick", "onDoubleClick"), Ir("focusin", "onFocus"), Ir("focusout", "onBlur"), Ir(Nr, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Dr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), zr = new Set("cancel close invalid load scroll toggle".split(" ").concat(Dr)); function Or(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, function (e, t, n, r, i, a, s, l, c) { if (Ue.apply(this, arguments), ze) { if (!ze) throw Error(o(198)); var u = Oe; ze = !1, Oe = null, Be || (Be = !0, Fe = u) } }(r, t, void 0, e), e.currentTarget = null } function Br(e, t) { t = 0 !== (4 & t); for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var o = void 0; if (t) for (var a = r.length - 1; 0 <= a; a--) { var s = r[a], l = s.instance, c = s.currentTarget; if (s = s.listener, l !== o && i.isPropagationStopped()) break e; Or(i, s, c), o = l } else for (a = 0; a < r.length; a++) { if (l = (s = r[a]).instance, c = s.currentTarget, s = s.listener, l !== o && i.isPropagationStopped()) break e; Or(i, s, c), o = l } } } if (Be) throw e = Fe, Be = !1, Fe = null, e } function Fr(e, t) { var n = t[mi]; void 0 === n && (n = t[mi] = new Set); var r = e + "__bubble"; n.has(r) || (Hr(t, e, 2, !1), n.add(r)) } function Vr(e, t, n) { var r = 0; t && (r |= 4), Hr(n, e, r, t) } var Ur = "_reactListening" + Math.random().toString(36).slice(2); function Wr(e) { if (!e[Ur]) { e[Ur] = !0, a.forEach((function (t) { "selectionchange" !== t && (zr.has(t) || Vr(t, !1, e), Vr(t, !0, e)) })); var t = 9 === e.nodeType ? e : e.ownerDocument; null === t || t[Ur] || (t[Ur] = !0, Vr("selectionchange", !1, t)) } } function Hr(e, t, n, r) { switch (Gt(t)) { case 1: var i = Xt; break; case 4: i = Qt; break; default: i = qt }n = i.bind(null, t, n, e), i = void 0, !Le || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function Yr(e, t, n, r, i) { var o = r; if (0 === (1 & t) && 0 === (2 & t) && null !== r) e: for (; ;) { if (null === r) return; var a = r.tag; if (3 === a || 4 === a) { var s = r.stateNode.containerInfo; if (s === i || 8 === s.nodeType && s.parentNode === i) break; if (4 === a) for (a = r.return; null !== a;) { var l = a.tag; if ((3 === l || 4 === l) && ((l = a.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i)) return; a = a.return } for (; null !== s;) { if (null === (a = yi(s))) return; if (5 === (l = a.tag) || 6 === l) { r = o = a; continue e } s = s.parentNode } } r = r.return } Te((function () { var r = o, i = we(n), a = []; e: { var s = Mr.get(e); if (void 0 !== s) { var l = un, c = e; switch (e) { case "keypress": if (0 === tn(n)) break e; case "keydown": case "keyup": l = Pn; break; case "focusin": c = "focus", l = gn; break; case "focusout": c = "blur", l = gn; break; case "beforeblur": case "afterblur": l = gn; break; case "click": if (2 === n.button) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": l = pn; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": l = mn; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": l = Nn; break; case Cr: case Pr: case jr: l = vn; break; case Nr: l = Mn; break; case "scroll": l = hn; break; case "wheel": l = In; break; case "copy": case "cut": case "paste": l = bn; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": l = jn }var u = 0 !== (4 & t), d = !u && "scroll" === e, h = u ? null !== s ? s + "Capture" : null : s; u = []; for (var f, p = r; null !== p;) { var m = (f = p).stateNode; if (5 === f.tag && null !== m && (f = m, null !== h && (null != (m = Ie(p, h)) && u.push(Xr(p, m, f)))), d) break; p = p.return } 0 < u.length && (s = new l(s, c, null, n, i), a.push({ event: s, listeners: u })) } } if (0 === (7 & t)) { if (l = "mouseout" === e || "pointerout" === e, (!(s = "mouseover" === e || "pointerover" === e) || n === xe || !(c = n.relatedTarget || n.fromElement) || !yi(c) && !c[pi]) && (l || s) && (s = i.window === i ? i : (s = i.ownerDocument) ? s.defaultView || s.parentWindow : window, l ? (l = r, null !== (c = (c = n.relatedTarget || n.toElement) ? yi(c) : null) && (c !== (d = We(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null, c = r), l !== c)) { if (u = pn, m = "onMouseLeave", h = "onMouseEnter", p = "mouse", "pointerout" !== e && "pointerover" !== e || (u = jn, m = "onPointerLeave", h = "onPointerEnter", p = "pointer"), d = null == l ? s : xi(l), f = null == c ? s : xi(c), (s = new u(m, p + "leave", l, n, i)).target = d, s.relatedTarget = f, m = null, yi(i) === r && ((u = new u(h, p + "enter", c, n, i)).target = f, u.relatedTarget = d, m = u), d = m, l && c) e: { for (h = c, p = 0, f = u = l; f; f = qr(f))p++; for (f = 0, m = h; m; m = qr(m))f++; for (; 0 < p - f;)u = qr(u), p--; for (; 0 < f - p;)h = qr(h), f--; for (; p--;) { if (u === h || null !== h && u === h.alternate) break e; u = qr(u), h = qr(h) } u = null } else u = null; null !== l && Zr(a, s, l, u, !1), null !== c && null !== d && Zr(a, d, c, u, !0) } if ("select" === (l = (s = r ? xi(r) : window).nodeName && s.nodeName.toLowerCase()) || "input" === l && "file" === s.type) var g = Gn; else if (Yn(s)) if (Jn) g = ar; else { g = ir; var v = rr } else (l = s.nodeName) && "input" === l.toLowerCase() && ("checkbox" === s.type || "radio" === s.type) && (g = or); switch (g && (g = g(e, r)) ? Xn(a, g, n, i) : (v && v(e, s, r), "focusout" === e && (v = s._wrapperState) && v.controlled && "number" === s.type && ee(s, "number", s.value)), v = r ? xi(r) : window, e) { case "focusin": (Yn(v) || "true" === v.contentEditable) && (gr = v, vr = r, yr = null); break; case "focusout": yr = vr = gr = null; break; case "mousedown": br = !0; break; case "contextmenu": case "mouseup": case "dragend": br = !1, xr(a, n, i); break; case "selectionchange": if (mr) break; case "keydown": case "keyup": xr(a, n, i) }var y; if (Rn) e: { switch (e) { case "compositionstart": var b = "onCompositionStart"; break e; case "compositionend": b = "onCompositionEnd"; break e; case "compositionupdate": b = "onCompositionUpdate"; break e }b = void 0 } else Wn ? Vn(e, n) && (b = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (b = "onCompositionStart"); b && (On && "ko" !== n.locale && (Wn || "onCompositionStart" !== b ? "onCompositionEnd" === b && Wn && (y = en()) : (_t = "value" in (Jt = i) ? Jt.value : Jt.textContent, Wn = !0)), 0 < (v = Qr(r, b)).length && (b = new xn(b, e, null, n, i), a.push({ event: b, listeners: v }), y ? b.data = y : null !== (y = Un(n)) && (b.data = y))), (y = zn ? function (e, t) { switch (e) { case "compositionend": return Un(t); case "keypress": return 32 !== t.which ? null : (Fn = !0, Bn); case "textInput": return (e = t.data) === Bn && Fn ? null : e; default: return null } }(e, n) : function (e, t) { if (Wn) return "compositionend" === e || !Rn && Vn(e, t) ? (e = en(), $t = _t = Jt = null, Wn = !1, e) : null; switch (e) { case "paste": default: return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return On && "ko" !== t.locale ? null : t.data } }(e, n)) && (0 < (r = Qr(r, "onBeforeInput")).length && (i = new xn("onBeforeInput", "beforeinput", null, n, i), a.push({ event: i, listeners: r }), i.data = y)) } Br(a, t) })) } function Xr(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Qr(e, t) { for (var n = t + "Capture", r = []; null !== e;) { var i = e, o = i.stateNode; 5 === i.tag && null !== o && (i = o, null != (o = Ie(e, n)) && r.unshift(Xr(e, o, i)), null != (o = Ie(e, t)) && r.push(Xr(e, o, i))), e = e.return } return r } function qr(e) { if (null === e) return null; do { e = e.return } while (e && 5 !== e.tag); return e || null } function Zr(e, t, n, r, i) { for (var o = t._reactName, a = []; null !== n && n !== r;) { var s = n, l = s.alternate, c = s.stateNode; if (null !== l && l === r) break; 5 === s.tag && null !== c && (s = c, i ? null != (l = Ie(n, o)) && a.unshift(Xr(n, l, s)) : i || null != (l = Ie(n, o)) && a.push(Xr(n, l, s))), n = n.return } 0 !== a.length && e.push({ event: t, listeners: a }) } var Kr = /\r\n?/g, Gr = /\u0000|\uFFFD/g; function Jr(e) { return ("string" === typeof e ? e : "" + e).replace(Kr, "\n").replace(Gr, "") } function _r(e, t, n) { if (t = Jr(t), Jr(e) !== t && n) throw Error(o(425)) } function $r() { } var ei = null, ti = null; function ni(e, t) { return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html } var ri = "function" === typeof setTimeout ? setTimeout : void 0, ii = "function" === typeof clearTimeout ? clearTimeout : void 0, oi = "function" === typeof Promise ? Promise : void 0, ai = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof oi ? function (e) { return oi.resolve(null).then(e).catch(si) } : ri; function si(e) { setTimeout((function () { throw e })) } function li(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && 8 === i.nodeType) if ("/$" === (n = i.data)) { if (0 === r) return e.removeChild(i), void Wt(t); r-- } else "$" !== n && "$?" !== n && "$!" !== n || r++; n = i } while (n); Wt(t) } function ci(e) { for (; null != e; e = e.nextSibling) { var t = e.nodeType; if (1 === t || 3 === t) break; if (8 === t) { if ("$" === (t = e.data) || "$!" === t || "$?" === t) break; if ("/$" === t) return null } } return e } function ui(e) { e = e.previousSibling; for (var t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("$" === n || "$!" === n || "$?" === n) { if (0 === t) return e; t-- } else "/$" === n && t++ } e = e.previousSibling } return null } var di = Math.random().toString(36).slice(2), hi = "__reactFiber$" + di, fi = "__reactProps$" + di, pi = "__reactContainer$" + di, mi = "__reactEvents$" + di, gi = "__reactListeners$" + di, vi = "__reactHandles$" + di; function yi(e) { var t = e[hi]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[pi] || n[hi]) { if (n = t.alternate, null !== t.child || null !== n && null !== n.child) for (e = ui(e); null !== e;) { if (n = e[hi]) return n; e = ui(e) } return t } n = (e = n).parentNode } return null } function bi(e) { return !(e = e[hi] || e[pi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e } function xi(e) { if (5 === e.tag || 6 === e.tag) return e.stateNode; throw Error(o(33)) } function wi(e) { return e[fi] || null } var ki = [], Si = -1; function Ai(e) { return { current: e } } function Ei(e) { 0 > Si || (e.current = ki[Si], ki[Si] = null, Si--) } function Ci(e, t) { Si++, ki[Si] = e.current, e.current = t } var Pi = {}, ji = Ai(Pi), Ni = Ai(!1), Mi = Pi; function Ti(e, t) { var n = e.type.contextTypes; if (!n) return Pi; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i, o = {}; for (i in n) o[i] = t[i]; return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o } function Ii(e) { return null !== (e = e.childContextTypes) && void 0 !== e } function Li() { Ei(Ni), Ei(ji) } function Ri(e, t, n) { if (ji.current !== Pi) throw Error(o(168)); Ci(ji, t), Ci(Ni, n) } function Di(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, "function" !== typeof r.getChildContext) return n; for (var i in r = r.getChildContext()) if (!(i in t)) throw Error(o(108, H(e) || "Unknown", i)); return O({}, n, r) } function zi(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Pi, Mi = ji.current, Ci(ji, e), Ci(Ni, Ni.current), !0 } function Oi(e, t, n) { var r = e.stateNode; if (!r) throw Error(o(169)); n ? (e = Di(e, t, Mi), r.__reactInternalMemoizedMergedChildContext = e, Ei(Ni), Ei(ji), Ci(ji, e)) : Ei(Ni), Ci(Ni, n) } var Bi = null, Fi = !1, Vi = !1; function Ui(e) { null === Bi ? Bi = [e] : Bi.push(e) } function Wi() { if (!Vi && null !== Bi) { Vi = !0; var e = 0, t = bt; try { var n = Bi; for (bt = 1; e < n.length; e++) { var r = n[e]; do { r = r(!0) } while (null !== r) } Bi = null, Fi = !1 } catch (i) { throw null !== Bi && (Bi = Bi.slice(e + 1)), qe($e, Wi), i } finally { bt = t, Vi = !1 } } return null } var Hi = [], Yi = 0, Xi = null, Qi = 0, qi = [], Zi = 0, Ki = null, Gi = 1, Ji = ""; function _i(e, t) { Hi[Yi++] = Qi, Hi[Yi++] = Xi, Xi = e, Qi = t } function $i(e, t, n) { qi[Zi++] = Gi, qi[Zi++] = Ji, qi[Zi++] = Ki, Ki = e; var r = Gi; e = Ji; var i = 32 - at(r) - 1; r &= ~(1 << i), n += 1; var o = 32 - at(t) + i; if (30 < o) { var a = i - i % 5; o = (r & (1 << a) - 1).toString(32), r >>= a, i -= a, Gi = 1 << 32 - at(t) + i | n << i | r, Ji = o + e } else Gi = 1 << o | n << i | r, Ji = e } function eo(e) { null !== e.return && (_i(e, 1), $i(e, 1, 0)) } function to(e) { for (; e === Xi;)Xi = Hi[--Yi], Hi[Yi] = null, Qi = Hi[--Yi], Hi[Yi] = null; for (; e === Ki;)Ki = qi[--Zi], qi[Zi] = null, Ji = qi[--Zi], qi[Zi] = null, Gi = qi[--Zi], qi[Zi] = null } var no = null, ro = null, io = !1, oo = null; function ao(e, t) { var n = Tc(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function so(e, t) { switch (e.tag) { case 5: var n = e.type; return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, no = e, ro = ci(t.firstChild), !0); case 6: return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, no = e, ro = null, !0); case 13: return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== Ki ? { id: Gi, overflow: Ji } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, (n = Tc(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, no = e, ro = null, !0); default: return !1 } } function lo(e) { return 0 !== (1 & e.mode) && 0 === (128 & e.flags) } function co(e) { if (io) { var t = ro; if (t) { var n = t; if (!so(e, t)) { if (lo(e)) throw Error(o(418)); t = ci(n.nextSibling); var r = no; t && so(e, t) ? ao(r, n) : (e.flags = -4097 & e.flags | 2, io = !1, no = e) } } else { if (lo(e)) throw Error(o(418)); e.flags = -4097 & e.flags | 2, io = !1, no = e } } } function uo(e) { for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;)e = e.return; no = e } function ho(e) { if (e !== no) return !1; if (!io) return uo(e), io = !0, !1; var t; if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)), t && (t = ro)) { if (lo(e)) throw fo(), Error(o(418)); for (; t;)ao(e, t), t = ci(t.nextSibling) } if (uo(e), 13 === e.tag) { if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(o(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("/$" === n) { if (0 === t) { ro = ci(e.nextSibling); break e } t-- } else "$" !== n && "$!" !== n && "$?" !== n || t++ } e = e.nextSibling } ro = null } } else ro = no ? ci(e.stateNode.nextSibling) : null; return !0 } function fo() { for (var e = ro; e;)e = ci(e.nextSibling) } function po() { ro = no = null, io = !1 } function mo(e) { null === oo ? oo = [e] : oo.push(e) } var go = x.ReactCurrentBatchConfig; function vo(e, t, n) { if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) { if (n._owner) { if (n = n._owner) { if (1 !== n.tag) throw Error(o(309)); var r = n.stateNode } if (!r) throw Error(o(147, e)); var i = r, a = "" + e; return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === a ? t.ref : (t = function (e) { var t = i.refs; null === e ? delete t[a] : t[a] = e }, t._stringRef = a, t) } if ("string" !== typeof e) throw Error(o(284)); if (!n._owner) throw Error(o(290, e)) } return e } function yo(e, t) { throw e = Object.prototype.toString.call(t), Error(o(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function bo(e) { return (0, e._init)(e._payload) } function xo(e) { function t(t, n) { if (e) { var r = t.deletions; null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n) } } function n(n, r) { if (!e) return null; for (; null !== r;)t(n, r), r = r.sibling; return null } function r(e, t) { for (e = new Map; null !== t;)null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling; return e } function i(e, t) { return (e = Lc(e, t)).index = 0, e.sibling = null, e } function a(t, n, r) { return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n) } function s(t) { return e && null === t.alternate && (t.flags |= 2), t } function l(e, t, n, r) { return null === t || 6 !== t.tag ? ((t = Oc(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t) } function c(e, t, n, r) { var o = n.type; return o === S ? d(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === o || "object" === typeof o && null !== o && o.$$typeof === I && bo(o) === t.type) ? ((r = i(t, n.props)).ref = vo(e, t, n), r.return = e, r) : ((r = Rc(n.type, n.key, n.props, null, e.mode, r)).ref = vo(e, t, n), r.return = e, r) } function u(e, t, n, r) { return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Bc(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t) } function d(e, t, n, r, o) { return null === t || 7 !== t.tag ? ((t = Dc(n, e.mode, r, o)).return = e, t) : ((t = i(t, n)).return = e, t) } function h(e, t, n) { if ("string" === typeof t && "" !== t || "number" === typeof t) return (t = Oc("" + t, e.mode, n)).return = e, t; if ("object" === typeof t && null !== t) { switch (t.$$typeof) { case w: return (n = Rc(t.type, t.key, t.props, null, e.mode, n)).ref = vo(e, null, t), n.return = e, n; case k: return (t = Bc(t, e.mode, n)).return = e, t; case I: return h(e, (0, t._init)(t._payload), n) }if (te(t) || D(t)) return (t = Dc(t, e.mode, n, null)).return = e, t; yo(e, t) } return null } function f(e, t, n, r) { var i = null !== t ? t.key : null; if ("string" === typeof n && "" !== n || "number" === typeof n) return null !== i ? null : l(e, t, "" + n, r); if ("object" === typeof n && null !== n) { switch (n.$$typeof) { case w: return n.key === i ? c(e, t, n, r) : null; case k: return n.key === i ? u(e, t, n, r) : null; case I: return f(e, t, (i = n._init)(n._payload), r) }if (te(n) || D(n)) return null !== i ? null : d(e, t, n, r, null); yo(e, n) } return null } function p(e, t, n, r, i) { if ("string" === typeof r && "" !== r || "number" === typeof r) return l(t, e = e.get(n) || null, "" + r, i); if ("object" === typeof r && null !== r) { switch (r.$$typeof) { case w: return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case k: return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case I: return p(e, t, n, (0, r._init)(r._payload), i) }if (te(r) || D(r)) return d(t, e = e.get(n) || null, r, i, null); yo(t, r) } return null } function m(i, o, s, l) { for (var c = null, u = null, d = o, m = o = 0, g = null; null !== d && m < s.length; m++) { d.index > m ? (g = d, d = null) : g = d.sibling; var v = f(i, d, s[m], l); if (null === v) { null === d && (d = g); break } e && d && null === v.alternate && t(i, d), o = a(v, o, m), null === u ? c = v : u.sibling = v, u = v, d = g } if (m === s.length) return n(i, d), io && _i(i, m), c; if (null === d) { for (; m < s.length; m++)null !== (d = h(i, s[m], l)) && (o = a(d, o, m), null === u ? c = d : u.sibling = d, u = d); return io && _i(i, m), c } for (d = r(i, d); m < s.length; m++)null !== (g = p(d, i, m, s[m], l)) && (e && null !== g.alternate && d.delete(null === g.key ? m : g.key), o = a(g, o, m), null === u ? c = g : u.sibling = g, u = g); return e && d.forEach((function (e) { return t(i, e) })), io && _i(i, m), c } function g(i, s, l, c) { var u = D(l); if ("function" !== typeof u) throw Error(o(150)); if (null == (l = u.call(l))) throw Error(o(151)); for (var d = u = null, m = s, g = s = 0, v = null, y = l.next(); null !== m && !y.done; g++, y = l.next()) { m.index > g ? (v = m, m = null) : v = m.sibling; var b = f(i, m, y.value, c); if (null === b) { null === m && (m = v); break } e && m && null === b.alternate && t(i, m), s = a(b, s, g), null === d ? u = b : d.sibling = b, d = b, m = v } if (y.done) return n(i, m), io && _i(i, g), u; if (null === m) { for (; !y.done; g++, y = l.next())null !== (y = h(i, y.value, c)) && (s = a(y, s, g), null === d ? u = y : d.sibling = y, d = y); return io && _i(i, g), u } for (m = r(i, m); !y.done; g++, y = l.next())null !== (y = p(m, i, g, y.value, c)) && (e && null !== y.alternate && m.delete(null === y.key ? g : y.key), s = a(y, s, g), null === d ? u = y : d.sibling = y, d = y); return e && m.forEach((function (e) { return t(i, e) })), io && _i(i, g), u } return function e(r, o, a, l) { if ("object" === typeof a && null !== a && a.type === S && null === a.key && (a = a.props.children), "object" === typeof a && null !== a) { switch (a.$$typeof) { case w: e: { for (var c = a.key, u = o; null !== u;) { if (u.key === c) { if ((c = a.type) === S) { if (7 === u.tag) { n(r, u.sibling), (o = i(u, a.props.children)).return = r, r = o; break e } } else if (u.elementType === c || "object" === typeof c && null !== c && c.$$typeof === I && bo(c) === u.type) { n(r, u.sibling), (o = i(u, a.props)).ref = vo(r, u, a), o.return = r, r = o; break e } n(r, u); break } t(r, u), u = u.sibling } a.type === S ? ((o = Dc(a.props.children, r.mode, l, a.key)).return = r, r = o) : ((l = Rc(a.type, a.key, a.props, null, r.mode, l)).ref = vo(r, o, a), l.return = r, r = l) } return s(r); case k: e: { for (u = a.key; null !== o;) { if (o.key === u) { if (4 === o.tag && o.stateNode.containerInfo === a.containerInfo && o.stateNode.implementation === a.implementation) { n(r, o.sibling), (o = i(o, a.children || [])).return = r, r = o; break e } n(r, o); break } t(r, o), o = o.sibling } (o = Bc(a, r.mode, l)).return = r, r = o } return s(r); case I: return e(r, o, (u = a._init)(a._payload), l) }if (te(a)) return m(r, o, a, l); if (D(a)) return g(r, o, a, l); yo(r, a) } return "string" === typeof a && "" !== a || "number" === typeof a ? (a = "" + a, null !== o && 6 === o.tag ? (n(r, o.sibling), (o = i(o, a)).return = r, r = o) : (n(r, o), (o = Oc(a, r.mode, l)).return = r, r = o), s(r)) : n(r, o) } } var wo = xo(!0), ko = xo(!1), So = Ai(null), Ao = null, Eo = null, Co = null; function Po() { Co = Eo = Ao = null } function jo(e) { var t = So.current; Ei(So), e._currentValue = t } function No(e, t, n) { for (; null !== e;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function Mo(e, t) { Ao = e, Co = Eo = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (bs = !0), e.firstContext = null) } function To(e) { var t = e._currentValue; if (Co !== e) if (e = { context: e, memoizedValue: t, next: null }, null === Eo) { if (null === Ao) throw Error(o(308)); Eo = e, Ao.dependencies = { lanes: 0, firstContext: e } } else Eo = Eo.next = e; return t } var Io = null; function Lo(e) { null === Io ? Io = [e] : Io.push(e) } function Ro(e, t, n, r) { var i = t.interleaved; return null === i ? (n.next = n, Lo(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Do(e, r) } function Do(e, t) { e.lanes |= t; var n = e.alternate; for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;)e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return; return 3 === n.tag ? n.stateNode : null } var zo = !1; function Oo(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Bo(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Fo(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Vo(e, t, n) { var r = e.updateQueue; if (null === r) return null; if (r = r.shared, 0 !== (2 & jl)) { var i = r.pending; return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Do(e, n) } return null === (i = r.interleaved) ? (t.next = t, Lo(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Do(e, n) } function Uo(e, t, n) { if (null !== (t = t.updateQueue) && (t = t.shared, 0 !== (4194240 & n))) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, yt(e, n) } } function Wo(e, t) { var n = e.updateQueue, r = e.alternate; if (null !== r && n === (r = r.updateQueue)) { var i = null, o = null; if (null !== (n = n.firstBaseUpdate)) { do { var a = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; null === o ? i = o = a : o = o.next = a, n = n.next } while (null !== n); null === o ? i = o = t : o = o.next = t } else i = o = t; return n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: o, shared: r.shared, effects: r.effects }, void (e.updateQueue = n) } null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Ho(e, t, n, r) { var i = e.updateQueue; zo = !1; var o = i.firstBaseUpdate, a = i.lastBaseUpdate, s = i.shared.pending; if (null !== s) { i.shared.pending = null; var l = s, c = l.next; l.next = null, null === a ? o = c : a.next = c, a = l; var u = e.alternate; null !== u && ((s = (u = u.updateQueue).lastBaseUpdate) !== a && (null === s ? u.firstBaseUpdate = c : s.next = c, u.lastBaseUpdate = l)) } if (null !== o) { var d = i.baseState; for (a = 0, u = c = l = null, s = o; ;) { var h = s.lane, f = s.eventTime; if ((r & h) === h) { null !== u && (u = u.next = { eventTime: f, lane: 0, tag: s.tag, payload: s.payload, callback: s.callback, next: null }); e: { var p = e, m = s; switch (h = t, f = n, m.tag) { case 1: if ("function" === typeof (p = m.payload)) { d = p.call(f, d, h); break e } d = p; break e; case 3: p.flags = -65537 & p.flags | 128; case 0: if (null === (h = "function" === typeof (p = m.payload) ? p.call(f, d, h) : p) || void 0 === h) break e; d = O({}, d, h); break e; case 2: zo = !0 } } null !== s.callback && 0 !== s.lane && (e.flags |= 64, null === (h = i.effects) ? i.effects = [s] : h.push(s)) } else f = { eventTime: f, lane: h, tag: s.tag, payload: s.payload, callback: s.callback, next: null }, null === u ? (c = u = f, l = d) : u = u.next = f, a |= h; if (null === (s = s.next)) { if (null === (s = i.shared.pending)) break; s = (h = s).next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null } } if (null === u && (l = d), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, null !== (t = i.shared.interleaved)) { i = t; do { a |= i.lane, i = i.next } while (i !== t) } else null === o && (i.shared.lanes = 0); zl |= a, e.lanes = a, e.memoizedState = d } } function Yo(e, t, n) { if (e = t.effects, t.effects = null, null !== e) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (null !== i) { if (r.callback = null, r = n, "function" !== typeof i) throw Error(o(191, i)); i.call(r) } } } var Xo = {}, Qo = Ai(Xo), qo = Ai(Xo), Zo = Ai(Xo); function Ko(e) { if (e === Xo) throw Error(o(174)); return e } function Go(e, t) { switch (Ci(Zo, t), Ci(qo, e), Ci(Qo, Xo), e = t.nodeType) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : le(null, ""); break; default: t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName) }Ei(Qo), Ci(Qo, t) } function Jo() { Ei(Qo), Ei(qo), Ei(Zo) } function _o(e) { Ko(Zo.current); var t = Ko(Qo.current), n = le(t, e.type); t !== n && (Ci(qo, e), Ci(Qo, n)) } function $o(e) { qo.current === e && (Ei(Qo), Ei(qo)) } var ea = Ai(0); function ta(e) { for (var t = e; null !== t;) { if (13 === t.tag) { var n = t.memoizedState; if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) { if (0 !== (128 & t.flags)) return t } else if (null !== t.child) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var na = []; function ra() { for (var e = 0; e < na.length; e++)na[e]._workInProgressVersionPrimary = null; na.length = 0 } var ia = x.ReactCurrentDispatcher, oa = x.ReactCurrentBatchConfig, aa = 0, sa = null, la = null, ca = null, ua = !1, da = !1, ha = 0, fa = 0; function pa() { throw Error(o(321)) } function ma(e, t) { if (null === t) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!sr(e[n], t[n])) return !1; return !0 } function ga(e, t, n, r, i, a) { if (aa = a, sa = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, ia.current = null === e || null === e.memoizedState ? $a : es, e = n(r, i), da) { a = 0; do { if (da = !1, ha = 0, 25 <= a) throw Error(o(301)); a += 1, ca = la = null, t.updateQueue = null, ia.current = ts, e = n(r, i) } while (da) } if (ia.current = _a, t = null !== la && null !== la.next, aa = 0, ca = la = sa = null, ua = !1, t) throw Error(o(300)); return e } function va() { var e = 0 !== ha; return ha = 0, e } function ya() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return null === ca ? sa.memoizedState = ca = e : ca = ca.next = e, ca } function ba() { if (null === la) { var e = sa.alternate; e = null !== e ? e.memoizedState : null } else e = la.next; var t = null === ca ? sa.memoizedState : ca.next; if (null !== t) ca = t, la = e; else { if (null === e) throw Error(o(310)); e = { memoizedState: (la = e).memoizedState, baseState: la.baseState, baseQueue: la.baseQueue, queue: la.queue, next: null }, null === ca ? sa.memoizedState = ca = e : ca = ca.next = e } return ca } function xa(e, t) { return "function" === typeof t ? t(e) : t } function wa(e) { var t = ba(), n = t.queue; if (null === n) throw Error(o(311)); n.lastRenderedReducer = e; var r = la, i = r.baseQueue, a = n.pending; if (null !== a) { if (null !== i) { var s = i.next; i.next = a.next, a.next = s } r.baseQueue = i = a, n.pending = null } if (null !== i) { a = i.next, r = r.baseState; var l = s = null, c = null, u = a; do { var d = u.lane; if ((aa & d) === d) null !== c && (c = c.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var h = { lane: d, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; null === c ? (l = c = h, s = r) : c = c.next = h, sa.lanes |= d, zl |= d } u = u.next } while (null !== u && u !== a); null === c ? s = r : c.next = l, sr(r, t.memoizedState) || (bs = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = c, n.lastRenderedState = r } if (null !== (e = n.interleaved)) { i = e; do { a = i.lane, sa.lanes |= a, zl |= a, i = i.next } while (i !== e) } else null === i && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function ka(e) { var t = ba(), n = t.queue; if (null === n) throw Error(o(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, a = t.memoizedState; if (null !== i) { n.pending = null; var s = i = i.next; do { a = e(a, s.action), s = s.next } while (s !== i); sr(a, t.memoizedState) || (bs = !0), t.memoizedState = a, null === t.baseQueue && (t.baseState = a), n.lastRenderedState = a } return [a, r] } function Sa() { } function Aa(e, t) { var n = sa, r = ba(), i = t(), a = !sr(r.memoizedState, i); if (a && (r.memoizedState = i, bs = !0), r = r.queue, za(Pa.bind(null, n, r, e), [e]), r.getSnapshot !== t || a || null !== ca && 1 & ca.memoizedState.tag) { if (n.flags |= 2048, Ta(9, Ca.bind(null, n, r, i, t), void 0, null), null === Nl) throw Error(o(349)); 0 !== (30 & aa) || Ea(n, t, i) } return i } function Ea(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, null === (t = sa.updateQueue) ? (t = { lastEffect: null, stores: null }, sa.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e) } function Ca(e, t, n, r) { t.value = n, t.getSnapshot = r, ja(t) && Na(e) } function Pa(e, t, n) { return n((function () { ja(t) && Na(e) })) } function ja(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !sr(e, n) } catch (r) { return !0 } } function Na(e) { var t = Do(e, 1); null !== t && nc(t, e, 1, -1) } function Ma(e) { var t = ya(); return "function" === typeof e && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: xa, lastRenderedState: e }, t.queue = e, e = e.dispatch = Za.bind(null, sa, e), [t.memoizedState, e] } function Ta(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, null === (t = sa.updateQueue) ? (t = { lastEffect: null, stores: null }, sa.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e } function Ia() { return ba().memoizedState } function La(e, t, n, r) { var i = ya(); sa.flags |= e, i.memoizedState = Ta(1 | t, n, void 0, void 0 === r ? null : r) } function Ra(e, t, n, r) { var i = ba(); r = void 0 === r ? null : r; var o = void 0; if (null !== la) { var a = la.memoizedState; if (o = a.destroy, null !== r && ma(r, a.deps)) return void (i.memoizedState = Ta(t, n, o, r)) } sa.flags |= e, i.memoizedState = Ta(1 | t, n, o, r) } function Da(e, t) { return La(8390656, 8, e, t) } function za(e, t) { return Ra(2048, 8, e, t) } function Oa(e, t) { return Ra(4, 2, e, t) } function Ba(e, t) { return Ra(4, 4, e, t) } function Fa(e, t) { return "function" === typeof t ? (e = e(), t(e), function () { t(null) }) : null !== t && void 0 !== t ? (e = e(), t.current = e, function () { t.current = null }) : void 0 } function Va(e, t, n) { return n = null !== n && void 0 !== n ? n.concat([e]) : null, Ra(4, 4, Fa.bind(null, t, e), n) } function Ua() { } function Wa(e, t) { var n = ba(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && ma(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function Ha(e, t) { var n = ba(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && ma(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Ya(e, t, n) { return 0 === (21 & aa) ? (e.baseState && (e.baseState = !1, bs = !0), e.memoizedState = n) : (sr(n, t) || (n = mt(), sa.lanes |= n, zl |= n, e.baseState = !0), t) } function Xa(e, t) { var n = bt; bt = 0 !== n && 4 > n ? n : 4, e(!0); var r = oa.transition; oa.transition = {}; try { e(!1), t() } finally { bt = n, oa.transition = r } } function Qa() { return ba().memoizedState } function qa(e, t, n) { var r = tc(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, Ka(e)) Ga(t, n); else if (null !== (n = Ro(e, t, n, r))) { nc(n, e, r, ec()), Ja(n, t, r) } } function Za(e, t, n) { var r = tc(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Ka(e)) Ga(t, i); else { var o = e.alternate; if (0 === e.lanes && (null === o || 0 === o.lanes) && null !== (o = t.lastRenderedReducer)) try { var a = t.lastRenderedState, s = o(a, n); if (i.hasEagerState = !0, i.eagerState = s, sr(s, a)) { var l = t.interleaved; return null === l ? (i.next = i, Lo(t)) : (i.next = l.next, l.next = i), void (t.interleaved = i) } } catch (c) { } null !== (n = Ro(e, t, i, r)) && (nc(n, e, r, i = ec()), Ja(n, t, r)) } } function Ka(e) { var t = e.alternate; return e === sa || null !== t && t === sa } function Ga(e, t) { da = ua = !0; var n = e.pending; null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function Ja(e, t, n) { if (0 !== (4194240 & n)) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, yt(e, n) } } var _a = { readContext: To, useCallback: pa, useContext: pa, useEffect: pa, useImperativeHandle: pa, useInsertionEffect: pa, useLayoutEffect: pa, useMemo: pa, useReducer: pa, useRef: pa, useState: pa, useDebugValue: pa, useDeferredValue: pa, useTransition: pa, useMutableSource: pa, useSyncExternalStore: pa, useId: pa, unstable_isNewReconciler: !1 }, $a = { readContext: To, useCallback: function (e, t) { return ya().memoizedState = [e, void 0 === t ? null : t], e }, useContext: To, useEffect: Da, useImperativeHandle: function (e, t, n) { return n = null !== n && void 0 !== n ? n.concat([e]) : null, La(4194308, 4, Fa.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return La(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return La(4, 2, e, t) }, useMemo: function (e, t) { var n = ya(); return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = ya(); return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = qa.bind(null, sa, e), [r.memoizedState, e] }, useRef: function (e) { return e = { current: e }, ya().memoizedState = e }, useState: Ma, useDebugValue: Ua, useDeferredValue: function (e) { return ya().memoizedState = e }, useTransition: function () { var e = Ma(!1), t = e[0]; return e = Xa.bind(null, e[1]), ya().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = sa, i = ya(); if (io) { if (void 0 === n) throw Error(o(407)); n = n() } else { if (n = t(), null === Nl) throw Error(o(349)); 0 !== (30 & aa) || Ea(r, t, n) } i.memoizedState = n; var a = { value: n, getSnapshot: t }; return i.queue = a, Da(Pa.bind(null, r, a, e), [e]), r.flags |= 2048, Ta(9, Ca.bind(null, r, a, n, t), void 0, null), n }, useId: function () { var e = ya(), t = Nl.identifierPrefix; if (io) { var n = Ji; t = ":" + t + "R" + (n = (Gi & ~(1 << 32 - at(Gi) - 1)).toString(32) + n), 0 < (n = ha++) && (t += "H" + n.toString(32)), t += ":" } else t = ":" + t + "r" + (n = fa++).toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, es = { readContext: To, useCallback: Wa, useContext: To, useEffect: za, useImperativeHandle: Va, useInsertionEffect: Oa, useLayoutEffect: Ba, useMemo: Ha, useReducer: wa, useRef: Ia, useState: function () { return wa(xa) }, useDebugValue: Ua, useDeferredValue: function (e) { return Ya(ba(), la.memoizedState, e) }, useTransition: function () { return [wa(xa)[0], ba().memoizedState] }, useMutableSource: Sa, useSyncExternalStore: Aa, useId: Qa, unstable_isNewReconciler: !1 }, ts = { readContext: To, useCallback: Wa, useContext: To, useEffect: za, useImperativeHandle: Va, useInsertionEffect: Oa, useLayoutEffect: Ba, useMemo: Ha, useReducer: ka, useRef: Ia, useState: function () { return ka(xa) }, useDebugValue: Ua, useDeferredValue: function (e) { var t = ba(); return null === la ? t.memoizedState = e : Ya(t, la.memoizedState, e) }, useTransition: function () { return [ka(xa)[0], ba().memoizedState] }, useMutableSource: Sa, useSyncExternalStore: Aa, useId: Qa, unstable_isNewReconciler: !1 }; function ns(e, t) { if (e && e.defaultProps) { for (var n in t = O({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]); return t } return t } function rs(e, t, n, r) { n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : O({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n) } var is = { isMounted: function (e) { return !!(e = e._reactInternals) && We(e) === e }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = ec(), i = tc(e), o = Fo(r, i); o.payload = t, void 0 !== n && null !== n && (o.callback = n), null !== (t = Vo(e, o, i)) && (nc(t, e, i, r), Uo(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = ec(), i = tc(e), o = Fo(r, i); o.tag = 1, o.payload = t, void 0 !== n && null !== n && (o.callback = n), null !== (t = Vo(e, o, i)) && (nc(t, e, i, r), Uo(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = ec(), r = tc(e), i = Fo(n, r); i.tag = 2, void 0 !== t && null !== t && (i.callback = t), null !== (t = Vo(e, i, r)) && (nc(t, e, r, n), Uo(t, e, r)) } }; function os(e, t, n, r, i, o, a) { return "function" === typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, o, a) : !t.prototype || !t.prototype.isPureReactComponent || (!lr(n, r) || !lr(i, o)) } function as(e, t, n) { var r = !1, i = Pi, o = t.contextType; return "object" === typeof o && null !== o ? o = To(o) : (i = Ii(t) ? Mi : ji.current, o = (r = null !== (r = t.contextTypes) && void 0 !== r) ? Ti(e, i) : Pi), t = new t(n, o), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = is, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t } function ss(e, t, n, r) { e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && is.enqueueReplaceState(t, t.state, null) } function ls(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = {}, Oo(e); var o = t.contextType; "object" === typeof o && null !== o ? i.context = To(o) : (o = Ii(t) ? Mi : ji.current, i.context = Ti(e, o)), i.state = e.memoizedState, "function" === typeof (o = t.getDerivedStateFromProps) && (rs(e, t, o, n), i.state = e.memoizedState), "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state, "function" === typeof i.componentWillMount && i.componentWillMount(), "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && is.enqueueReplaceState(i, i.state, null), Ho(e, n, i, r), i.state = e.memoizedState), "function" === typeof i.componentDidMount && (e.flags |= 4194308) } function cs(e, t) { try { var n = "", r = t; do { n += U(r), r = r.return } while (r); var i = n } catch (o) { i = "\nError generating stack: " + o.message + "\n" + o.stack } return { value: e, source: t, stack: i, digest: null } } function us(e, t, n) { return { value: e, source: null, stack: null != n ? n : null, digest: null != t ? t : null } } function ds(e, t) { try { console.error(t.value) } catch (n) { setTimeout((function () { throw n })) } } var hs = "function" === typeof WeakMap ? WeakMap : Map; function fs(e, t, n) { (n = Fo(-1, n)).tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Yl || (Yl = !0, Xl = r), ds(0, t) }, n } function ps(e, t, n) { (n = Fo(-1, n)).tag = 3; var r = e.type.getDerivedStateFromError; if ("function" === typeof r) { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { ds(0, t) } } var o = e.stateNode; return null !== o && "function" === typeof o.componentDidCatch && (n.callback = function () { ds(0, t), "function" !== typeof r && (null === Ql ? Ql = new Set([this]) : Ql.add(this)); var e = t.stack; this.componentDidCatch(t.value, { componentStack: null !== e ? e : "" }) }), n } function ms(e, t, n) { var r = e.pingCache; if (null === r) { r = e.pingCache = new hs; var i = new Set; r.set(t, i) } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = Ec.bind(null, e, t, n), t.then(e, e)) } function gs(e) { do { var t; if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e; e = e.return } while (null !== e); return null } function vs(e, t, n, r, i) { return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = Fo(-1, 1)).tag = 2, Vo(n, t, 1))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e) } var ys = x.ReactCurrentOwner, bs = !1; function xs(e, t, n, r) { t.child = null === e ? ko(t, null, n, r) : wo(t, e.child, n, r) } function ws(e, t, n, r, i) { n = n.render; var o = t.ref; return Mo(t, i), r = ga(e, t, n, r, o, i), n = va(), null === e || bs ? (io && n && eo(t), t.flags |= 1, xs(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ys(e, t, i)) } function ks(e, t, n, r, i) { if (null === e) { var o = n.type; return "function" !== typeof o || Ic(o) || void 0 !== o.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Rc(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = o, Ss(e, t, o, r, i)) } if (o = e.child, 0 === (e.lanes & i)) { var a = o.memoizedProps; if ((n = null !== (n = n.compare) ? n : lr)(a, r) && e.ref === t.ref) return Ys(e, t, i) } return t.flags |= 1, (e = Lc(o, r)).ref = t.ref, e.return = t, t.child = e } function Ss(e, t, n, r, i) { if (null !== e) { var o = e.memoizedProps; if (lr(o, r) && e.ref === t.ref) { if (bs = !1, t.pendingProps = r = o, 0 === (e.lanes & i)) return t.lanes = e.lanes, Ys(e, t, i); 0 !== (131072 & e.flags) && (bs = !0) } } return Cs(e, t, n, r, i) } function As(e, t, n) { var r = t.pendingProps, i = r.children, o = null !== e ? e.memoizedState : null; if ("hidden" === r.mode) if (0 === (1 & t.mode)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ci(Ll, Il), Il |= n; else { if (0 === (1073741824 & n)) return e = null !== o ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Ci(Ll, Il), Il |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = null !== o ? o.baseLanes : n, Ci(Ll, Il), Il |= r } else null !== o ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, Ci(Ll, Il), Il |= r; return xs(e, t, i, n), t.child } function Es(e, t) { var n = t.ref; (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Cs(e, t, n, r, i) { var o = Ii(n) ? Mi : ji.current; return o = Ti(t, o), Mo(t, i), n = ga(e, t, n, r, o, i), r = va(), null === e || bs ? (io && r && eo(t), t.flags |= 1, xs(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ys(e, t, i)) } function Ps(e, t, n, r, i) { if (Ii(n)) { var o = !0; zi(t) } else o = !1; if (Mo(t, i), null === t.stateNode) Hs(e, t), as(t, n, r), ls(t, n, r, i), r = !0; else if (null === e) { var a = t.stateNode, s = t.memoizedProps; a.props = s; var l = a.context, c = n.contextType; "object" === typeof c && null !== c ? c = To(c) : c = Ti(t, c = Ii(n) ? Mi : ji.current); var u = n.getDerivedStateFromProps, d = "function" === typeof u || "function" === typeof a.getSnapshotBeforeUpdate; d || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== r || l !== c) && ss(t, a, r, c), zo = !1; var h = t.memoizedState; a.state = h, Ho(t, r, a, i), l = t.memoizedState, s !== r || h !== l || Ni.current || zo ? ("function" === typeof u && (rs(t, n, u, r), l = t.memoizedState), (s = zo || os(t, n, s, r, h, l, c)) ? (d || "function" !== typeof a.UNSAFE_componentWillMount && "function" !== typeof a.componentWillMount || ("function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount()), "function" === typeof a.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), a.props = r, a.state = l, a.context = c, r = s) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308), r = !1) } else { a = t.stateNode, Bo(e, t), s = t.memoizedProps, c = t.type === t.elementType ? s : ns(t.type, s), a.props = c, d = t.pendingProps, h = a.context, "object" === typeof (l = n.contextType) && null !== l ? l = To(l) : l = Ti(t, l = Ii(n) ? Mi : ji.current); var f = n.getDerivedStateFromProps; (u = "function" === typeof f || "function" === typeof a.getSnapshotBeforeUpdate) || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== d || h !== l) && ss(t, a, r, l), zo = !1, h = t.memoizedState, a.state = h, Ho(t, r, a, i); var p = t.memoizedState; s !== d || h !== p || Ni.current || zo ? ("function" === typeof f && (rs(t, n, f, r), p = t.memoizedState), (c = zo || os(t, n, c, r, h, p, l) || !1) ? (u || "function" !== typeof a.UNSAFE_componentWillUpdate && "function" !== typeof a.componentWillUpdate || ("function" === typeof a.componentWillUpdate && a.componentWillUpdate(r, p, l), "function" === typeof a.UNSAFE_componentWillUpdate && a.UNSAFE_componentWillUpdate(r, p, l)), "function" === typeof a.componentDidUpdate && (t.flags |= 4), "function" === typeof a.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = p), a.props = r, a.state = p, a.context = l, r = c) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1) } return js(e, t, n, r, o, i) } function js(e, t, n, r, i, o) { Es(e, t); var a = 0 !== (128 & t.flags); if (!r && !a) return i && Oi(t, n, !1), Ys(e, t, o); r = t.stateNode, ys.current = t; var s = a && "function" !== typeof n.getDerivedStateFromError ? null : r.render(); return t.flags |= 1, null !== e && a ? (t.child = wo(t, e.child, null, o), t.child = wo(t, null, s, o)) : xs(e, t, s, o), t.memoizedState = r.state, i && Oi(t, n, !0), t.child } function Ns(e) { var t = e.stateNode; t.pendingContext ? Ri(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Ri(0, t.context, !1), Go(e, t.containerInfo) } function Ms(e, t, n, r, i) { return po(), mo(i), t.flags |= 256, xs(e, t, n, r), t.child } var Ts, Is, Ls, Rs, Ds = { dehydrated: null, treeContext: null, retryLane: 0 }; function zs(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Os(e, t, n) { var r, i = t.pendingProps, a = ea.current, s = !1, l = 0 !== (128 & t.flags); if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & a)), r ? (s = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (a |= 1), Ci(ea, 1 & a), null === e) return co(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824, null) : (l = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, l = { mode: "hidden", children: l }, 0 === (1 & i) && null !== s ? (s.childLanes = 0, s.pendingProps = l) : s = zc(l, i, 0, null), e = Dc(e, i, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = zs(n), t.memoizedState = Ds, e) : Bs(t, l)); if (null !== (a = e.memoizedState) && null !== (r = a.dehydrated)) return function (e, t, n, r, i, a, s) { if (n) return 256 & t.flags ? (t.flags &= -257, Fs(e, t, s, r = us(Error(o(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (a = r.fallback, i = t.mode, r = zc({ mode: "visible", children: r.children }, i, 0, null), (a = Dc(a, i, s, null)).flags |= 2, r.return = t, a.return = t, r.sibling = a, t.child = r, 0 !== (1 & t.mode) && wo(t, e.child, null, s), t.child.memoizedState = zs(s), t.memoizedState = Ds, a); if (0 === (1 & t.mode)) return Fs(e, t, s, null); if ("$!" === i.data) { if (r = i.nextSibling && i.nextSibling.dataset) var l = r.dgst; return r = l, Fs(e, t, s, r = us(a = Error(o(419)), r, void 0)) } if (l = 0 !== (s & e.childLanes), bs || l) { if (null !== (r = Nl)) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }0 !== (i = 0 !== (i & (r.suspendedLanes | s)) ? 0 : i) && i !== a.retryLane && (a.retryLane = i, Do(e, i), nc(r, e, i, -1)) } return mc(), Fs(e, t, s, r = us(Error(o(421)))) } return "$?" === i.data ? (t.flags |= 128, t.child = e.child, t = Pc.bind(null, e), i._reactRetry = t, null) : (e = a.treeContext, ro = ci(i.nextSibling), no = t, io = !0, oo = null, null !== e && (qi[Zi++] = Gi, qi[Zi++] = Ji, qi[Zi++] = Ki, Gi = e.id, Ji = e.overflow, Ki = t), t = Bs(t, r.children), t.flags |= 4096, t) }(e, t, l, i, r, a, n); if (s) { s = i.fallback, l = t.mode, r = (a = e.child).sibling; var c = { mode: "hidden", children: i.children }; return 0 === (1 & l) && t.child !== a ? ((i = t.child).childLanes = 0, i.pendingProps = c, t.deletions = null) : (i = Lc(a, c)).subtreeFlags = 14680064 & a.subtreeFlags, null !== r ? s = Lc(r, s) : (s = Dc(s, l, n, null)).flags |= 2, s.return = t, i.return = t, i.sibling = s, t.child = i, i = s, s = t.child, l = null === (l = e.child.memoizedState) ? zs(n) : { baseLanes: l.baseLanes | n, cachePool: null, transitions: l.transitions }, s.memoizedState = l, s.childLanes = e.childLanes & ~n, t.memoizedState = Ds, i } return e = (s = e.child).sibling, i = Lc(s, { mode: "visible", children: i.children }), 0 === (1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i } function Bs(e, t) { return (t = zc({ mode: "visible", children: t }, e.mode, 0, null)).return = e, e.child = t } function Fs(e, t, n, r) { return null !== r && mo(r), wo(t, e.child, null, n), (e = Bs(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e } function Vs(e, t, n) { e.lanes |= t; var r = e.alternate; null !== r && (r.lanes |= t), No(e.return, t, n) } function Us(e, t, n, r, i) { var o = e.memoizedState; null === o ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i) } function Ws(e, t, n) { var r = t.pendingProps, i = r.revealOrder, o = r.tail; if (xs(e, t, r.children, n), 0 !== (2 & (r = ea.current))) r = 1 & r | 2, t.flags |= 128; else { if (null !== e && 0 !== (128 & e.flags)) e: for (e = t.child; null !== e;) { if (13 === e.tag) null !== e.memoizedState && Vs(e, n, t); else if (19 === e.tag) Vs(e, n, t); else if (null !== e.child) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; null === e.sibling;) { if (null === e.return || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (Ci(ea, r), 0 === (1 & t.mode)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; null !== n;)null !== (e = n.alternate) && null === ta(e) && (i = n), n = n.sibling; null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), Us(t, !1, i, n, o); break; case "backwards": for (n = null, i = t.child, t.child = null; null !== i;) { if (null !== (e = i.alternate) && null === ta(e)) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } Us(t, !0, n, null, o); break; case "together": Us(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Hs(e, t) { 0 === (1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Ys(e, t, n) { if (null !== e && (t.dependencies = e.dependencies), zl |= t.lanes, 0 === (n & t.childLanes)) return null; if (null !== e && t.child !== e.child) throw Error(o(153)); if (null !== t.child) { for (n = Lc(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;)e = e.sibling, (n = n.sibling = Lc(e, e.pendingProps)).return = t; n.sibling = null } return t.child } function Xs(e, t) { if (!io) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; null !== t;)null !== t.alternate && (n = t), t = t.sibling; null === n ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; null !== n;)null !== n.alternate && (r = n), n = n.sibling; null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function Qs(e) { var t = null !== e.alternate && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function qs(e, t, n) { var r = t.pendingProps; switch (to(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Qs(t), null; case 1: case 17: return Ii(t.type) && Li(), Qs(t), null; case 3: return r = t.stateNode, Jo(), Ei(Ni), Ei(ji), ra(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (ho(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024, null !== oo && (ac(oo), oo = null))), Is(e, t), Qs(t), null; case 5: $o(t); var i = Ko(Zo.current); if (n = t.type, null !== e && null != t.stateNode) Ls(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (null === t.stateNode) throw Error(o(166)); return Qs(t), null } if (e = Ko(Qo.current), ho(t)) { r = t.stateNode, n = t.type; var a = t.memoizedProps; switch (r[hi] = t, r[fi] = a, e = 0 !== (1 & t.mode), n) { case "dialog": Fr("cancel", r), Fr("close", r); break; case "iframe": case "object": case "embed": Fr("load", r); break; case "video": case "audio": for (i = 0; i < Dr.length; i++)Fr(Dr[i], r); break; case "source": Fr("error", r); break; case "img": case "image": case "link": Fr("error", r), Fr("load", r); break; case "details": Fr("toggle", r); break; case "input": G(r, a), Fr("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!a.multiple }, Fr("invalid", r); break; case "textarea": ie(r, a), Fr("invalid", r) }for (var l in ye(n, a), i = null, a) if (a.hasOwnProperty(l)) { var c = a[l]; "children" === l ? "string" === typeof c ? r.textContent !== c && (!0 !== a.suppressHydrationWarning && _r(r.textContent, c, e), i = ["children", c]) : "number" === typeof c && r.textContent !== "" + c && (!0 !== a.suppressHydrationWarning && _r(r.textContent, c, e), i = ["children", "" + c]) : s.hasOwnProperty(l) && null != c && "onScroll" === l && Fr("scroll", r) } switch (n) { case "input": Q(r), $(r, a, !0); break; case "textarea": Q(r), ae(r); break; case "select": case "option": break; default: "function" === typeof a.onClick && (r.onclick = $r) }r = i, t.updateQueue = r, null !== r && (t.flags |= 4) } else { l = 9 === i.nodeType ? i : i.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = se(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" === typeof r.is ? e = l.createElement(n, { is: r.is }) : (e = l.createElement(n), "select" === n && (l = e, r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n), e[hi] = t, e[fi] = r, Ts(e, t, !1, !1), t.stateNode = e; e: { switch (l = be(n, r), n) { case "dialog": Fr("cancel", e), Fr("close", e), i = r; break; case "iframe": case "object": case "embed": Fr("load", e), i = r; break; case "video": case "audio": for (i = 0; i < Dr.length; i++)Fr(Dr[i], e); i = r; break; case "source": Fr("error", e), i = r; break; case "img": case "image": case "link": Fr("error", e), Fr("load", e), i = r; break; case "details": Fr("toggle", e), i = r; break; case "input": G(e, r), i = K(e, r), Fr("invalid", e); break; case "option": default: i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = O({}, r, { value: void 0 }), Fr("invalid", e); break; case "textarea": ie(e, r), i = re(e, r), Fr("invalid", e) }for (a in ye(n, i), c = i) if (c.hasOwnProperty(a)) { var u = c[a]; "style" === a ? ge(e, u) : "dangerouslySetInnerHTML" === a ? null != (u = u ? u.__html : void 0) && de(e, u) : "children" === a ? "string" === typeof u ? ("textarea" !== n || "" !== u) && he(e, u) : "number" === typeof u && he(e, "" + u) : "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && "autoFocus" !== a && (s.hasOwnProperty(a) ? null != u && "onScroll" === a && Fr("scroll", e) : null != u && b(e, a, u, l)) } switch (n) { case "input": Q(e), $(e, r, !1); break; case "textarea": Q(e), ae(e); break; case "option": null != r.value && e.setAttribute("value", "" + Y(r.value)); break; case "select": e.multiple = !!r.multiple, null != (a = r.value) ? ne(e, !!r.multiple, a, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0); break; default: "function" === typeof i.onClick && (e.onclick = $r) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } null !== t.ref && (t.flags |= 512, t.flags |= 2097152) } return Qs(t), null; case 6: if (e && null != t.stateNode) Rs(e, t, e.memoizedProps, r); else { if ("string" !== typeof r && null === t.stateNode) throw Error(o(166)); if (n = Ko(Zo.current), Ko(Qo.current), ho(t)) { if (r = t.stateNode, n = t.memoizedProps, r[hi] = t, (a = r.nodeValue !== n) && null !== (e = no)) switch (e.tag) { case 3: _r(r.nodeValue, n, 0 !== (1 & e.mode)); break; case 5: !0 !== e.memoizedProps.suppressHydrationWarning && _r(r.nodeValue, n, 0 !== (1 & e.mode)) }a && (t.flags |= 4) } else (r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[hi] = t, t.stateNode = r } return Qs(t), null; case 13: if (Ei(ea), r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) { if (io && null !== ro && 0 !== (1 & t.mode) && 0 === (128 & t.flags)) fo(), po(), t.flags |= 98560, a = !1; else if (a = ho(t), null !== r && null !== r.dehydrated) { if (null === e) { if (!a) throw Error(o(318)); if (!(a = null !== (a = t.memoizedState) ? a.dehydrated : null)) throw Error(o(317)); a[hi] = t } else po(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4; Qs(t), a = !1 } else null !== oo && (ac(oo), oo = null), a = !0; if (!a) return 65536 & t.flags ? t : null } return 0 !== (128 & t.flags) ? (t.lanes = n, t) : ((r = null !== r) !== (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192, 0 !== (1 & t.mode) && (null === e || 0 !== (1 & ea.current) ? 0 === Rl && (Rl = 3) : mc())), null !== t.updateQueue && (t.flags |= 4), Qs(t), null); case 4: return Jo(), Is(e, t), null === e && Wr(t.stateNode.containerInfo), Qs(t), null; case 10: return jo(t.type._context), Qs(t), null; case 19: if (Ei(ea), null === (a = t.memoizedState)) return Qs(t), null; if (r = 0 !== (128 & t.flags), null === (l = a.rendering)) if (r) Xs(a, !1); else { if (0 !== Rl || null !== e && 0 !== (128 & e.flags)) for (e = t.child; null !== e;) { if (null !== (l = ta(e))) { for (t.flags |= 128, Xs(a, !1), null !== (r = l.updateQueue) && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; null !== n;)e = r, (a = n).flags &= 14680066, null === (l = a.alternate) ? (a.childLanes = 0, a.lanes = e, a.child = null, a.subtreeFlags = 0, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = l.childLanes, a.lanes = l.lanes, a.child = l.child, a.subtreeFlags = 0, a.deletions = null, a.memoizedProps = l.memoizedProps, a.memoizedState = l.memoizedState, a.updateQueue = l.updateQueue, a.type = l.type, e = l.dependencies, a.dependencies = null === e ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Ci(ea, 1 & ea.current | 2), t.child } e = e.sibling } null !== a.tail && Je() > Wl && (t.flags |= 128, r = !0, Xs(a, !1), t.lanes = 4194304) } else { if (!r) if (null !== (e = ta(l))) { if (t.flags |= 128, r = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), Xs(a, !0), null === a.tail && "hidden" === a.tailMode && !l.alternate && !io) return Qs(t), null } else 2 * Je() - a.renderingStartTime > Wl && 1073741824 !== n && (t.flags |= 128, r = !0, Xs(a, !1), t.lanes = 4194304); a.isBackwards ? (l.sibling = t.child, t.child = l) : (null !== (n = a.last) ? n.sibling = l : t.child = l, a.last = l) } return null !== a.tail ? (t = a.tail, a.rendering = t, a.tail = t.sibling, a.renderingStartTime = Je(), t.sibling = null, n = ea.current, Ci(ea, r ? 1 & n | 2 : 1 & n), t) : (Qs(t), null); case 22: case 23: return dc(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Il) && (Qs(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Qs(t), null; case 24: case 25: return null }throw Error(o(156, t.tag)) } function Zs(e, t) { switch (to(t), t.tag) { case 1: return Ii(t.type) && Li(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 3: return Jo(), Ei(Ni), Ei(ji), ra(), 0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 5: return $o(t), null; case 13: if (Ei(ea), null !== (e = t.memoizedState) && null !== e.dehydrated) { if (null === t.alternate) throw Error(o(340)); po() } return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 19: return Ei(ea), null; case 4: return Jo(), null; case 10: return jo(t.type._context), null; case 22: case 23: return dc(), null; default: return null } } Ts = function (e, t) { for (var n = t.child; null !== n;) { if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode); else if (4 !== n.tag && null !== n.child) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; null === n.sibling;) { if (null === n.return || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }, Is = function () { }, Ls = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, Ko(Qo.current); var o, a = null; switch (n) { case "input": i = K(e, i), r = K(e, r), a = []; break; case "select": i = O({}, i, { value: void 0 }), r = O({}, r, { value: void 0 }), a = []; break; case "textarea": i = re(e, i), r = re(e, r), a = []; break; default: "function" !== typeof i.onClick && "function" === typeof r.onClick && (e.onclick = $r) }for (u in ye(n, r), n = null, i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && null != i[u]) if ("style" === u) { var l = i[u]; for (o in l) l.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else "dangerouslySetInnerHTML" !== u && "children" !== u && "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (s.hasOwnProperty(u) ? a || (a = []) : (a = a || []).push(u, null)); for (u in r) { var c = r[u]; if (l = null != i ? i[u] : void 0, r.hasOwnProperty(u) && c !== l && (null != c || null != l)) if ("style" === u) if (l) { for (o in l) !l.hasOwnProperty(o) || c && c.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in c) c.hasOwnProperty(o) && l[o] !== c[o] && (n || (n = {}), n[o] = c[o]) } else n || (a || (a = []), a.push(u, n)), n = c; else "dangerouslySetInnerHTML" === u ? (c = c ? c.__html : void 0, l = l ? l.__html : void 0, null != c && l !== c && (a = a || []).push(u, c)) : "children" === u ? "string" !== typeof c && "number" !== typeof c || (a = a || []).push(u, "" + c) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && (s.hasOwnProperty(u) ? (null != c && "onScroll" === u && Fr("scroll", e), a || l === c || (a = [])) : (a = a || []).push(u, c)) } n && (a = a || []).push("style", n); var u = a; (t.updateQueue = u) && (t.flags |= 4) } }, Rs = function (e, t, n, r) { n !== r && (t.flags |= 4) }; var Ks = !1, Gs = !1, Js = "function" === typeof WeakSet ? WeakSet : Set, _s = null; function $s(e, t) { var n = e.ref; if (null !== n) if ("function" === typeof n) try { n(null) } catch (r) { Ac(e, t, r) } else n.current = null } function el(e, t, n) { try { n() } catch (r) { Ac(e, t, r) } } var tl = !1; function nl(e, t, n) { var r = t.updateQueue; if (null !== (r = null !== r ? r.lastEffect : null)) { var i = r = r.next; do { if ((i.tag & e) === e) { var o = i.destroy; i.destroy = void 0, void 0 !== o && el(t, n, o) } i = i.next } while (i !== r) } } function rl(e, t) { if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function il(e) { var t = e.ref; if (null !== t) { var n = e.stateNode; e.tag, e = n, "function" === typeof t ? t(e) : t.current = e } } function ol(e) { var t = e.alternate; null !== t && (e.alternate = null, ol(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && (null !== (t = e.stateNode) && (delete t[hi], delete t[fi], delete t[mi], delete t[gi], delete t[vi])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function al(e) { return 5 === e.tag || 3 === e.tag || 4 === e.tag } function sl(e) { e: for (; ;) { for (; null === e.sibling;) { if (null === e.return || al(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) { if (2 & e.flags) continue e; if (null === e.child || 4 === e.tag) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function ll(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = $r)); else if (4 !== r && null !== (e = e.child)) for (ll(e, t, n), e = e.sibling; null !== e;)ll(e, t, n), e = e.sibling } function cl(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (4 !== r && null !== (e = e.child)) for (cl(e, t, n), e = e.sibling; null !== e;)cl(e, t, n), e = e.sibling } var ul = null, dl = !1; function hl(e, t, n) { for (n = n.child; null !== n;)fl(e, t, n), n = n.sibling } function fl(e, t, n) { if (ot && "function" === typeof ot.onCommitFiberUnmount) try { ot.onCommitFiberUnmount(it, n) } catch (s) { } switch (n.tag) { case 5: Gs || $s(n, t); case 6: var r = ul, i = dl; ul = null, hl(e, t, n), dl = i, null !== (ul = r) && (dl ? (e = ul, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : ul.removeChild(n.stateNode)); break; case 18: null !== ul && (dl ? (e = ul, n = n.stateNode, 8 === e.nodeType ? li(e.parentNode, n) : 1 === e.nodeType && li(e, n), Wt(e)) : li(ul, n.stateNode)); break; case 4: r = ul, i = dl, ul = n.stateNode.containerInfo, dl = !0, hl(e, t, n), ul = r, dl = i; break; case 0: case 11: case 14: case 15: if (!Gs && (null !== (r = n.updateQueue) && null !== (r = r.lastEffect))) { i = r = r.next; do { var o = i, a = o.destroy; o = o.tag, void 0 !== a && (0 !== (2 & o) || 0 !== (4 & o)) && el(n, t, a), i = i.next } while (i !== r) } hl(e, t, n); break; case 1: if (!Gs && ($s(n, t), "function" === typeof (r = n.stateNode).componentWillUnmount)) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (s) { Ac(n, t, s) } hl(e, t, n); break; case 21: hl(e, t, n); break; case 22: 1 & n.mode ? (Gs = (r = Gs) || null !== n.memoizedState, hl(e, t, n), Gs = r) : hl(e, t, n); break; default: hl(e, t, n) } } function pl(e) { var t = e.updateQueue; if (null !== t) { e.updateQueue = null; var n = e.stateNode; null === n && (n = e.stateNode = new Js), t.forEach((function (t) { var r = jc.bind(null, e, t); n.has(t) || (n.add(t), t.then(r, r)) })) } } function ml(e, t) { var n = t.deletions; if (null !== n) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var a = e, s = t, l = s; e: for (; null !== l;) { switch (l.tag) { case 5: ul = l.stateNode, dl = !1; break e; case 3: case 4: ul = l.stateNode.containerInfo, dl = !0; break e }l = l.return } if (null === ul) throw Error(o(160)); fl(a, s, i), ul = null, dl = !1; var c = i.alternate; null !== c && (c.return = null), i.return = null } catch (u) { Ac(i, t, u) } } if (12854 & t.subtreeFlags) for (t = t.child; null !== t;)gl(t, e), t = t.sibling } function gl(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (ml(t, e), vl(e), 4 & r) { try { nl(3, e, e.return), rl(3, e) } catch (g) { Ac(e, e.return, g) } try { nl(5, e, e.return) } catch (g) { Ac(e, e.return, g) } } break; case 1: ml(t, e), vl(e), 512 & r && null !== n && $s(n, n.return); break; case 5: if (ml(t, e), vl(e), 512 & r && null !== n && $s(n, n.return), 32 & e.flags) { var i = e.stateNode; try { he(i, "") } catch (g) { Ac(e, e.return, g) } } if (4 & r && null != (i = e.stateNode)) { var a = e.memoizedProps, s = null !== n ? n.memoizedProps : a, l = e.type, c = e.updateQueue; if (e.updateQueue = null, null !== c) try { "input" === l && "radio" === a.type && null != a.name && J(i, a), be(l, s); var u = be(l, a); for (s = 0; s < c.length; s += 2) { var d = c[s], h = c[s + 1]; "style" === d ? ge(i, h) : "dangerouslySetInnerHTML" === d ? de(i, h) : "children" === d ? he(i, h) : b(i, d, h, u) } switch (l) { case "input": _(i, a); break; case "textarea": oe(i, a); break; case "select": var f = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!a.multiple; var p = a.value; null != p ? ne(i, !!a.multiple, p, !1) : f !== !!a.multiple && (null != a.defaultValue ? ne(i, !!a.multiple, a.defaultValue, !0) : ne(i, !!a.multiple, a.multiple ? [] : "", !1)) }i[fi] = a } catch (g) { Ac(e, e.return, g) } } break; case 6: if (ml(t, e), vl(e), 4 & r) { if (null === e.stateNode) throw Error(o(162)); i = e.stateNode, a = e.memoizedProps; try { i.nodeValue = a } catch (g) { Ac(e, e.return, g) } } break; case 3: if (ml(t, e), vl(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try { Wt(t.containerInfo) } catch (g) { Ac(e, e.return, g) } break; case 4: default: ml(t, e), vl(e); break; case 13: ml(t, e), vl(e), 8192 & (i = e.child).flags && (a = null !== i.memoizedState, i.stateNode.isHidden = a, !a || null !== i.alternate && null !== i.alternate.memoizedState || (Ul = Je())), 4 & r && pl(e); break; case 22: if (d = null !== n && null !== n.memoizedState, 1 & e.mode ? (Gs = (u = Gs) || d, ml(t, e), Gs = u) : ml(t, e), vl(e), 8192 & r) { if (u = null !== e.memoizedState, (e.stateNode.isHidden = u) && !d && 0 !== (1 & e.mode)) for (_s = e, d = e.child; null !== d;) { for (h = _s = d; null !== _s;) { switch (p = (f = _s).child, f.tag) { case 0: case 11: case 14: case 15: nl(4, f, f.return); break; case 1: $s(f, f.return); var m = f.stateNode; if ("function" === typeof m.componentWillUnmount) { r = f, n = f.return; try { t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount() } catch (g) { Ac(r, n, g) } } break; case 5: $s(f, f.return); break; case 22: if (null !== f.memoizedState) { wl(h); continue } }null !== p ? (p.return = f, _s = p) : wl(h) } d = d.sibling } e: for (d = null, h = e; ;) { if (5 === h.tag) { if (null === d) { d = h; try { i = h.stateNode, u ? "function" === typeof (a = i.style).setProperty ? a.setProperty("display", "none", "important") : a.display = "none" : (l = h.stateNode, s = void 0 !== (c = h.memoizedProps.style) && null !== c && c.hasOwnProperty("display") ? c.display : null, l.style.display = me("display", s)) } catch (g) { Ac(e, e.return, g) } } } else if (6 === h.tag) { if (null === d) try { h.stateNode.nodeValue = u ? "" : h.memoizedProps } catch (g) { Ac(e, e.return, g) } } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === e) && null !== h.child) { h.child.return = h, h = h.child; continue } if (h === e) break e; for (; null === h.sibling;) { if (null === h.return || h.return === e) break e; d === h && (d = null), h = h.return } d === h && (d = null), h.sibling.return = h.return, h = h.sibling } } break; case 19: ml(t, e), vl(e), 4 & r && pl(e); case 21: } } function vl(e) { var t = e.flags; if (2 & t) { try { e: { for (var n = e.return; null !== n;) { if (al(n)) { var r = n; break e } n = n.return } throw Error(o(160)) } switch (r.tag) { case 5: var i = r.stateNode; 32 & r.flags && (he(i, ""), r.flags &= -33), cl(e, sl(e), i); break; case 3: case 4: var a = r.stateNode.containerInfo; ll(e, sl(e), a); break; default: throw Error(o(161)) } } catch (s) { Ac(e, e.return, s) } e.flags &= -3 } 4096 & t && (e.flags &= -4097) } function yl(e, t, n) { _s = e, bl(e, t, n) } function bl(e, t, n) { for (var r = 0 !== (1 & e.mode); null !== _s;) { var i = _s, o = i.child; if (22 === i.tag && r) { var a = null !== i.memoizedState || Ks; if (!a) { var s = i.alternate, l = null !== s && null !== s.memoizedState || Gs; s = Ks; var c = Gs; if (Ks = a, (Gs = l) && !c) for (_s = i; null !== _s;)l = (a = _s).child, 22 === a.tag && null !== a.memoizedState ? kl(i) : null !== l ? (l.return = a, _s = l) : kl(i); for (; null !== o;)_s = o, bl(o, t, n), o = o.sibling; _s = i, Ks = s, Gs = c } xl(e) } else 0 !== (8772 & i.subtreeFlags) && null !== o ? (o.return = i, _s = o) : xl(e) } } function xl(e) { for (; null !== _s;) { var t = _s; if (0 !== (8772 & t.flags)) { var n = t.alternate; try { if (0 !== (8772 & t.flags)) switch (t.tag) { case 0: case 11: case 15: Gs || rl(5, t); break; case 1: var r = t.stateNode; if (4 & t.flags && !Gs) if (null === n) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : ns(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var a = t.updateQueue; null !== a && Yo(t, a, r); break; case 3: var s = t.updateQueue; if (null !== s) { if (n = null, null !== t.child) switch (t.child.tag) { case 5: case 1: n = t.child.stateNode }Yo(t, s, n) } break; case 5: var l = t.stateNode; if (null === n && 4 & t.flags) { n = l; var c = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": c.autoFocus && n.focus(); break; case "img": c.src && (n.src = c.src) } } break; case 6: case 4: case 12: case 19: case 17: case 21: case 22: case 23: case 25: break; case 13: if (null === t.memoizedState) { var u = t.alternate; if (null !== u) { var d = u.memoizedState; if (null !== d) { var h = d.dehydrated; null !== h && Wt(h) } } } break; default: throw Error(o(163)) }Gs || 512 & t.flags && il(t) } catch (f) { Ac(t, t.return, f) } } if (t === e) { _s = null; break } if (null !== (n = t.sibling)) { n.return = t.return, _s = n; break } _s = t.return } } function wl(e) { for (; null !== _s;) { var t = _s; if (t === e) { _s = null; break } var n = t.sibling; if (null !== n) { n.return = t.return, _s = n; break } _s = t.return } } function kl(e) { for (; null !== _s;) { var t = _s; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { rl(4, t) } catch (l) { Ac(t, n, l) } break; case 1: var r = t.stateNode; if ("function" === typeof r.componentDidMount) { var i = t.return; try { r.componentDidMount() } catch (l) { Ac(t, i, l) } } var o = t.return; try { il(t) } catch (l) { Ac(t, o, l) } break; case 5: var a = t.return; try { il(t) } catch (l) { Ac(t, a, l) } } } catch (l) { Ac(t, t.return, l) } if (t === e) { _s = null; break } var s = t.sibling; if (null !== s) { s.return = t.return, _s = s; break } _s = t.return } } var Sl, Al = Math.ceil, El = x.ReactCurrentDispatcher, Cl = x.ReactCurrentOwner, Pl = x.ReactCurrentBatchConfig, jl = 0, Nl = null, Ml = null, Tl = 0, Il = 0, Ll = Ai(0), Rl = 0, Dl = null, zl = 0, Ol = 0, Bl = 0, Fl = null, Vl = null, Ul = 0, Wl = 1 / 0, Hl = null, Yl = !1, Xl = null, Ql = null, ql = !1, Zl = null, Kl = 0, Gl = 0, Jl = null, _l = -1, $l = 0; function ec() { return 0 !== (6 & jl) ? Je() : -1 !== _l ? _l : _l = Je() } function tc(e) { return 0 === (1 & e.mode) ? 1 : 0 !== (2 & jl) && 0 !== Tl ? Tl & -Tl : null !== go.transition ? (0 === $l && ($l = mt()), $l) : 0 !== (e = bt) ? e : e = void 0 === (e = window.event) ? 16 : Gt(e.type) } function nc(e, t, n, r) { if (50 < Gl) throw Gl = 0, Jl = null, Error(o(185)); vt(e, n, r), 0 !== (2 & jl) && e === Nl || (e === Nl && (0 === (2 & jl) && (Ol |= n), 4 === Rl && sc(e, Tl)), rc(e, r), 1 === n && 0 === jl && 0 === (1 & t.mode) && (Wl = Je() + 500, Fi && Wi())) } function rc(e, t) { var n = e.callbackNode; !function (e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) { var a = 31 - at(o), s = 1 << a, l = i[a]; -1 === l ? 0 !== (s & n) && 0 === (s & r) || (i[a] = ft(s, t)) : l <= t && (e.expiredLanes |= s), o &= ~s } }(e, t); var r = ht(e, e === Nl ? Tl : 0); if (0 === r) null !== n && Ze(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (null != n && Ze(n), 1 === t) 0 === e.tag ? function (e) { Fi = !0, Ui(e) }(lc.bind(null, e)) : Ui(lc.bind(null, e)), ai((function () { 0 === (6 & jl) && Wi() })), n = null; else { switch (xt(r)) { case 1: n = $e; break; case 4: n = et; break; case 16: default: n = tt; break; case 536870912: n = rt }n = Nc(n, ic.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function ic(e, t) { if (_l = -1, $l = 0, 0 !== (6 & jl)) throw Error(o(327)); var n = e.callbackNode; if (kc() && e.callbackNode !== n) return null; var r = ht(e, e === Nl ? Tl : 0); if (0 === r) return null; if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t) t = gc(e, r); else { t = r; var i = jl; jl |= 2; var a = pc(); for (Nl === e && Tl === t || (Hl = null, Wl = Je() + 500, hc(e, t)); ;)try { yc(); break } catch (l) { fc(e, l) } Po(), El.current = a, jl = i, null !== Ml ? t = 0 : (Nl = null, Tl = 0, t = Rl) } if (0 !== t) { if (2 === t && (0 !== (i = pt(e)) && (r = i, t = oc(e, i))), 1 === t) throw n = Dl, hc(e, 0), sc(e, r), rc(e, Je()), n; if (6 === t) sc(e, r); else { if (i = e.current.alternate, 0 === (30 & r) && !function (e) { for (var t = e; ;) { if (16384 & t.flags) { var n = t.updateQueue; if (null !== n && null !== (n = n.stores)) for (var r = 0; r < n.length; r++) { var i = n[r], o = i.getSnapshot; i = i.value; try { if (!sr(o(), i)) return !1 } catch (s) { return !1 } } } if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n; else { if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 }(i) && (2 === (t = gc(e, r)) && (0 !== (a = pt(e)) && (r = a, t = oc(e, a))), 1 === t)) throw n = Dl, hc(e, 0), sc(e, r), rc(e, Je()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(o(345)); case 2: case 5: wc(e, Vl, Hl); break; case 3: if (sc(e, r), (130023424 & r) === r && 10 < (t = Ul + 500 - Je())) { if (0 !== ht(e, 0)) break; if (((i = e.suspendedLanes) & r) !== r) { ec(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = ri(wc.bind(null, e, Vl, Hl), t); break } wc(e, Vl, Hl); break; case 4: if (sc(e, r), (4194240 & r) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - at(r); a = 1 << s, (s = t[s]) > i && (i = s), r &= ~a } if (r = i, 10 < (r = (120 > (r = Je() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Al(r / 1960)) - r)) { e.timeoutHandle = ri(wc.bind(null, e, Vl, Hl), r); break } wc(e, Vl, Hl); break; default: throw Error(o(329)) } } } return rc(e, Je()), e.callbackNode === n ? ic.bind(null, e) : null } function oc(e, t) { var n = Fl; return e.current.memoizedState.isDehydrated && (hc(e, t).flags |= 256), 2 !== (e = gc(e, t)) && (t = Vl, Vl = n, null !== t && ac(t)), e } function ac(e) { null === Vl ? Vl = e : Vl.push.apply(Vl, e) } function sc(e, t) { for (t &= ~Bl, t &= ~Ol, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - at(t), r = 1 << n; e[n] = -1, t &= ~r } } function lc(e) { if (0 !== (6 & jl)) throw Error(o(327)); kc(); var t = ht(e, 0); if (0 === (1 & t)) return rc(e, Je()), null; var n = gc(e, t); if (0 !== e.tag && 2 === n) { var r = pt(e); 0 !== r && (t = r, n = oc(e, r)) } if (1 === n) throw n = Dl, hc(e, 0), sc(e, t), rc(e, Je()), n; if (6 === n) throw Error(o(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, wc(e, Vl, Hl), rc(e, Je()), null } function cc(e, t) { var n = jl; jl |= 1; try { return e(t) } finally { 0 === (jl = n) && (Wl = Je() + 500, Fi && Wi()) } } function uc(e) { null !== Zl && 0 === Zl.tag && 0 === (6 & jl) && kc(); var t = jl; jl |= 1; var n = Pl.transition, r = bt; try { if (Pl.transition = null, bt = 1, e) return e() } finally { bt = r, Pl.transition = n, 0 === (6 & (jl = t)) && Wi() } } function dc() { Il = Ll.current, Ei(Ll) } function hc(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (-1 !== n && (e.timeoutHandle = -1, ii(n)), null !== Ml) for (n = Ml.return; null !== n;) { var r = n; switch (to(r), r.tag) { case 1: null !== (r = r.type.childContextTypes) && void 0 !== r && Li(); break; case 3: Jo(), Ei(Ni), Ei(ji), ra(); break; case 5: $o(r); break; case 4: Jo(); break; case 13: case 19: Ei(ea); break; case 10: jo(r.type._context); break; case 22: case 23: dc() }n = n.return } if (Nl = e, Ml = e = Lc(e.current, null), Tl = Il = t, Rl = 0, Dl = null, Bl = Ol = zl = 0, Vl = Fl = null, null !== Io) { for (t = 0; t < Io.length; t++)if (null !== (r = (n = Io[t]).interleaved)) { n.interleaved = null; var i = r.next, o = n.pending; if (null !== o) { var a = o.next; o.next = i, r.next = a } n.pending = r } Io = null } return e } function fc(e, t) { for (; ;) { var n = Ml; try { if (Po(), ia.current = _a, ua) { for (var r = sa.memoizedState; null !== r;) { var i = r.queue; null !== i && (i.pending = null), r = r.next } ua = !1 } if (aa = 0, ca = la = sa = null, da = !1, ha = 0, Cl.current = null, null === n || null === n.return) { Rl = 1, Dl = t, Ml = null; break } e: { var a = e, s = n.return, l = n, c = t; if (t = Tl, l.flags |= 32768, null !== c && "object" === typeof c && "function" === typeof c.then) { var u = c, d = l, h = d.tag; if (0 === (1 & d.mode) && (0 === h || 11 === h || 15 === h)) { var f = d.alternate; f ? (d.updateQueue = f.updateQueue, d.memoizedState = f.memoizedState, d.lanes = f.lanes) : (d.updateQueue = null, d.memoizedState = null) } var p = gs(s); if (null !== p) { p.flags &= -257, vs(p, s, l, 0, t), 1 & p.mode && ms(a, u, t), c = u; var m = (t = p).updateQueue; if (null === m) { var g = new Set; g.add(c), t.updateQueue = g } else m.add(c); break e } if (0 === (1 & t)) { ms(a, u, t), mc(); break e } c = Error(o(426)) } else if (io && 1 & l.mode) { var v = gs(s); if (null !== v) { 0 === (65536 & v.flags) && (v.flags |= 256), vs(v, s, l, 0, t), mo(cs(c, l)); break e } } a = c = cs(c, l), 4 !== Rl && (Rl = 2), null === Fl ? Fl = [a] : Fl.push(a), a = s; do { switch (a.tag) { case 3: a.flags |= 65536, t &= -t, a.lanes |= t, Wo(a, fs(0, c, t)); break e; case 1: l = c; var y = a.type, b = a.stateNode; if (0 === (128 & a.flags) && ("function" === typeof y.getDerivedStateFromError || null !== b && "function" === typeof b.componentDidCatch && (null === Ql || !Ql.has(b)))) { a.flags |= 65536, t &= -t, a.lanes |= t, Wo(a, ps(a, l, t)); break e } }a = a.return } while (null !== a) } xc(n) } catch (x) { t = x, Ml === n && null !== n && (Ml = n = n.return); continue } break } } function pc() { var e = El.current; return El.current = _a, null === e ? _a : e } function mc() { 0 !== Rl && 3 !== Rl && 2 !== Rl || (Rl = 4), null === Nl || 0 === (268435455 & zl) && 0 === (268435455 & Ol) || sc(Nl, Tl) } function gc(e, t) { var n = jl; jl |= 2; var r = pc(); for (Nl === e && Tl === t || (Hl = null, hc(e, t)); ;)try { vc(); break } catch (i) { fc(e, i) } if (Po(), jl = n, El.current = r, null !== Ml) throw Error(o(261)); return Nl = null, Tl = 0, Rl } function vc() { for (; null !== Ml;)bc(Ml) } function yc() { for (; null !== Ml && !Ke();)bc(Ml) } function bc(e) { var t = Sl(e.alternate, e, Il); e.memoizedProps = e.pendingProps, null === t ? xc(e) : Ml = t, Cl.current = null } function xc(e) { var t = e; do { var n = t.alternate; if (e = t.return, 0 === (32768 & t.flags)) { if (null !== (n = qs(n, t, Il))) return void (Ml = n) } else { if (null !== (n = Zs(n, t))) return n.flags &= 32767, void (Ml = n); if (null === e) return Rl = 6, void (Ml = null); e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null } if (null !== (t = t.sibling)) return void (Ml = t); Ml = t = e } while (null !== t); 0 === Rl && (Rl = 5) } function wc(e, t, n) { var r = bt, i = Pl.transition; try { Pl.transition = null, bt = 1, function (e, t, n, r) { do { kc() } while (null !== Zl); if (0 !== (6 & jl)) throw Error(o(327)); n = e.finishedWork; var i = e.finishedLanes; if (null === n) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(o(177)); e.callbackNode = null, e.callbackPriority = 0; var a = n.lanes | n.childLanes; if (function (e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - at(n), o = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o } }(e, a), e === Nl && (Ml = Nl = null, Tl = 0), 0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags) || ql || (ql = !0, Nc(tt, (function () { return kc(), null }))), a = 0 !== (15990 & n.flags), 0 !== (15990 & n.subtreeFlags) || a) { a = Pl.transition, Pl.transition = null; var s = bt; bt = 1; var l = jl; jl |= 4, Cl.current = null, function (e, t) { if (ei = Yt, fr(e = hr())) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection(); if (r && 0 !== r.rangeCount) { n = r.anchorNode; var i = r.anchorOffset, a = r.focusNode; r = r.focusOffset; try { n.nodeType, a.nodeType } catch (w) { n = null; break e } var s = 0, l = -1, c = -1, u = 0, d = 0, h = e, f = null; t: for (; ;) { for (var p; h !== n || 0 !== i && 3 !== h.nodeType || (l = s + i), h !== a || 0 !== r && 3 !== h.nodeType || (c = s + r), 3 === h.nodeType && (s += h.nodeValue.length), null !== (p = h.firstChild);)f = h, h = p; for (; ;) { if (h === e) break t; if (f === n && ++u === i && (l = s), f === a && ++d === r && (c = s), null !== (p = h.nextSibling)) break; f = (h = f).parentNode } h = p } n = -1 === l || -1 === c ? null : { start: l, end: c } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (ti = { focusedElem: e, selectionRange: n }, Yt = !1, _s = t; null !== _s;)if (e = (t = _s).child, 0 !== (1028 & t.subtreeFlags) && null !== e) e.return = t, _s = e; else for (; null !== _s;) { t = _s; try { var m = t.alternate; if (0 !== (1024 & t.flags)) switch (t.tag) { case 0: case 11: case 15: case 5: case 6: case 4: case 17: break; case 1: if (null !== m) { var g = m.memoizedProps, v = m.memoizedState, y = t.stateNode, b = y.getSnapshotBeforeUpdate(t.elementType === t.type ? g : ns(t.type, g), v); y.__reactInternalSnapshotBeforeUpdate = b } break; case 3: var x = t.stateNode.containerInfo; 1 === x.nodeType ? x.textContent = "" : 9 === x.nodeType && x.documentElement && x.removeChild(x.documentElement); break; default: throw Error(o(163)) } } catch (w) { Ac(t, t.return, w) } if (null !== (e = t.sibling)) { e.return = t.return, _s = e; break } _s = t.return } m = tl, tl = !1 }(e, n), gl(n, e), pr(ti), Yt = !!ei, ti = ei = null, e.current = n, yl(n, e, i), Ge(), jl = l, bt = s, Pl.transition = a } else e.current = n; if (ql && (ql = !1, Zl = e, Kl = i), a = e.pendingLanes, 0 === a && (Ql = null), function (e) { if (ot && "function" === typeof ot.onCommitFiberRoot) try { ot.onCommitFiberRoot(it, e, void 0, 128 === (128 & e.current.flags)) } catch (t) { } }(n.stateNode), rc(e, Je()), null !== t) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (Yl) throw Yl = !1, e = Xl, Xl = null, e; 0 !== (1 & Kl) && 0 !== e.tag && kc(), a = e.pendingLanes, 0 !== (1 & a) ? e === Jl ? Gl++ : (Gl = 0, Jl = e) : Gl = 0, Wi() }(e, t, n, r) } finally { Pl.transition = i, bt = r } return null } function kc() { if (null !== Zl) { var e = xt(Kl), t = Pl.transition, n = bt; try { if (Pl.transition = null, bt = 16 > e ? 16 : e, null === Zl) var r = !1; else { if (e = Zl, Zl = null, Kl = 0, 0 !== (6 & jl)) throw Error(o(331)); var i = jl; for (jl |= 4, _s = e.current; null !== _s;) { var a = _s, s = a.child; if (0 !== (16 & _s.flags)) { var l = a.deletions; if (null !== l) { for (var c = 0; c < l.length; c++) { var u = l[c]; for (_s = u; null !== _s;) { var d = _s; switch (d.tag) { case 0: case 11: case 15: nl(8, d, a) }var h = d.child; if (null !== h) h.return = d, _s = h; else for (; null !== _s;) { var f = (d = _s).sibling, p = d.return; if (ol(d), d === u) { _s = null; break } if (null !== f) { f.return = p, _s = f; break } _s = p } } } var m = a.alternate; if (null !== m) { var g = m.child; if (null !== g) { m.child = null; do { var v = g.sibling; g.sibling = null, g = v } while (null !== g) } } _s = a } } if (0 !== (2064 & a.subtreeFlags) && null !== s) s.return = a, _s = s; else e: for (; null !== _s;) { if (0 !== (2048 & (a = _s).flags)) switch (a.tag) { case 0: case 11: case 15: nl(9, a, a.return) }var y = a.sibling; if (null !== y) { y.return = a.return, _s = y; break e } _s = a.return } } var b = e.current; for (_s = b; null !== _s;) { var x = (s = _s).child; if (0 !== (2064 & s.subtreeFlags) && null !== x) x.return = s, _s = x; else e: for (s = b; null !== _s;) { if (0 !== (2048 & (l = _s).flags)) try { switch (l.tag) { case 0: case 11: case 15: rl(9, l) } } catch (k) { Ac(l, l.return, k) } if (l === s) { _s = null; break e } var w = l.sibling; if (null !== w) { w.return = l.return, _s = w; break e } _s = l.return } } if (jl = i, Wi(), ot && "function" === typeof ot.onPostCommitFiberRoot) try { ot.onPostCommitFiberRoot(it, e) } catch (k) { } r = !0 } return r } finally { bt = n, Pl.transition = t } } return !1 } function Sc(e, t, n) { e = Vo(e, t = fs(0, t = cs(n, t), 1), 1), t = ec(), null !== e && (vt(e, 1, t), rc(e, t)) } function Ac(e, t, n) { if (3 === e.tag) Sc(e, e, n); else for (; null !== t;) { if (3 === t.tag) { Sc(t, e, n); break } if (1 === t.tag) { var r = t.stateNode; if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === Ql || !Ql.has(r))) { t = Vo(t, e = ps(t, e = cs(n, e), 1), 1), e = ec(), null !== t && (vt(t, 1, e), rc(t, e)); break } } t = t.return } } function Ec(e, t, n) { var r = e.pingCache; null !== r && r.delete(t), t = ec(), e.pingedLanes |= e.suspendedLanes & n, Nl === e && (Tl & n) === n && (4 === Rl || 3 === Rl && (130023424 & Tl) === Tl && 500 > Je() - Ul ? hc(e, 0) : Bl |= n), rc(e, t) } function Cc(e, t) { 0 === t && (0 === (1 & e.mode) ? t = 1 : (t = ut, 0 === (130023424 & (ut <<= 1)) && (ut = 4194304))); var n = ec(); null !== (e = Do(e, t)) && (vt(e, t, n), rc(e, n)) } function Pc(e) { var t = e.memoizedState, n = 0; null !== t && (n = t.retryLane), Cc(e, n) } function jc(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; null !== i && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(o(314)) }null !== r && r.delete(t), Cc(e, n) } function Nc(e, t) { return qe(e, t) } function Mc(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Tc(e, t, n, r) { return new Mc(e, t, n, r) } function Ic(e) { return !(!(e = e.prototype) || !e.isReactComponent) } function Lc(e, t) { var n = e.alternate; return null === n ? ((n = Tc(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Rc(e, t, n, r, i, a) { var s = 2; if (r = e, "function" === typeof e) Ic(e) && (s = 1); else if ("string" === typeof e) s = 5; else e: switch (e) { case S: return Dc(n.children, i, a, t); case A: s = 8, i |= 8; break; case E: return (e = Tc(12, n, t, 2 | i)).elementType = E, e.lanes = a, e; case N: return (e = Tc(13, n, t, i)).elementType = N, e.lanes = a, e; case M: return (e = Tc(19, n, t, i)).elementType = M, e.lanes = a, e; case L: return zc(n, i, a, t); default: if ("object" === typeof e && null !== e) switch (e.$$typeof) { case C: s = 10; break e; case P: s = 9; break e; case j: s = 11; break e; case T: s = 14; break e; case I: s = 16, r = null; break e }throw Error(o(130, null == e ? e : typeof e, "")) }return (t = Tc(s, n, t, i)).elementType = e, t.type = r, t.lanes = a, t } function Dc(e, t, n, r) { return (e = Tc(7, e, r, t)).lanes = n, e } function zc(e, t, n, r) { return (e = Tc(22, e, r, t)).elementType = L, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function Oc(e, t, n) { return (e = Tc(6, e, null, t)).lanes = n, e } function Bc(e, t, n) { return (t = Tc(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function Fc(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gt(0), this.expirationTimes = gt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gt(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function Vc(e, t, n, r, i, o, a, s, l) { return e = new Fc(e, t, n, s, l), 1 === t ? (t = 1, !0 === o && (t |= 8)) : t = 0, o = Tc(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Oo(o), e } function Uc(e) { if (!e) return Pi; e: { if (We(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(o(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Ii(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (null !== t); throw Error(o(171)) } if (1 === e.tag) { var n = e.type; if (Ii(n)) return Di(e, n, t) } return t } function Wc(e, t, n, r, i, o, a, s, l) { return (e = Vc(n, r, !0, e, 0, o, 0, s, l)).context = Uc(null), n = e.current, (o = Fo(r = ec(), i = tc(n))).callback = void 0 !== t && null !== t ? t : null, Vo(n, o, i), e.current.lanes = i, vt(e, i, r), rc(e, r), e } function Hc(e, t, n, r) { var i = t.current, o = ec(), a = tc(i); return n = Uc(n), null === t.context ? t.context = n : t.pendingContext = n, (t = Fo(o, a)).payload = { element: e }, null !== (r = void 0 === r ? null : r) && (t.callback = r), null !== (e = Vo(i, t, a)) && (nc(e, i, a, o), Uo(e, i, a)), a } function Yc(e) { return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null } function Xc(e, t) { if (null !== (e = e.memoizedState) && null !== e.dehydrated) { var n = e.retryLane; e.retryLane = 0 !== n && n < t ? n : t } } function Qc(e, t) { Xc(e, t), (e = e.alternate) && Xc(e, t) } Sl = function (e, t, n) { if (null !== e) if (e.memoizedProps !== t.pendingProps || Ni.current) bs = !0; else { if (0 === (e.lanes & n) && 0 === (128 & t.flags)) return bs = !1, function (e, t, n) { switch (t.tag) { case 3: Ns(t), po(); break; case 5: _o(t); break; case 1: Ii(t.type) && zi(t); break; case 4: Go(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; Ci(So, r._currentValue), r._currentValue = i; break; case 13: if (null !== (r = t.memoizedState)) return null !== r.dehydrated ? (Ci(ea, 1 & ea.current), t.flags |= 128, null) : 0 !== (n & t.child.childLanes) ? Os(e, t, n) : (Ci(ea, 1 & ea.current), null !== (e = Ys(e, t, n)) ? e.sibling : null); Ci(ea, 1 & ea.current); break; case 19: if (r = 0 !== (n & t.childLanes), 0 !== (128 & e.flags)) { if (r) return Ws(e, t, n); t.flags |= 128 } if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), Ci(ea, ea.current), r) break; return null; case 22: case 23: return t.lanes = 0, As(e, t, n) }return Ys(e, t, n) }(e, t, n); bs = 0 !== (131072 & e.flags) } else bs = !1, io && 0 !== (1048576 & t.flags) && $i(t, Qi, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Hs(e, t), e = t.pendingProps; var i = Ti(t, ji.current); Mo(t, n), i = ga(null, t, r, e, i, n); var a = va(); return t.flags |= 1, "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ii(r) ? (a = !0, zi(t)) : a = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, Oo(t), i.updater = is, t.stateNode = i, i._reactInternals = t, ls(t, r, e, n), t = js(null, t, r, !0, a, n)) : (t.tag = 0, io && a && eo(t), xs(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Hs(e, t), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function (e) { if ("function" === typeof e) return Ic(e) ? 1 : 0; if (void 0 !== e && null !== e) { if ((e = e.$$typeof) === j) return 11; if (e === T) return 14 } return 2 }(r), e = ns(r, e), i) { case 0: t = Cs(null, t, r, e, n); break e; case 1: t = Ps(null, t, r, e, n); break e; case 11: t = ws(null, t, r, e, n); break e; case 14: t = ks(null, t, r, ns(r.type, e), n); break e }throw Error(o(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, Cs(e, t, r, i = t.elementType === r ? i : ns(r, i), n); case 1: return r = t.type, i = t.pendingProps, Ps(e, t, r, i = t.elementType === r ? i : ns(r, i), n); case 3: e: { if (Ns(t), null === e) throw Error(o(387)); r = t.pendingProps, i = (a = t.memoizedState).element, Bo(e, t), Ho(t, r, null, n); var s = t.memoizedState; if (r = s.element, a.isDehydrated) { if (a = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = a, t.memoizedState = a, 256 & t.flags) { t = Ms(e, t, r, n, i = cs(Error(o(423)), t)); break e } if (r !== i) { t = Ms(e, t, r, n, i = cs(Error(o(424)), t)); break e } for (ro = ci(t.stateNode.containerInfo.firstChild), no = t, io = !0, oo = null, n = ko(t, null, r, n), t.child = n; n;)n.flags = -3 & n.flags | 4096, n = n.sibling } else { if (po(), r === i) { t = Ys(e, t, n); break e } xs(e, t, r, n) } t = t.child } return t; case 5: return _o(t), null === e && co(t), r = t.type, i = t.pendingProps, a = null !== e ? e.memoizedProps : null, s = i.children, ni(r, i) ? s = null : null !== a && ni(r, a) && (t.flags |= 32), Es(e, t), xs(e, t, s, n), t.child; case 6: return null === e && co(t), null; case 13: return Os(e, t, n); case 4: return Go(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = wo(t, null, r, n) : xs(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, ws(e, t, r, i = t.elementType === r ? i : ns(r, i), n); case 7: return xs(e, t, t.pendingProps, n), t.child; case 8: case 12: return xs(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, a = t.memoizedProps, s = i.value, Ci(So, r._currentValue), r._currentValue = s, null !== a) if (sr(a.value, s)) { if (a.children === i.children && !Ni.current) { t = Ys(e, t, n); break e } } else for (null !== (a = t.child) && (a.return = t); null !== a;) { var l = a.dependencies; if (null !== l) { s = a.child; for (var c = l.firstContext; null !== c;) { if (c.context === r) { if (1 === a.tag) { (c = Fo(-1, n & -n)).tag = 2; var u = a.updateQueue; if (null !== u) { var d = (u = u.shared).pending; null === d ? c.next = c : (c.next = d.next, d.next = c), u.pending = c } } a.lanes |= n, null !== (c = a.alternate) && (c.lanes |= n), No(a.return, n, t), l.lanes |= n; break } c = c.next } } else if (10 === a.tag) s = a.type === t.type ? null : a.child; else if (18 === a.tag) { if (null === (s = a.return)) throw Error(o(341)); s.lanes |= n, null !== (l = s.alternate) && (l.lanes |= n), No(s, n, t), s = a.sibling } else s = a.child; if (null !== s) s.return = a; else for (s = a; null !== s;) { if (s === t) { s = null; break } if (null !== (a = s.sibling)) { a.return = s.return, s = a; break } s = s.return } a = s } xs(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, Mo(t, n), r = r(i = To(i)), t.flags |= 1, xs(e, t, r, n), t.child; case 14: return i = ns(r = t.type, t.pendingProps), ks(e, t, r, i = ns(r.type, i), n); case 15: return Ss(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : ns(r, i), Hs(e, t), t.tag = 1, Ii(r) ? (e = !0, zi(t)) : e = !1, Mo(t, n), as(t, r, i), ls(t, r, i, n), js(null, t, r, !0, e, n); case 19: return Ws(e, t, n); case 22: return As(e, t, n) }throw Error(o(156, t.tag)) }; var qc = "function" === typeof reportError ? reportError : function (e) { console.error(e) }; function Zc(e) { this._internalRoot = e } function Kc(e) { this._internalRoot = e } function Gc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType) } function Jc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue)) } function _c() { } function $c(e, t, n, r, i) { var o = n._reactRootContainer; if (o) { var a = o; if ("function" === typeof i) { var s = i; i = function () { var e = Yc(a); s.call(e) } } Hc(t, a, e, i) } else a = function (e, t, n, r, i) { if (i) { if ("function" === typeof r) { var o = r; r = function () { var e = Yc(a); o.call(e) } } var a = Wc(t, r, e, 0, null, !1, 0, "", _c); return e._reactRootContainer = a, e[pi] = a.current, Wr(8 === e.nodeType ? e.parentNode : e), uc(), a } for (; i = e.lastChild;)e.removeChild(i); if ("function" === typeof r) { var s = r; r = function () { var e = Yc(l); s.call(e) } } var l = Vc(e, 0, !1, null, 0, !1, 0, "", _c); return e._reactRootContainer = l, e[pi] = l.current, Wr(8 === e.nodeType ? e.parentNode : e), uc((function () { Hc(t, l, n, r) })), l }(n, t, e, i, r); return Yc(a) } Kc.prototype.render = Zc.prototype.render = function (e) { var t = this._internalRoot; if (null === t) throw Error(o(409)); Hc(e, t, null, null) }, Kc.prototype.unmount = Zc.prototype.unmount = function () { var e = this._internalRoot; if (null !== e) { this._internalRoot = null; var t = e.containerInfo; uc((function () { Hc(null, e, null, null) })), t[pi] = null } }, Kc.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = At(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Lt.length && 0 !== t && t < Lt[n].priority; n++); Lt.splice(n, 0, e), 0 === n && Ot(e) } }, wt = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = dt(t.pendingLanes); 0 !== n && (yt(t, 1 | n), rc(t, Je()), 0 === (6 & jl) && (Wl = Je() + 500, Wi())) } break; case 13: uc((function () { var t = Do(e, 1); if (null !== t) { var n = ec(); nc(t, e, 1, n) } })), Qc(e, 1) } }, kt = function (e) { if (13 === e.tag) { var t = Do(e, 134217728); if (null !== t) nc(t, e, 134217728, ec()); Qc(e, 134217728) } }, St = function (e) { if (13 === e.tag) { var t = tc(e), n = Do(e, t); if (null !== n) nc(n, e, t, ec()); Qc(e, t) } }, At = function () { return bt }, Et = function (e, t) { var n = bt; try { return bt = e, t() } finally { bt = n } }, ke = function (e, t, n) { switch (t) { case "input": if (_(e, n), t = n.name, "radio" === n.type && null != t) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = wi(r); if (!i) throw Error(o(90)); q(r), _(r, i) } } } break; case "textarea": oe(e, n); break; case "select": null != (t = n.value) && ne(e, !!n.multiple, t, !1) } }, je = cc, Ne = uc; var eu = { usingClientEntryPoint: !1, Events: [bi, xi, wi, Ce, Pe, cc] }, tu = { findFiberByHostInstance: yi, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, nu = { bundleType: tu.bundleType, version: tu.version, rendererPackageName: tu.rendererPackageName, rendererConfig: tu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: x.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return null === (e = Xe(e)) ? null : e.stateNode }, findFiberByHostInstance: tu.findFiberByHostInstance || function () { return null }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) { var ru = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!ru.isDisabled && ru.supportsFiber) try { it = ru.inject(nu), ot = ru } catch (ue) { } } t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = eu, t.createPortal = function (e, t) { var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null; if (!Gc(t)) throw Error(o(200)); return function (e, t, n) { var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null; return { $$typeof: k, key: null == r ? null : "" + r, children: e, containerInfo: t, implementation: n } }(e, t, null, n) }, t.createRoot = function (e, t) { if (!Gc(e)) throw Error(o(299)); var n = !1, r = "", i = qc; return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = Vc(e, 1, !1, null, 0, n, 0, r, i), e[pi] = t.current, Wr(8 === e.nodeType ? e.parentNode : e), new Zc(t) }, t.findDOMNode = function (e) { if (null == e) return null; if (1 === e.nodeType) return e; var t = e._reactInternals; if (void 0 === t) { if ("function" === typeof e.render) throw Error(o(188)); throw e = Object.keys(e).join(","), Error(o(268, e)) } return e = null === (e = Xe(t)) ? null : e.stateNode }, t.flushSync = function (e) { return uc(e) }, t.hydrate = function (e, t, n) { if (!Jc(t)) throw Error(o(200)); return $c(null, e, t, !0, n) }, t.hydrateRoot = function (e, t, n) { if (!Gc(e)) throw Error(o(405)); var r = null != n && n.hydratedSources || null, i = !1, a = "", s = qc; if (null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (i = !0), void 0 !== n.identifierPrefix && (a = n.identifierPrefix), void 0 !== n.onRecoverableError && (s = n.onRecoverableError)), t = Wc(t, null, e, 1, null != n ? n : null, i, 0, a, s), e[pi] = t.current, Wr(e), r) for (e = 0; e < r.length; e++)i = (i = (n = r[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new Kc(t) }, t.render = function (e, t, n) { if (!Jc(t)) throw Error(o(200)); return $c(null, e, t, !1, n) }, t.unmountComponentAtNode = function (e) { if (!Jc(e)) throw Error(o(40)); return !!e._reactRootContainer && (uc((function () { $c(null, null, e, !1, (function () { e._reactRootContainer = null, e[pi] = null })) })), !0) }, t.unstable_batchedUpdates = cc, t.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Jc(n)) throw Error(o(200)); if (null == e || void 0 === e._reactInternals) throw Error(o(38)); return $c(e, t, n, !1, r) }, t.version = "18.3.1-next-f1338f8080-20240426" }, 391: (e, t, n) => { "use strict"; var r = n(950); t.createRoot = r.createRoot, t.hydrateRoot = r.hydrateRoot }, 950: (e, t, n) => { "use strict"; !function e() { if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } }(), e.exports = n(730) }, 818: (e, t, n) => { var r = n(43); function i(e) { return e && "object" === typeof e && "default" in e ? e : { default: e } } var o = i(r); !function (e) { if (!e || "undefined" === typeof window) return; const t = document.createElement("style"); t.setAttribute("type", "text/css"), t.innerHTML = e, document.head.appendChild(t) }('.rfm-marquee-container {\n  overflow-x: hidden;\n  display: flex;\n  flex-direction: row;\n  position: relative;\n  width: var(--width);\n  transform: var(--transform);\n}\n.rfm-marquee-container:hover div {\n  animation-play-state: var(--pause-on-hover);\n}\n.rfm-marquee-container:active div {\n  animation-play-state: var(--pause-on-click);\n}\n\n.rfm-overlay {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n}\n.rfm-overlay::before, .rfm-overlay::after {\n  background: linear-gradient(to right, var(--gradient-color), rgba(255, 255, 255, 0));\n  content: "";\n  height: 100%;\n  position: absolute;\n  width: var(--gradient-width);\n  z-index: 2;\n  pointer-events: none;\n  touch-action: none;\n}\n.rfm-overlay::after {\n  right: 0;\n  top: 0;\n  transform: rotateZ(180deg);\n}\n.rfm-overlay::before {\n  left: 0;\n  top: 0;\n}\n\n.rfm-marquee {\n  flex: 0 0 auto;\n  min-width: var(--min-width);\n  z-index: 1;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  animation: scroll var(--duration) linear var(--delay) var(--iteration-count);\n  animation-play-state: var(--play);\n  animation-delay: var(--delay);\n  animation-direction: var(--direction);\n}\n@keyframes scroll {\n  0% {\n    transform: translateX(0%);\n  }\n  100% {\n    transform: translateX(-100%);\n  }\n}\n\n.rfm-initial-child-container {\n  flex: 0 0 auto;\n  display: flex;\n  min-width: auto;\n  flex-direction: row;\n  align-items: center;\n}\n\n.rfm-child {\n  transform: var(--transform);\n}'); const a = r.forwardRef((function (e, t) { let { style: n = {}, className: i = "", autoFill: a = !1, play: s = !0, pauseOnHover: l = !1, pauseOnClick: c = !1, direction: u = "left", speed: d = 50, delay: h = 0, loop: f = 0, gradient: p = !1, gradientColor: m = "white", gradientWidth: g = 200, onFinish: v, onCycleComplete: y, onMount: b, children: x } = e; const [w, k] = r.useState(0), [S, A] = r.useState(0), [E, C] = r.useState(1), [P, j] = r.useState(!1), N = r.useRef(null), M = t || N, T = r.useRef(null), I = r.useCallback((() => { if (T.current && M.current) { const e = M.current.getBoundingClientRect(), t = T.current.getBoundingClientRect(); let n = e.width, r = t.width; "up" !== u && "down" !== u || (n = e.height, r = t.height), C(a && n && r && r < n ? Math.ceil(n / r) : 1), k(n), A(r) } }), [a, M, u]); r.useEffect((() => { if (P && (I(), T.current && M.current)) { const e = new ResizeObserver((() => I())); return e.observe(M.current), e.observe(T.current), () => { e && e.disconnect() } } }), [I, M, P]), r.useEffect((() => { I() }), [I, x]), r.useEffect((() => { j(!0) }), []), r.useEffect((() => { "function" === typeof b && b() }), []); const L = r.useMemo((() => a ? S * E / d : S < w ? w / d : S / d), [a, w, S, E, d]), R = r.useMemo((() => Object.assign(Object.assign({}, n), { "--pause-on-hover": !s || l ? "paused" : "running", "--pause-on-click": !s || l && !c || c ? "paused" : "running", "--width": "up" === u || "down" === u ? "100vh" : "100%", "--transform": "up" === u ? "rotate(-90deg)" : "down" === u ? "rotate(90deg)" : "none" })), [n, s, l, c, u]), D = r.useMemo((() => ({ "--gradient-color": m, "--gradient-width": "number" === typeof g ? "".concat(g, "px") : g })), [m, g]), z = r.useMemo((() => ({ "--play": s ? "running" : "paused", "--direction": "left" === u ? "normal" : "reverse", "--duration": "".concat(L, "s"), "--delay": "".concat(h, "s"), "--iteration-count": f ? "".concat(f) : "infinite", "--min-width": a ? "auto" : "100%" })), [s, u, L, h, f, a]), O = r.useMemo((() => ({ "--transform": "up" === u ? "rotate(90deg)" : "down" === u ? "rotate(-90deg)" : "none" })), [u]), B = r.useCallback((e => [...Array(Number.isFinite(e) && e >= 0 ? e : 0)].map(((e, t) => o.default.createElement(r.Fragment, { key: t }, r.Children.map(x, (e => o.default.createElement("div", { style: O, className: "rfm-child" }, e))))))), [O, x]); return P ? o.default.createElement("div", { ref: M, style: R, className: "rfm-marquee-container " + i }, p && o.default.createElement("div", { style: D, className: "rfm-overlay" }), o.default.createElement("div", { className: "rfm-marquee", style: z, onAnimationIteration: y, onAnimationEnd: v }, o.default.createElement("div", { className: "rfm-initial-child-container", ref: T }, r.Children.map(x, (e => o.default.createElement("div", { style: O, className: "rfm-child" }, e)))), B(E - 1)), o.default.createElement("div", { className: "rfm-marquee", style: z }, B(E))) : null })); t.A = a }, 153: (e, t, n) => { "use strict"; var r = n(43), i = Symbol.for("react.element"), o = Symbol.for("react.fragment"), a = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, l = { key: !0, ref: !0, __self: !0, __source: !0 }; function c(e, t, n) { var r, o = {}, c = null, u = null; for (r in void 0 !== n && (c = "" + n), void 0 !== t.key && (c = "" + t.key), void 0 !== t.ref && (u = t.ref), t) a.call(t, r) && !l.hasOwnProperty(r) && (o[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps) void 0 === o[r] && (o[r] = t[r]); return { $$typeof: i, type: e, key: c, ref: u, props: o, _owner: s.current } } t.Fragment = o, t.jsx = c, t.jsxs = c }, 202: (e, t) => { "use strict"; var n = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), f = Symbol.iterator; var p = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, m = Object.assign, g = {}; function v(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || p } function y() { } function b(e, t, n) { this.props = e, this.context = t, this.refs = g, this.updater = n || p } v.prototype.isReactComponent = {}, v.prototype.setState = function (e, t) { if ("object" !== typeof e && "function" !== typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }, v.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }, y.prototype = v.prototype; var x = b.prototype = new y; x.constructor = b, m(x, v.prototype), x.isPureReactComponent = !0; var w = Array.isArray, k = Object.prototype.hasOwnProperty, S = { current: null }, A = { key: !0, ref: !0, __self: !0, __source: !0 }; function E(e, t, r) { var i, o = {}, a = null, s = null; if (null != t) for (i in void 0 !== t.ref && (s = t.ref), void 0 !== t.key && (a = "" + t.key), t) k.call(t, i) && !A.hasOwnProperty(i) && (o[i] = t[i]); var l = arguments.length - 2; if (1 === l) o.children = r; else if (1 < l) { for (var c = Array(l), u = 0; u < l; u++)c[u] = arguments[u + 2]; o.children = c } if (e && e.defaultProps) for (i in l = e.defaultProps) void 0 === o[i] && (o[i] = l[i]); return { $$typeof: n, type: e, key: a, ref: s, props: o, _owner: S.current } } function C(e) { return "object" === typeof e && null !== e && e.$$typeof === n } var P = /\/+/g; function j(e, t) { return "object" === typeof e && null !== e && null != e.key ? function (e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, (function (e) { return t[e] })) }("" + e.key) : t.toString(36) } function N(e, t, i, o, a) { var s = typeof e; "undefined" !== s && "boolean" !== s || (e = null); var l = !1; if (null === e) l = !0; else switch (s) { case "string": case "number": l = !0; break; case "object": switch (e.$$typeof) { case n: case r: l = !0 } }if (l) return a = a(l = e), e = "" === o ? "." + j(l, 0) : o, w(a) ? (i = "", null != e && (i = e.replace(P, "$&/") + "/"), N(a, t, i, "", (function (e) { return e }))) : null != a && (C(a) && (a = function (e, t) { return { $$typeof: n, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } }(a, i + (!a.key || l && l.key === a.key ? "" : ("" + a.key).replace(P, "$&/") + "/") + e)), t.push(a)), 1; if (l = 0, o = "" === o ? "." : o + ":", w(e)) for (var c = 0; c < e.length; c++) { var u = o + j(s = e[c], c); l += N(s, t, i, u, a) } else if (u = function (e) { return null === e || "object" !== typeof e ? null : "function" === typeof (e = f && e[f] || e["@@iterator"]) ? e : null }(e), "function" === typeof u) for (e = u.call(e), c = 0; !(s = e.next()).done;)l += N(s = s.value, t, i, u = o + j(s, c++), a); else if ("object" === s) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return l } function M(e, t, n) { if (null == e) return e; var r = [], i = 0; return N(e, r, "", "", (function (e) { return t.call(n, e, i++) })), r } function T(e) { if (-1 === e._status) { var t = e._result; (t = t()).then((function (t) { 0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t) }), (function (t) { 0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t) })), -1 === e._status && (e._status = 0, e._result = t) } if (1 === e._status) return e._result.default; throw e._result } var I = { current: null }, L = { transition: null }, R = { ReactCurrentDispatcher: I, ReactCurrentBatchConfig: L, ReactCurrentOwner: S }; function D() { throw Error("act(...) is not supported in production builds of React.") } t.Children = { map: M, forEach: function (e, t, n) { M(e, (function () { t.apply(this, arguments) }), n) }, count: function (e) { var t = 0; return M(e, (function () { t++ })), t }, toArray: function (e) { return M(e, (function (e) { return e })) || [] }, only: function (e) { if (!C(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }, t.Component = v, t.Fragment = i, t.Profiler = a, t.PureComponent = b, t.StrictMode = o, t.Suspense = u, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = R, t.act = D, t.cloneElement = function (e, t, r) { if (null === e || void 0 === e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var i = m({}, e.props), o = e.key, a = e.ref, s = e._owner; if (null != t) { if (void 0 !== t.ref && (a = t.ref, s = S.current), void 0 !== t.key && (o = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps; for (c in t) k.call(t, c) && !A.hasOwnProperty(c) && (i[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c]) } var c = arguments.length - 2; if (1 === c) i.children = r; else if (1 < c) { l = Array(c); for (var u = 0; u < c; u++)l[u] = arguments[u + 2]; i.children = l } return { $$typeof: n, type: e.type, key: o, ref: a, props: i, _owner: s } }, t.createContext = function (e) { return (e = { $$typeof: l, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }).Provider = { $$typeof: s, _context: e }, e.Consumer = e }, t.createElement = E, t.createFactory = function (e) { var t = E.bind(null, e); return t.type = e, t }, t.createRef = function () { return { current: null } }, t.forwardRef = function (e) { return { $$typeof: c, render: e } }, t.isValidElement = C, t.lazy = function (e) { return { $$typeof: h, _payload: { _status: -1, _result: e }, _init: T } }, t.memo = function (e, t) { return { $$typeof: d, type: e, compare: void 0 === t ? null : t } }, t.startTransition = function (e) { var t = L.transition; L.transition = {}; try { e() } finally { L.transition = t } }, t.unstable_act = D, t.useCallback = function (e, t) { return I.current.useCallback(e, t) }, t.useContext = function (e) { return I.current.useContext(e) }, t.useDebugValue = function () { }, t.useDeferredValue = function (e) { return I.current.useDeferredValue(e) }, t.useEffect = function (e, t) { return I.current.useEffect(e, t) }, t.useId = function () { return I.current.useId() }, t.useImperativeHandle = function (e, t, n) { return I.current.useImperativeHandle(e, t, n) }, t.useInsertionEffect = function (e, t) { return I.current.useInsertionEffect(e, t) }, t.useLayoutEffect = function (e, t) { return I.current.useLayoutEffect(e, t) }, t.useMemo = function (e, t) { return I.current.useMemo(e, t) }, t.useReducer = function (e, t, n) { return I.current.useReducer(e, t, n) }, t.useRef = function (e) { return I.current.useRef(e) }, t.useState = function (e) { return I.current.useState(e) }, t.useSyncExternalStore = function (e, t, n) { return I.current.useSyncExternalStore(e, t, n) }, t.useTransition = function () { return I.current.useTransition() }, t.version = "18.3.1" }, 43: (e, t, n) => { "use strict"; e.exports = n(202) }, 579: (e, t, n) => { "use strict"; e.exports = n(153) }, 234: (e, t) => { "use strict"; function n(e, t) { var n = e.length; e.push(t); e: for (; 0 < n;) { var r = n - 1 >>> 1, i = e[r]; if (!(0 < o(i, t))) break e; e[r] = t, e[n] = i, n = r } } function r(e) { return 0 === e.length ? null : e[0] } function i(e) { if (0 === e.length) return null; var t = e[0], n = e.pop(); if (n !== t) { e[0] = n; e: for (var r = 0, i = e.length, a = i >>> 1; r < a;) { var s = 2 * (r + 1) - 1, l = e[s], c = s + 1, u = e[c]; if (0 > o(l, n)) c < i && 0 > o(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[s] = n, r = s); else { if (!(c < i && 0 > o(u, n))) break e; e[r] = u, e[c] = n, r = c } } } return t } function o(e, t) { var n = e.sortIndex - t.sortIndex; return 0 !== n ? n : e.id - t.id } if ("object" === typeof performance && "function" === typeof performance.now) { var a = performance; t.unstable_now = function () { return a.now() } } else { var s = Date, l = s.now(); t.unstable_now = function () { return s.now() - l } } var c = [], u = [], d = 1, h = null, f = 3, p = !1, m = !1, g = !1, v = "function" === typeof setTimeout ? setTimeout : null, y = "function" === typeof clearTimeout ? clearTimeout : null, b = "undefined" !== typeof setImmediate ? setImmediate : null; function x(e) { for (var t = r(u); null !== t;) { if (null === t.callback) i(u); else { if (!(t.startTime <= e)) break; i(u), t.sortIndex = t.expirationTime, n(c, t) } t = r(u) } } function w(e) { if (g = !1, x(e), !m) if (null !== r(c)) m = !0, L(k); else { var t = r(u); null !== t && R(w, t.startTime - e) } } function k(e, n) { m = !1, g && (g = !1, y(C), C = -1), p = !0; var o = f; try { for (x(n), h = r(c); null !== h && (!(h.expirationTime > n) || e && !N());) { var a = h.callback; if ("function" === typeof a) { h.callback = null, f = h.priorityLevel; var s = a(h.expirationTime <= n); n = t.unstable_now(), "function" === typeof s ? h.callback = s : h === r(c) && i(c), x(n) } else i(c); h = r(c) } if (null !== h) var l = !0; else { var d = r(u); null !== d && R(w, d.startTime - n), l = !1 } return l } finally { h = null, f = o, p = !1 } } "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling); var S, A = !1, E = null, C = -1, P = 5, j = -1; function N() { return !(t.unstable_now() - j < P) } function M() { if (null !== E) { var e = t.unstable_now(); j = e; var n = !0; try { n = E(!0, e) } finally { n ? S() : (A = !1, E = null) } } else A = !1 } if ("function" === typeof b) S = function () { b(M) }; else if ("undefined" !== typeof MessageChannel) { var T = new MessageChannel, I = T.port2; T.port1.onmessage = M, S = function () { I.postMessage(null) } } else S = function () { v(M, 0) }; function L(e) { E = e, A || (A = !0, S()) } function R(e, n) { C = v((function () { e(t.unstable_now()) }), n) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (e) { e.callback = null }, t.unstable_continueExecution = function () { m || p || (m = !0, L(k)) }, t.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < e ? Math.floor(1e3 / e) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return f }, t.unstable_getFirstCallbackNode = function () { return r(c) }, t.unstable_next = function (e) { switch (f) { case 1: case 2: case 3: var t = 3; break; default: t = f }var n = f; f = t; try { return e() } finally { f = n } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var n = f; f = e; try { return t() } finally { f = n } }, t.unstable_scheduleCallback = function (e, i, o) { var a = t.unstable_now(); switch ("object" === typeof o && null !== o ? o = "number" === typeof (o = o.delay) && 0 < o ? a + o : a : o = a, e) { case 1: var s = -1; break; case 2: s = 250; break; case 5: s = 1073741823; break; case 4: s = 1e4; break; default: s = 5e3 }return e = { id: d++, callback: i, priorityLevel: e, startTime: o, expirationTime: s = o + s, sortIndex: -1 }, o > a ? (e.sortIndex = o, n(u, e), null === r(c) && e === r(u) && (g ? (y(C), C = -1) : g = !0, R(w, o - a))) : (e.sortIndex = s, n(c, e), m || p || (m = !0, L(k))), e }, t.unstable_shouldYield = N, t.unstable_wrapCallback = function (e) { var t = f; return function () { var n = f; f = t; try { return e.apply(this, arguments) } finally { f = n } } } }, 853: (e, t, n) => { "use strict"; e.exports = n(234) }, 294: function (e, t, n) { "use strict"; var r = (this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } })(n(222)), i = n(146); function o(e, t) { var n = {}; return e && "string" === typeof e ? ((0, r.default)(e, (function (e, r) { e && r && (n[(0, i.camelCase)(e, t)] = r) })), n) : n } o.default = o, e.exports = o }, 146: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.camelCase = void 0; var n = /^--[a-zA-Z0-9_-]+$/, r = /-([a-z])/g, i = /^[^-]+$/, o = /^-(webkit|moz|ms|o|khtml)-/, a = /^-(ms)-/, s = function (e, t) { return t.toUpperCase() }, l = function (e, t) { return "".concat(t, "-") }; t.camelCase = function (e, t) { return void 0 === t && (t = {}), function (e) { return !e || i.test(e) || n.test(e) }(e) ? e : (e = e.toLowerCase(), (e = t.reactCompat ? e.replace(a, l) : e.replace(o, l)).replace(r, s)) } }, 222: function (e, t, n) { "use strict"; var r = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e, t) { var n = null; if (!e || "string" !== typeof e) return n; var r = (0, i.default)(e), o = "function" === typeof t; return r.forEach((function (e) { if ("declaration" === e.type) { var r = e.property, i = e.value; o ? t(r, i, e) : i && ((n = n || {})[r] = i) } })), n }; var i = r(n(403)) } }, t = {}; function n(r) { var i = t[r]; if (void 0 !== i) return i.exports; var o = t[r] = { exports: {} }; return e[r].call(o.exports, o, o.exports, n), o.exports } n.m = e, n.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return n.d(t, { a: t }), t }, (() => { var e, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__; n.t = function (r, i) { if (1 & i && (r = this(r)), 8 & i) return r; if ("object" === typeof r && r) { if (4 & i && r.__esModule) return r; if (16 & i && "function" === typeof r.then) return r } var o = Object.create(null); n.r(o); var a = {}; e = e || [null, t({}), t([]), t(t)]; for (var s = 2 & i && r; "object" == typeof s && !~e.indexOf(s); s = t(s))Object.getOwnPropertyNames(s).forEach((e => a[e] = () => r[e])); return a.default = () => r, n.d(o, a), o } })(), n.d = (e, t) => { for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: t[r] }) }, n.f = {}, n.e = e => Promise.all(Object.keys(n.f).reduce(((t, r) => (n.f[r](e, t), t)), [])), n.u = e => "static/js/" + e + ".09a1ab47.chunk.js", n.miniCssF = e => { }, n.g = function () { if ("object" === typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (e) { if ("object" === typeof window) return window } }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => { var e = {}, t = "magmar:"; n.l = (r, i, o, a) => { if (e[r]) e[r].push(i); else { var s, l; if (void 0 !== o) for (var c = document.getElementsByTagName("script"), u = 0; u < c.length; u++) { var d = c[u]; if (d.getAttribute("src") == r || d.getAttribute("data-webpack") == t + o) { s = d; break } } s || (l = !0, (s = document.createElement("script")).charset = "utf-8", s.timeout = 120, n.nc && s.setAttribute("nonce", n.nc), s.setAttribute("data-webpack", t + o), s.src = r), e[r] = [i]; var h = (t, n) => { s.onerror = s.onload = null, clearTimeout(f); var i = e[r]; if (delete e[r], s.parentNode && s.parentNode.removeChild(s), i && i.forEach((e => e(n))), t) return t(n) }, f = setTimeout(h.bind(null, void 0, { type: "timeout", target: s }), 12e4); s.onerror = h.bind(null, s.onerror), s.onload = h.bind(null, s.onload), l && document.head.appendChild(s) } } })(), n.r = e => { "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n.p = "/", (() => { var e = { 792: 0 }; n.f.j = (t, r) => { var i = n.o(e, t) ? e[t] : void 0; if (0 !== i) if (i) r.push(i[2]); else { var o = new Promise(((n, r) => i = e[t] = [n, r])); r.push(i[2] = o); var a = n.p + n.u(t), s = new Error; n.l(a, (r => { if (n.o(e, t) && (0 !== (i = e[t]) && (e[t] = void 0), i)) { var o = r && ("load" === r.type ? "missing" : r.type), a = r && r.target && r.target.src; s.message = "Loading chunk " + t + " failed.\n(" + o + ": " + a + ")", s.name = "ChunkLoadError", s.type = o, s.request = a, i[1](s) } }), "chunk-" + t, t) } }; var t = (t, r) => { var i, o, a = r[0], s = r[1], l = r[2], c = 0; if (a.some((t => 0 !== e[t]))) { for (i in s) n.o(s, i) && (n.m[i] = s[i]); if (l) l(n) } for (t && t(r); c < a.length; c++)o = a[c], n.o(e, o) && e[o] && e[o][0](), e[o] = 0 }, r = self.webpackChunkmagmar = self.webpackChunkmagmar || []; r.forEach(t.bind(null, 0)), r.push = t.bind(null, r.push.bind(r)) })(), (() => { "use strict"; var e = {}; n.r(e), n.d(e, { boolean: () => Ad, booleanish: () => Ed, commaOrSpaceSeparated: () => Md, commaSeparated: () => Nd, number: () => Pd, overloadedBoolean: () => Cd, spaceSeparated: () => jd }); var t = {}; n.r(t), n.d(t, { attentionMarkers: () => sp, contentInitial: () => tp, disable: () => lp, document: () => ep, flow: () => rp, flowInitial: () => np, insideSpan: () => ap, string: () => ip, text: () => op }); var r, i = n(43), o = n.t(i, 2), a = n(391), s = n(950), l = n.t(s, 2); function c() { return c = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, c.apply(this, arguments) } !function (e) { e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE" }(r || (r = {})); const u = "popstate"; function d(e, t) { if (!1 === e || null === e || "undefined" === typeof e) throw new Error(t) } function h(e, t) { if (!e) { "undefined" !== typeof console && console.warn(t); try { throw new Error(t) } catch (tc) { } } } function f(e, t) { return { usr: e.state, key: e.key, idx: t } } function p(e, t, n, r) { return void 0 === n && (n = null), c({ pathname: "string" === typeof e ? e : e.pathname, search: "", hash: "" }, "string" === typeof t ? g(t) : t, { state: n, key: t && t.key || r || Math.random().toString(36).substr(2, 8) }) } function m(e) { let { pathname: t = "/", search: n = "", hash: r = "" } = e; return n && "?" !== n && (t += "?" === n.charAt(0) ? n : "?" + n), r && "#" !== r && (t += "#" === r.charAt(0) ? r : "#" + r), t } function g(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e) } return t } function v(e, t, n, i) { void 0 === i && (i = {}); let { window: o = document.defaultView, v5Compat: a = !1 } = i, s = o.history, l = r.Pop, h = null, g = v(); function v() { return (s.state || { idx: null }).idx } function y() { l = r.Pop; let e = v(), t = null == e ? null : e - g; g = e, h && h({ action: l, location: x.location, delta: t }) } function b(e) { let t = "null" !== o.location.origin ? o.location.origin : o.location.href, n = "string" === typeof e ? e : m(e); return n = n.replace(/ $/, "%20"), d(t, "No window.location.(origin|href) available to create URL for href: " + n), new URL(n, t) } null == g && (g = 0, s.replaceState(c({}, s.state, { idx: g }), "")); let x = { get action() { return l }, get location() { return e(o, s) }, listen(e) { if (h) throw new Error("A history only accepts one active listener"); return o.addEventListener(u, y), h = e, () => { o.removeEventListener(u, y), h = null } }, createHref: e => t(o, e), createURL: b, encodeLocation(e) { let t = b(e); return { pathname: t.pathname, search: t.search, hash: t.hash } }, push: function (e, t) { l = r.Push; let i = p(x.location, e, t); n && n(i, e), g = v() + 1; let c = f(i, g), u = x.createHref(i); try { s.pushState(c, "", u) } catch (d) { if (d instanceof DOMException && "DataCloneError" === d.name) throw d; o.location.assign(u) } a && h && h({ action: l, location: x.location, delta: 1 }) }, replace: function (e, t) { l = r.Replace; let i = p(x.location, e, t); n && n(i, e), g = v(); let o = f(i, g), c = x.createHref(i); s.replaceState(o, "", c), a && h && h({ action: l, location: x.location, delta: 0 }) }, go: e => s.go(e) }; return x } var y; !function (e) { e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error" }(y || (y = {})); new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]); function b(e, t, n) { return void 0 === n && (n = "/"), x(e, t, n, !1) } function x(e, t, n, r) { let i = R(("string" === typeof t ? g(t) : t).pathname || "/", n); if (null == i) return null; let o = w(e); !function (e) { e.sort(((e, t) => e.score !== t.score ? t.score - e.score : function (e, t) { let n = e.length === t.length && e.slice(0, -1).every(((e, n) => e === t[n])); return n ? e[e.length - 1] - t[t.length - 1] : 0 }(e.routesMeta.map((e => e.childrenIndex)), t.routesMeta.map((e => e.childrenIndex))))) }(o); let a = null; for (let s = 0; null == a && s < o.length; ++s) { let e = L(i); a = T(o[s], e, r) } return a } function w(e, t, n, r) { void 0 === t && (t = []), void 0 === n && (n = []), void 0 === r && (r = ""); let i = (e, i, o) => { let a = { relativePath: void 0 === o ? e.path || "" : o, caseSensitive: !0 === e.caseSensitive, childrenIndex: i, route: e }; a.relativePath.startsWith("/") && (d(a.relativePath.startsWith(r), 'Absolute route path "' + a.relativePath + '" nested under path "' + r + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.'), a.relativePath = a.relativePath.slice(r.length)); let s = F([r, a.relativePath]), l = n.concat(a); e.children && e.children.length > 0 && (d(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + s + '".'), w(e.children, t, l, s)), (null != e.path || e.index) && t.push({ path: s, score: M(s, e.index), routesMeta: l }) }; return e.forEach(((e, t) => { var n; if ("" !== e.path && null != (n = e.path) && n.includes("?")) for (let r of k(e.path)) i(e, t, r); else i(e, t) })), t } function k(e) { let t = e.split("/"); if (0 === t.length) return []; let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, ""); if (0 === r.length) return i ? [o, ""] : [o]; let a = k(r.join("/")), s = []; return s.push(...a.map((e => "" === e ? o : [o, e].join("/")))), i && s.push(...a), s.map((t => e.startsWith("/") && "" === t ? "/" : t)) } const S = /^:[\w-]+$/, A = 3, E = 2, C = 1, P = 10, j = -2, N = e => "*" === e; function M(e, t) { let n = e.split("/"), r = n.length; return n.some(N) && (r += j), t && (r += E), n.filter((e => !N(e))).reduce(((e, t) => e + (S.test(t) ? A : "" === t ? C : P)), r) } function T(e, t, n) { void 0 === n && (n = !1); let { routesMeta: r } = e, i = {}, o = "/", a = []; for (let s = 0; s < r.length; ++s) { let e = r[s], l = s === r.length - 1, c = "/" === o ? t : t.slice(o.length) || "/", u = I({ path: e.relativePath, caseSensitive: e.caseSensitive, end: l }, c), d = e.route; if (!u && l && n && !r[r.length - 1].route.index && (u = I({ path: e.relativePath, caseSensitive: e.caseSensitive, end: !1 }, c)), !u) return null; Object.assign(i, u.params), a.push({ params: i, pathname: F([o, u.pathname]), pathnameBase: V(F([o, u.pathnameBase])), route: d }), "/" !== u.pathnameBase && (o = F([o, u.pathnameBase])) } return a } function I(e, t) { "string" === typeof e && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = function (e, t, n) { void 0 === t && (t = !1); void 0 === n && (n = !0); h("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were "' + e.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "' + e.replace(/\*$/, "/*") + '".'); let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, ((e, t, n) => (r.push({ paramName: t, isOptional: null != n }), n ? "/?([^\\/]+)?" : "/([^\\/]+)"))); e.endsWith("*") ? (r.push({ paramName: "*" }), i += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : "" !== e && "/" !== e && (i += "(?:(?=\\/|$))"); let o = new RegExp(i, t ? void 0 : "i"); return [o, r] }(e.path, e.caseSensitive, e.end), i = t.match(n); if (!i) return null; let o = i[0], a = o.replace(/(.)\/+$/, "$1"), s = i.slice(1), l = r.reduce(((e, t, n) => { let { paramName: r, isOptional: i } = t; if ("*" === r) { let e = s[n] || ""; a = o.slice(0, o.length - e.length).replace(/(.)\/+$/, "$1") } const l = s[n]; return e[r] = i && !l ? void 0 : (l || "").replace(/%2F/g, "/"), e }), {}); return { params: l, pathname: o, pathnameBase: a, pattern: e } } function L(e) { try { return e.split("/").map((e => decodeURIComponent(e).replace(/\//g, "%2F"))).join("/") } catch (t) { return h(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + t + ")."), e } } function R(e, t) { if ("/" === t) return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && "/" !== r ? null : e.slice(n) || "/" } function D(e, t, n, r) { return "Cannot include a '" + e + "' character in a manually specified `to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the `to." + n + '` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.' } function z(e) { return e.filter(((e, t) => 0 === t || e.route.path && e.route.path.length > 0)) } function O(e, t) { let n = z(e); return t ? n.map(((e, t) => t === n.length - 1 ? e.pathname : e.pathnameBase)) : n.map((e => e.pathnameBase)) } function B(e, t, n, r) { let i; void 0 === r && (r = !1), "string" === typeof e ? i = g(e) : (i = c({}, e), d(!i.pathname || !i.pathname.includes("?"), D("?", "pathname", "search", i)), d(!i.pathname || !i.pathname.includes("#"), D("#", "pathname", "hash", i)), d(!i.search || !i.search.includes("#"), D("#", "search", "hash", i))); let o, a = "" === e || "" === i.pathname, s = a ? "/" : i.pathname; if (null == s) o = n; else { let e = t.length - 1; if (!r && s.startsWith("..")) { let t = s.split("/"); for (; ".." === t[0];)t.shift(), e -= 1; i.pathname = t.join("/") } o = e >= 0 ? t[e] : "/" } let l = function (e, t) { void 0 === t && (t = "/"); let { pathname: n, search: r = "", hash: i = "" } = "string" === typeof e ? g(e) : e, o = n ? n.startsWith("/") ? n : function (e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach((e => { ".." === e ? n.length > 1 && n.pop() : "." !== e && n.push(e) })), n.length > 1 ? n.join("/") : "/" }(n, t) : t; return { pathname: o, search: U(r), hash: W(i) } }(i, o), u = s && "/" !== s && s.endsWith("/"), h = (a || "." === s) && n.endsWith("/"); return l.pathname.endsWith("/") || !u && !h || (l.pathname += "/"), l } const F = e => e.join("/").replace(/\/\/+/g, "/"), V = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), U = e => e && "?" !== e ? e.startsWith("?") ? e : "?" + e : "", W = e => e && "#" !== e ? e.startsWith("#") ? e : "#" + e : ""; Error; function H(e) { return null != e && "number" === typeof e.status && "string" === typeof e.statusText && "boolean" === typeof e.internal && "data" in e } const Y = ["post", "put", "patch", "delete"], X = (new Set(Y), ["get", ...Y]); new Set(X), new Set([301, 302, 303, 307, 308]), new Set([307, 308]); Symbol("deferred"); function Q() { return Q = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Q.apply(this, arguments) } const q = i.createContext(null); const Z = i.createContext(null); const K = i.createContext(null); const G = i.createContext(null); const J = i.createContext({ outlet: null, matches: [], isDataRoute: !1 }); const _ = i.createContext(null); function $() { return null != i.useContext(G) } function ee() { return $() || d(!1), i.useContext(G).location } function te(e) { i.useContext(K).static || i.useLayoutEffect(e) } function ne() { let { isDataRoute: e } = i.useContext(J); return e ? function () { let { router: e } = he(ue.UseNavigateStable), t = pe(de.UseNavigateStable), n = i.useRef(!1); te((() => { n.current = !0 })); let r = i.useCallback((function (r, i) { void 0 === i && (i = {}), n.current && ("number" === typeof r ? e.navigate(r) : e.navigate(r, Q({ fromRouteId: t }, i))) }), [e, t]); return r }() : function () { $() || d(!1); let e = i.useContext(q), { basename: t, future: n, navigator: r } = i.useContext(K), { matches: o } = i.useContext(J), { pathname: a } = ee(), s = JSON.stringify(O(o, n.v7_relativeSplatPath)), l = i.useRef(!1); te((() => { l.current = !0 })); let c = i.useCallback((function (n, i) { if (void 0 === i && (i = {}), !l.current) return; if ("number" === typeof n) return void r.go(n); let o = B(n, JSON.parse(s), a, "path" === i.relative); null == e && "/" !== t && (o.pathname = "/" === o.pathname ? t : F([t, o.pathname])), (i.replace ? r.replace : r.push)(o, i.state, i) }), [t, r, s, a, e]); return c }() } function re(e, t) { let { relative: n } = void 0 === t ? {} : t, { future: r } = i.useContext(K), { matches: o } = i.useContext(J), { pathname: a } = ee(), s = JSON.stringify(O(o, r.v7_relativeSplatPath)); return i.useMemo((() => B(e, JSON.parse(s), a, "path" === n)), [e, s, a, n]) } function ie(e, t, n, o) { $() || d(!1); let { navigator: a } = i.useContext(K), { matches: s } = i.useContext(J), l = s[s.length - 1], c = l ? l.params : {}, u = (l && l.pathname, l ? l.pathnameBase : "/"); l && l.route; let h, f = ee(); if (t) { var p; let e = "string" === typeof t ? g(t) : t; "/" === u || (null == (p = e.pathname) ? void 0 : p.startsWith(u)) || d(!1), h = e } else h = f; let m = h.pathname || "/", v = m; if ("/" !== u) { let e = u.replace(/^\//, "").split("/"); v = "/" + m.replace(/^\//, "").split("/").slice(e.length).join("/") } let y = b(e, { pathname: v }); let x = ce(y && y.map((e => Object.assign({}, e, { params: Object.assign({}, c, e.params), pathname: F([u, a.encodeLocation ? a.encodeLocation(e.pathname).pathname : e.pathname]), pathnameBase: "/" === e.pathnameBase ? u : F([u, a.encodeLocation ? a.encodeLocation(e.pathnameBase).pathname : e.pathnameBase]) }))), s, n, o); return t && x ? i.createElement(G.Provider, { value: { location: Q({ pathname: "/", search: "", hash: "", state: null, key: "default" }, h), navigationType: r.Pop } }, x) : x } function oe() { let e = function () { var e; let t = i.useContext(_), n = fe(de.UseRouteError), r = pe(de.UseRouteError); if (void 0 !== t) return t; return null == (e = n.errors) ? void 0 : e[r] }(), t = H(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, r = "rgba(200,200,200, 0.5)", o = { padding: "0.5rem", backgroundColor: r }; return i.createElement(i.Fragment, null, i.createElement("h2", null, "Unexpected Application Error!"), i.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? i.createElement("pre", { style: o }, n) : null, null) } const ae = i.createElement(oe, null); class se extends i.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { return t.location !== e.location || "idle" !== t.revalidation && "idle" === e.revalidation ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: void 0 !== e.error ? e.error : t.error, location: t.location, revalidation: e.revalidation || t.revalidation } } componentDidCatch(e, t) { console.error("React Router caught the following error during render", e, t) } render() { return void 0 !== this.state.error ? i.createElement(J.Provider, { value: this.props.routeContext }, i.createElement(_.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function le(e) { let { routeContext: t, match: n, children: r } = e, o = i.useContext(q); return o && o.static && o.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (o.staticContext._deepestRenderedBoundaryId = n.route.id), i.createElement(J.Provider, { value: t }, r) } function ce(e, t, n, r) { var o; if (void 0 === t && (t = []), void 0 === n && (n = null), void 0 === r && (r = null), null == e) { var a; if (null == (a = n) || !a.errors) return null; e = n.matches } let s = e, l = null == (o = n) ? void 0 : o.errors; if (null != l) { let e = s.findIndex((e => e.route.id && void 0 !== (null == l ? void 0 : l[e.route.id]))); e >= 0 || d(!1), s = s.slice(0, Math.min(s.length, e + 1)) } let c = !1, u = -1; if (n && r && r.v7_partialHydration) for (let i = 0; i < s.length; i++) { let e = s[i]; if ((e.route.HydrateFallback || e.route.hydrateFallbackElement) && (u = i), e.route.id) { let { loaderData: t, errors: r } = n, i = e.route.loader && void 0 === t[e.route.id] && (!r || void 0 === r[e.route.id]); if (e.route.lazy || i) { c = !0, s = u >= 0 ? s.slice(0, u + 1) : [s[0]]; break } } } return s.reduceRight(((e, r, o) => { let a, d = !1, h = null, f = null; var p; n && (a = l && r.route.id ? l[r.route.id] : void 0, h = r.route.errorElement || ae, c && (u < 0 && 0 === o ? (p = "route-fallback", !1 || me[p] || (me[p] = !0), d = !0, f = null) : u === o && (d = !0, f = r.route.hydrateFallbackElement || null))); let m = t.concat(s.slice(0, o + 1)), g = () => { let t; return t = a ? h : d ? f : r.route.Component ? i.createElement(r.route.Component, null) : r.route.element ? r.route.element : e, i.createElement(le, { match: r, routeContext: { outlet: e, matches: m, isDataRoute: null != n }, children: t }) }; return n && (r.route.ErrorBoundary || r.route.errorElement || 0 === o) ? i.createElement(se, { location: n.location, revalidation: n.revalidation, component: h, error: a, children: g(), routeContext: { outlet: null, matches: m, isDataRoute: !0 } }) : g() }), null) } var ue = function (e) { return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e }(ue || {}), de = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(de || {}); function he(e) { let t = i.useContext(q); return t || d(!1), t } function fe(e) { let t = i.useContext(Z); return t || d(!1), t } function pe(e) { let t = function () { let e = i.useContext(J); return e || d(!1), e }(), n = t.matches[t.matches.length - 1]; return n.route.id || d(!1), n.route.id } const me = {}; o.startTransition; function ge(e) { d(!1) } function ve(e) { let { basename: t = "/", children: n = null, location: o, navigationType: a = r.Pop, navigator: s, static: l = !1, future: c } = e; $() && d(!1); let u = t.replace(/^\/*/, "/"), h = i.useMemo((() => ({ basename: u, navigator: s, static: l, future: Q({ v7_relativeSplatPath: !1 }, c) })), [u, c, s, l]); "string" === typeof o && (o = g(o)); let { pathname: f = "/", search: p = "", hash: m = "", state: v = null, key: y = "default" } = o, b = i.useMemo((() => { let e = R(f, u); return null == e ? null : { location: { pathname: e, search: p, hash: m, state: v, key: y }, navigationType: a } }), [u, f, p, m, v, y, a]); return null == b ? null : i.createElement(K.Provider, { value: h }, i.createElement(G.Provider, { children: n, value: b })) } function ye(e) { let { children: t, location: n } = e; return function (e, t) { return ie(e, t) }(be(t), n) } new Promise((() => { })); i.Component; function be(e, t) { void 0 === t && (t = []); let n = []; return i.Children.forEach(e, ((e, r) => { if (!i.isValidElement(e)) return; let o = [...t, r]; if (e.type === i.Fragment) return void n.push.apply(n, be(e.props.children, o)); e.type !== ge && d(!1), e.props.index && e.props.children && d(!1); let a = { id: e.props.id || o.join("-"), caseSensitive: e.props.caseSensitive, element: e.props.element, Component: e.props.Component, index: e.props.index, path: e.props.path, loader: e.props.loader, action: e.props.action, errorElement: e.props.errorElement, ErrorBoundary: e.props.ErrorBoundary, hasErrorBoundary: null != e.props.ErrorBoundary || null != e.props.errorElement, shouldRevalidate: e.props.shouldRevalidate, handle: e.props.handle, lazy: e.props.lazy }; e.props.children && (a.children = be(e.props.children, o)), n.push(a) })), n } function xe() { return xe = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, xe.apply(this, arguments) } function we(e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i } new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]); const ke = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"]; try { window.__reactRouterVersion = "6" } catch (tc) { } new Map; const Se = o.startTransition; l.flushSync, o.useId; function Ae(e) { let { basename: t, children: n, future: r, window: o } = e, a = i.useRef(); var s; null == a.current && (a.current = (void 0 === (s = { window: o, v5Compat: !0 }) && (s = {}), v((function (e, t) { let { pathname: n, search: r, hash: i } = e.location; return p("", { pathname: n, search: r, hash: i }, t.state && t.state.usr || null, t.state && t.state.key || "default") }), (function (e, t) { return "string" === typeof t ? t : m(t) }), null, s))); let l = a.current, [c, u] = i.useState({ action: l.action, location: l.location }), { v7_startTransition: d } = r || {}, h = i.useCallback((e => { d && Se ? Se((() => u(e))) : u(e) }), [u, d]); return i.useLayoutEffect((() => l.listen(h)), [l, h]), i.createElement(ve, { basename: t, children: n, location: c.location, navigationType: c.action, navigator: l, future: r }) } const Ee = "undefined" !== typeof window && "undefined" !== typeof window.document && "undefined" !== typeof window.document.createElement, Ce = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Pe = i.forwardRef((function (e, t) { let n, { onClick: r, relative: o, reloadDocument: a, replace: s, state: l, target: c, to: u, preventScrollReset: h, unstable_viewTransition: f } = e, p = we(e, ke), { basename: g } = i.useContext(K), v = !1; if ("string" === typeof u && Ce.test(u) && (n = u, Ee)) try { let e = new URL(window.location.href), t = u.startsWith("//") ? new URL(e.protocol + u) : new URL(u), n = R(t.pathname, g); t.origin === e.origin && null != n ? u = n + t.search + t.hash : v = !0 } catch (tc) { } let y = function (e, t) { let { relative: n } = void 0 === t ? {} : t; $() || d(!1); let { basename: r, navigator: o } = i.useContext(K), { hash: a, pathname: s, search: l } = re(e, { relative: n }), c = s; return "/" !== r && (c = "/" === s ? r : F([r, s])), o.createHref({ pathname: c, search: l, hash: a }) }(u, { relative: o }), b = function (e, t) { let { target: n, replace: r, state: o, preventScrollReset: a, relative: s, unstable_viewTransition: l } = void 0 === t ? {} : t, c = ne(), u = ee(), d = re(e, { relative: s }); return i.useCallback((t => { if (function (e, t) { return 0 === e.button && (!t || "_self" === t) && !function (e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) }(e) }(t, n)) { t.preventDefault(); let n = void 0 !== r ? r : m(u) === m(d); c(e, { replace: n, state: o, preventScrollReset: a, relative: s, unstable_viewTransition: l }) } }), [u, c, d, r, o, n, e, a, s, l]) }(u, { replace: s, state: l, target: c, preventScrollReset: h, relative: o, unstable_viewTransition: f }); return i.createElement("a", xe({}, p, { href: n || y, onClick: v || a ? r : function (e) { r && r(e), e.defaultPrevented || b(e) }, ref: t, target: c })) })); var je, Ne; (function (e) { e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState" })(je || (je = {})), function (e) { e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration" }(Ne || (Ne = {})); var Me = n(579); const Te = (0, i.createContext)({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }), Ie = (0, i.createContext)({}), Le = (0, i.createContext)(null), Re = "undefined" !== typeof document, De = Re ? i.useLayoutEffect : i.useEffect, ze = (0, i.createContext)({ strict: !1 }), Oe = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), Be = "data-" + Oe("framerAppearId"), Fe = !1, Ve = !1; const Ue = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]; function We(e, t) { let n = !1, r = !0; const i = { delta: 0, timestamp: 0, isProcessing: !1 }, o = () => n = !0, a = Ue.reduce(((e, t) => (e[t] = function (e) { let t = new Set, n = new Set, r = !1, i = !1; const o = new WeakSet; let a = { delta: 0, timestamp: 0, isProcessing: !1 }; function s(t) { o.has(t) && (l.schedule(t), e()), t(a) } const l = { schedule: function (e) { const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2] && r ? t : n; return arguments.length > 1 && void 0 !== arguments[1] && arguments[1] && o.add(e), i.has(e) || i.add(e), e }, cancel: e => { n.delete(e), o.delete(e) }, process: e => { a = e, r ? i = !0 : (r = !0, [t, n] = [n, t], n.clear(), t.forEach(s), r = !1, i && (i = !1, l.process(e))) } }; return l }(o), e)), {}), { read: s, resolveKeyframes: l, update: c, preRender: u, render: d, postRender: h } = a, f = () => { const o = Ve ? i.timestamp : performance.now(); n = !1, i.delta = r ? 1e3 / 60 : Math.max(Math.min(o - i.timestamp, 40), 1), i.timestamp = o, i.isProcessing = !0, s.process(i), l.process(i), c.process(i), u.process(i), d.process(i), h.process(i), i.isProcessing = !1, n && t && (r = !1, e(f)) }, p = Ue.reduce(((t, o) => { const s = a[o]; return t[o] = function (t) { let o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; return n || (n = !0, r = !0, i.isProcessing || e(f)), s.schedule(t, o, a) }, t }), {}); return { schedule: p, cancel: e => { for (let t = 0; t < Ue.length; t++)a[Ue[t]].cancel(e) }, state: i, steps: a } } const { schedule: He, cancel: Ye } = We(queueMicrotask, !1); function Xe(e) { return e && "object" === typeof e && Object.prototype.hasOwnProperty.call(e, "current") } const Qe = (0, i.createContext)({}); let qe = !1; function Ze(e, t, n, r, o) { const { visualElement: a } = (0, i.useContext)(Ie), s = (0, i.useContext)(ze), l = (0, i.useContext)(Le), c = (0, i.useContext)(Te).reducedMotion, u = (0, i.useRef)(); r = r || s.renderer, !u.current && r && (u.current = r(e, { visualState: t, parent: a, props: n, presenceContext: l, blockInitialAnimation: !!l && !1 === l.initial, reducedMotionConfig: c })); const d = u.current, h = (0, i.useContext)(Qe); !d || d.projection || !o || "html" !== d.type && "svg" !== d.type || function (e, t, n, r) { const { layoutId: i, layout: o, drag: a, dragConstraints: s, layoutScroll: l, layoutRoot: c } = t; e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : Ge(e.parent)), e.projection.setOptions({ layoutId: i, layout: o, alwaysMeasureLayout: Boolean(a) || s && Xe(s), visualElement: e, scheduleRender: () => e.scheduleRender(), animationType: "string" === typeof o ? o : "both", initialPromotionConfig: r, layoutScroll: l, layoutRoot: c }) }(u.current, n, o, h), (0, i.useInsertionEffect)((() => { d && d.update(n, l) })); const f = (0, i.useRef)(Boolean(n[Be] && !window.HandoffComplete)); return De((() => { d && (d.updateFeatures(), He.render(d.render), f.current && d.animationState && d.animationState.animateChanges()) })), (0, i.useEffect)((() => { d && (!f.current && d.animationState && d.animationState.animateChanges(), f.current && (f.current = !1, qe || (qe = !0, queueMicrotask(Ke)))) })), d } function Ke() { window.HandoffComplete = !0 } function Ge(e) { if (e) return !1 !== e.options.allowProjection ? e.projection : Ge(e.parent) } function Je(e, t, n) { return (0, i.useCallback)((r => { r && e.mount && e.mount(r), t && (r ? t.mount(r) : t.unmount()), n && ("function" === typeof n ? n(r) : Xe(n) && (n.current = r)) }), [t]) } function _e(e) { return "string" === typeof e || Array.isArray(e) } function $e(e) { return null !== e && "object" === typeof e && "function" === typeof e.start } const et = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], tt = ["initial", ...et]; function nt(e) { return $e(e.animate) || tt.some((t => _e(e[t]))) } function rt(e) { return Boolean(nt(e) || e.variants) } function it(e) { const { initial: t, animate: n } = function (e, t) { if (nt(e)) { const { initial: t, animate: n } = e; return { initial: !1 === t || _e(t) ? t : void 0, animate: _e(n) ? n : void 0 } } return !1 !== e.inherit ? t : {} }(e, (0, i.useContext)(Ie)); return (0, i.useMemo)((() => ({ initial: t, animate: n })), [ot(t), ot(n)]) } function ot(e) { return Array.isArray(e) ? e.join(" ") : e } const at = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, st = {}; for (const n in at) st[n] = { isEnabled: e => at[n].some((t => !!e[t])) }; const lt = (0, i.createContext)({}), ct = Symbol.for("motionComponentSymbol"); function ut(e) { let { preloadedFeatures: t, createVisualElement: n, useRender: r, useVisualState: o, Component: a } = e; t && function (e) { for (const t in e) st[t] = { ...st[t], ...e[t] } }(t); const s = (0, i.forwardRef)((function (e, t) { let s; const l = { ...(0, i.useContext)(Te), ...e, layoutId: dt(e) }, { isStatic: c } = l, u = it(e), d = o(e, c); if (!c && Re) { !function () { (0, i.useContext)(ze).strict; 0 }(); const e = function (e) { const { drag: t, layout: n } = st; if (!t && !n) return {}; const r = { ...t, ...n }; return { MeasureLayout: (null === t || void 0 === t ? void 0 : t.isEnabled(e)) || (null === n || void 0 === n ? void 0 : n.isEnabled(e)) ? r.MeasureLayout : void 0, ProjectionNode: r.ProjectionNode } }(l); s = e.MeasureLayout, u.visualElement = Ze(a, d, l, n, e.ProjectionNode) } return (0, Me.jsxs)(Ie.Provider, { value: u, children: [s && u.visualElement ? (0, Me.jsx)(s, { visualElement: u.visualElement, ...l }) : null, r(a, e, Je(d, u.visualElement, t), d, c, u.visualElement)] }) })); return s[ct] = a, s } function dt(e) { let { layoutId: t } = e; const n = (0, i.useContext)(lt).id; return n && void 0 !== t ? n + "-" + t : t } function ht(e) { function t(t) { return ut(e(t, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {})) } if ("undefined" === typeof Proxy) return t; const n = new Map; return new Proxy(t, { get: (e, r) => (n.has(r) || n.set(r, t(r)), n.get(r)) }) } const ft = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function pt(e) { return "string" === typeof e && !e.includes("-") && !!(ft.indexOf(e) > -1 || /[A-Z]/u.test(e)) } const mt = {}; const gt = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], vt = new Set(gt); function yt(e, t) { let { layout: n, layoutId: r } = t; return vt.has(e) || e.startsWith("origin") || (n || void 0 !== r) && (!!mt[e] || "opacity" === e) } const bt = e => Boolean(e && e.getVelocity), xt = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, wt = gt.length; const kt = e => t => "string" === typeof t && t.startsWith(e), St = kt("--"), At = kt("var(--"), Et = e => !!At(e) && Ct.test(e.split("/*")[0].trim()), Ct = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, Pt = (e, t) => t && "number" === typeof e ? t.transform(e) : e, jt = (e, t, n) => n > t ? t : n < e ? e : n, Nt = { test: e => "number" === typeof e, parse: parseFloat, transform: e => e }, Mt = { ...Nt, transform: e => jt(0, 1, e) }, Tt = { ...Nt, default: 1 }, It = e => Math.round(1e5 * e) / 1e5, Lt = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu, Rt = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu, Dt = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu; function zt(e) { return "string" === typeof e } const Ot = e => ({ test: t => zt(t) && t.endsWith(e) && 1 === t.split(" ").length, parse: parseFloat, transform: t => "".concat(t).concat(e) }), Bt = Ot("deg"), Ft = Ot("%"), Vt = Ot("px"), Ut = Ot("vh"), Wt = Ot("vw"), Ht = { ...Ft, parse: e => Ft.parse(e) / 100, transform: e => Ft.transform(100 * e) }, Yt = { ...Nt, transform: Math.round }, Xt = { borderWidth: Vt, borderTopWidth: Vt, borderRightWidth: Vt, borderBottomWidth: Vt, borderLeftWidth: Vt, borderRadius: Vt, radius: Vt, borderTopLeftRadius: Vt, borderTopRightRadius: Vt, borderBottomRightRadius: Vt, borderBottomLeftRadius: Vt, width: Vt, maxWidth: Vt, height: Vt, maxHeight: Vt, size: Vt, top: Vt, right: Vt, bottom: Vt, left: Vt, padding: Vt, paddingTop: Vt, paddingRight: Vt, paddingBottom: Vt, paddingLeft: Vt, margin: Vt, marginTop: Vt, marginRight: Vt, marginBottom: Vt, marginLeft: Vt, rotate: Bt, rotateX: Bt, rotateY: Bt, rotateZ: Bt, scale: Tt, scaleX: Tt, scaleY: Tt, scaleZ: Tt, skew: Bt, skewX: Bt, skewY: Bt, distance: Vt, translateX: Vt, translateY: Vt, translateZ: Vt, x: Vt, y: Vt, z: Vt, perspective: Vt, transformPerspective: Vt, opacity: Mt, originX: Ht, originY: Ht, originZ: Vt, zIndex: Yt, backgroundPositionX: Vt, backgroundPositionY: Vt, fillOpacity: Mt, strokeOpacity: Mt, numOctaves: Yt }; function Qt(e, t, n) { const { style: r, vars: i, transform: o, transformOrigin: a } = e; let s = !1, l = !1, c = !0; for (const u in t) { const e = t[u]; if (St(u)) { i[u] = e; continue } const n = Xt[u], d = Pt(e, n); if (vt.has(u)) { if (s = !0, o[u] = d, !c) continue; e !== (n.default || 0) && (c = !1) } else u.startsWith("origin") ? (l = !0, a[u] = d) : r[u] = d } if (t.transform || (s || n ? r.transform = function (e, t, n) { let r = ""; for (let i = 0; i < wt; i++) { const t = gt[i]; if (void 0 !== e[t]) { const n = xt[t] || t; r += "".concat(n, "(").concat(e[t], ") ") } } return r = r.trim(), n ? r = n(e, t ? "" : r) : t && (r = "none"), r }(e.transform, c, n) : r.transform && (r.transform = "none")), l) { const { originX: e = "50%", originY: t = "50%", originZ: n = 0 } = a; r.transformOrigin = "".concat(e, " ").concat(t, " ").concat(n) } } const qt = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function Zt(e, t, n) { for (const r in t) bt(t[r]) || yt(r, n) || (e[r] = t[r]) } function Kt(e, t) { const n = {}; return Zt(n, e.style || {}, e), Object.assign(n, function (e, t) { let { transformTemplate: n } = e; return (0, i.useMemo)((() => { const e = qt(); return Qt(e, t, n), Object.assign({}, e.vars, e.style) }), [t]) }(e, t)), n } function Gt(e, t) { const n = {}, r = Kt(e, t); return e.drag && !1 !== e.dragListener && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = !0 === e.drag ? "none" : "pan-".concat("x" === e.drag ? "y" : "x")), void 0 === e.tabIndex && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n } const Jt = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function _t(e) { return e.startsWith("while") || e.startsWith("drag") && "draggable" !== e || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || Jt.has(e) } let $t = e => !_t(e); try { (en = require("@emotion/is-prop-valid").default) && ($t = e => e.startsWith("on") ? !_t(e) : en(e)) } catch (Dv) { } var en; function tn(e, t, n) { return "string" === typeof e ? e : Vt.transform(t + n * e) } const nn = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, rn = { offset: "strokeDashoffset", array: "strokeDasharray" }; function on(e, t, n, r) { let { attrX: i, attrY: o, attrScale: a, originX: s, originY: l, pathLength: c, pathSpacing: u = 1, pathOffset: d = 0, ...h } = t; if (Qt(e, h, r), n) return void (e.style.viewBox && (e.attrs.viewBox = e.style.viewBox)); e.attrs = e.style, e.style = {}; const { attrs: f, style: p, dimensions: m } = e; f.transform && (m && (p.transform = f.transform), delete f.transform), m && (void 0 !== s || void 0 !== l || p.transform) && (p.transformOrigin = function (e, t, n) { const r = tn(t, e.x, e.width), i = tn(n, e.y, e.height); return "".concat(r, " ").concat(i) }(m, void 0 !== s ? s : .5, void 0 !== l ? l : .5)), void 0 !== i && (f.x = i), void 0 !== o && (f.y = o), void 0 !== a && (f.scale = a), void 0 !== c && function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, i = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]; e.pathLength = 1; const o = i ? nn : rn; e[o.offset] = Vt.transform(-r); const a = Vt.transform(t), s = Vt.transform(n); e[o.array] = "".concat(a, " ").concat(s) }(f, c, u, d, !1) } const an = () => ({ ...qt(), attrs: {} }), sn = e => "string" === typeof e && "svg" === e.toLowerCase(); function ln(e, t, n, r) { const o = (0, i.useMemo)((() => { const n = an(); return on(n, t, sn(r), e.transformTemplate), { ...n.attrs, style: { ...n.style } } }), [t]); if (e.style) { const t = {}; Zt(t, e.style, e), o.style = { ...t, ...o.style } } return o } function cn() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; return (t, n, r, o, a) => { let { latestValues: s } = o; const l = (pt(t) ? ln : Gt)(n, s, a, t), c = function (e, t, n) { const r = {}; for (const i in e) "values" === i && "object" === typeof e.values || ($t(i) || !0 === n && _t(i) || !t && !_t(i) || e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]); return r }(n, "string" === typeof t, e), u = t !== i.Fragment ? { ...c, ...l, ref: r } : {}, { children: d } = n, h = (0, i.useMemo)((() => bt(d) ? d.get() : d), [d]); return (0, i.createElement)(t, { ...u, children: h }) } } function un(e, t, n, r) { let { style: i, vars: o } = t; Object.assign(e.style, i, r && r.getProjectionStyles(n)); for (const a in o) e.style.setProperty(a, o[a]) } const dn = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function hn(e, t, n, r) { un(e, t, void 0, r); for (const i in t.attrs) e.setAttribute(dn.has(i) ? i : Oe(i), t.attrs[i]) } function fn(e, t, n) { var r; const { style: i } = e, o = {}; for (const a in i) (bt(i[a]) || t.style && bt(t.style[a]) || yt(a, e) || void 0 !== (null === (r = null === n || void 0 === n ? void 0 : n.getValue(a)) || void 0 === r ? void 0 : r.liveStyle)) && (o[a] = i[a]); return n && i && "string" === typeof i.willChange && (n.applyWillChange = !1), o } function pn(e, t, n) { const r = fn(e, t, n); for (const i in e) if (bt(e[i]) || bt(t[i])) { r[-1 !== gt.indexOf(i) ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i] = e[i] } return r } function mn(e) { const t = [{}, {}]; return null === e || void 0 === e || e.values.forEach(((e, n) => { t[0][n] = e.get(), t[1][n] = e.getVelocity() })), t } function gn(e, t, n, r) { if ("function" === typeof t) { const [i, o] = mn(r); t = t(void 0 !== n ? n : e.custom, i, o) } if ("string" === typeof t && (t = e.variants && e.variants[t]), "function" === typeof t) { const [i, o] = mn(r); t = t(void 0 !== n ? n : e.custom, i, o) } return t } function vn(e) { const t = (0, i.useRef)(null); return null === t.current && (t.current = e()), t.current } const yn = e => Array.isArray(e), bn = e => Boolean(e && "object" === typeof e && e.mix && e.toValue), xn = e => yn(e) ? e[e.length - 1] || 0 : e; function wn(e) { const t = bt(e) ? e.get() : e; return bn(t) ? t.toValue() : t } const kn = new Set(["opacity", "clipPath", "filter", "transform"]); function Sn(e) { return vt.has(e) ? "transform" : kn.has(e) ? Oe(e) : void 0 } function An(e, t) { -1 === e.indexOf(t) && e.push(t) } function En(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } const Cn = e => (t, n) => { const r = (0, i.useContext)(Ie), o = (0, i.useContext)(Le), a = () => function (e, t, n, r, i) { let { applyWillChange: o = !1, scrapeMotionValuesFromProps: a, createRenderState: s, onMount: l } = e; const c = { latestValues: Nn(t, n, r, !i && o, a), renderState: s() }; return l && (c.mount = e => l(t, e, c)), c }(e, t, r, o, n); return n ? a() : vn(a) }; function Pn(e, t) { const n = Sn(t); n && An(e, n) } function jn(e, t, n) { const r = Array.isArray(t) ? t : [t]; for (let i = 0; i < r.length; i++) { const t = gn(e, r[i]); if (t) { const { transitionEnd: e, transition: r, ...i } = t; n(i, e) } } } function Nn(e, t, n, r, i) { var o; const a = {}, s = [], l = r && void 0 === (null === (o = e.style) || void 0 === o ? void 0 : o.willChange), c = i(e, {}); for (const g in c) a[g] = wn(c[g]); let { initial: u, animate: d } = e; const h = nt(e), f = rt(e); t && f && !h && !1 !== e.inherit && (void 0 === u && (u = t.initial), void 0 === d && (d = t.animate)); let p = !!n && !1 === n.initial; p = p || !1 === u; const m = p ? d : u; return m && "boolean" !== typeof m && !$e(m) && jn(e, m, ((e, t) => { for (const n in e) { let t = e[n]; if (Array.isArray(t)) { t = t[p ? t.length - 1 : 0] } null !== t && (a[n] = t) } for (const n in t) a[n] = t[n] })), l && (d && !1 !== u && !$e(d) && jn(e, d, (e => { for (const t in e) Pn(s, t) })), s.length && (a.willChange = s.join(","))), a } const Mn = e => e, { schedule: Tn, cancel: In, state: Ln, steps: Rn } = We("undefined" !== typeof requestAnimationFrame ? requestAnimationFrame : Mn, !0), Dn = { useVisualState: Cn({ scrapeMotionValuesFromProps: pn, createRenderState: an, onMount: (e, t, n) => { let { renderState: r, latestValues: i } = n; Tn.read((() => { try { r.dimensions = "function" === typeof t.getBBox ? t.getBBox() : t.getBoundingClientRect() } catch (tc) { r.dimensions = { x: 0, y: 0, width: 0, height: 0 } } })), Tn.render((() => { on(r, i, sn(t.tagName), e.transformTemplate), hn(t, r) })) } }) }, zn = { useVisualState: Cn({ applyWillChange: !0, scrapeMotionValuesFromProps: fn, createRenderState: qt }) }; function On(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : { passive: !0 }; return e.addEventListener(t, n, r), () => e.removeEventListener(t, n) } const Bn = e => "mouse" === e.pointerType ? "number" !== typeof e.button || e.button <= 0 : !1 !== e.isPrimary; function Fn(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "page"; return { point: { x: e["".concat(t, "X")], y: e["".concat(t, "Y")] } } } const Vn = e => t => Bn(t) && e(t, Fn(t)); function Un(e, t, n, r) { return On(e, t, Vn(n), r) } const Wn = (e, t) => n => t(e(n)), Hn = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return t.reduce(Wn) }; function Yn(e) { let t = null; return () => { const n = () => { t = null }; return null === t && (t = e, n) } } const Xn = Yn("dragHorizontal"), Qn = Yn("dragVertical"); function qn(e) { let t = !1; if ("y" === e) t = Qn(); else if ("x" === e) t = Xn(); else { const e = Xn(), n = Qn(); e && n ? t = () => { e(), n() } : (e && e(), n && n()) } return t } function Zn() { const e = qn(!0); return !e || (e(), !1) } class Kn { constructor(e) { this.isMounted = !1, this.node = e } update() { } } function Gn(e, t) { const n = t ? "pointerenter" : "pointerleave", r = t ? "onHoverStart" : "onHoverEnd"; return Un(e.current, n, ((n, i) => { if ("touch" === n.pointerType || Zn()) return; const o = e.getProps(); e.animationState && o.whileHover && e.animationState.setActive("whileHover", t); const a = o[r]; a && Tn.postRender((() => a(n, i))) }), { passive: !e.getProps()[r] }) } const Jn = (e, t) => !!t && (e === t || Jn(e, t.parentElement)); function _n(e, t) { if (!t) return; const n = new PointerEvent("pointer" + e); t(n, Fn(n)) } const $n = new WeakMap, er = new WeakMap, tr = e => { const t = $n.get(e.target); t && t(e) }, nr = e => { e.forEach(tr) }; function rr(e, t, n) { const r = function (e) { let { root: t, ...n } = e; const r = t || document; er.has(r) || er.set(r, {}); const i = er.get(r), o = JSON.stringify(n); return i[o] || (i[o] = new IntersectionObserver(nr, { root: t, ...n })), i[o] }(t); return $n.set(e, n), r.observe(e), () => { $n.delete(e), r.unobserve(e) } } const ir = { some: 0, all: 1 }; const or = { inView: { Feature: class extends Kn { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: e = {} } = this.node.getProps(), { root: t, margin: n, amount: r = "some", once: i } = e, o = { root: t ? t.current : void 0, rootMargin: n, threshold: "number" === typeof r ? r : ir[r] }; return rr(this.node.current, o, (e => { const { isIntersecting: t } = e; if (this.isInView === t) return; if (this.isInView = t, i && !t && this.hasEnteredView) return; t && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", t); const { onViewportEnter: n, onViewportLeave: r } = this.node.getProps(), o = t ? n : r; o && o(e) })) } mount() { this.startObserver() } update() { if ("undefined" === typeof IntersectionObserver) return; const { props: e, prevProps: t } = this.node, n = ["amount", "margin", "root"].some(function (e) { let { viewport: t = {} } = e, { viewport: n = {} } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return e => t[e] !== n[e] }(e, t)); n && this.startObserver() } unmount() { } } }, tap: { Feature: class extends Kn { constructor() { super(...arguments), this.removeStartListeners = Mn, this.removeEndListeners = Mn, this.removeAccessibleListeners = Mn, this.startPointerPress = (e, t) => { if (this.isPressing) return; this.removeEndListeners(); const n = this.node.getProps(), r = Un(window, "pointerup", ((e, t) => { if (!this.checkPressEnd()) return; const { onTap: n, onTapCancel: r, globalTapTarget: i } = this.node.getProps(), o = i || Jn(this.node.current, e.target) ? n : r; o && Tn.update((() => o(e, t))) }), { passive: !(n.onTap || n.onPointerUp) }), i = Un(window, "pointercancel", ((e, t) => this.cancelPress(e, t)), { passive: !(n.onTapCancel || n.onPointerCancel) }); this.removeEndListeners = Hn(r, i), this.startPress(e, t) }, this.startAccessiblePress = () => { const e = On(this.node.current, "keydown", (e => { if ("Enter" !== e.key || this.isPressing) return; this.removeEndListeners(), this.removeEndListeners = On(this.node.current, "keyup", (e => { "Enter" === e.key && this.checkPressEnd() && _n("up", ((e, t) => { const { onTap: n } = this.node.getProps(); n && Tn.postRender((() => n(e, t))) })) })), _n("down", ((e, t) => { this.startPress(e, t) })) })), t = On(this.node.current, "blur", (() => { this.isPressing && _n("cancel", ((e, t) => this.cancelPress(e, t))) })); this.removeAccessibleListeners = Hn(e, t) } } startPress(e, t) { this.isPressing = !0; const { onTapStart: n, whileTap: r } = this.node.getProps(); r && this.node.animationState && this.node.animationState.setActive("whileTap", !0), n && Tn.postRender((() => n(e, t))) } checkPressEnd() { this.removeEndListeners(), this.isPressing = !1; return this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !Zn() } cancelPress(e, t) { if (!this.checkPressEnd()) return; const { onTapCancel: n } = this.node.getProps(); n && Tn.postRender((() => n(e, t))) } mount() { const e = this.node.getProps(), t = Un(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(e.onTapStart || e.onPointerStart) }), n = On(this.node.current, "focus", this.startAccessiblePress); this.removeStartListeners = Hn(t, n) } unmount() { this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners() } } }, focus: { Feature: class extends Kn { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let e = !1; try { e = this.node.current.matches(":focus-visible") } catch (tc) { e = !0 } e && this.node.animationState && (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { this.isActive && this.node.animationState && (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = Hn(On(this.node.current, "focus", (() => this.onFocus())), On(this.node.current, "blur", (() => this.onBlur()))) } unmount() { } } }, hover: { Feature: class extends Kn { mount() { this.unmount = Hn(Gn(this.node, !0), Gn(this.node, !1)) } unmount() { } } } }; function ar(e, t) { if (!Array.isArray(t)) return !1; const n = t.length; if (n !== e.length) return !1; for (let r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } function sr(e, t, n) { const r = e.getProps(); return gn(r, t, void 0 !== n ? n : r.custom, e) } const lr = e => 1e3 * e, cr = e => e / 1e3, ur = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, dr = { type: "keyframes", duration: .8 }, hr = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, fr = (e, t) => { let { keyframes: n } = t; return n.length > 2 ? dr : vt.has(e) ? e.startsWith("scale") ? { type: "spring", stiffness: 550, damping: 0 === n[1] ? 2 * Math.sqrt(550) : 30, restSpeed: 10 } : ur : hr }; function pr(e, t) { return e[t] || e.default || e } const mr = !1, gr = e => null !== e; function vr(e, t, n) { let { repeat: r, repeatType: i = "loop" } = t; const o = e.filter(gr), a = r && "loop" !== i && r % 2 === 1 ? 0 : o.length - 1; return a && void 0 !== n ? n : o[a] } let yr; function br() { yr = void 0 } const xr = { now: () => (void 0 === yr && xr.set(Ln.isProcessing || Ve ? Ln.timestamp : performance.now()), yr), set: e => { yr = e, queueMicrotask(br) } }, wr = e => /^0[^.\s]+$/u.test(e); let kr = Mn, Sr = Mn; const Ar = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), Er = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function Cr(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1; Sr(n <= 4, 'Max CSS variable fallback depth detected in property "'.concat(e, '". This may indicate a circular fallback dependency.')); const [r, i] = function (e) { const t = Er.exec(e); if (!t) return [,]; const [, n, r, i] = t; return ["--".concat(null !== n && void 0 !== n ? n : r), i] }(e); if (!r) return; const o = window.getComputedStyle(t).getPropertyValue(r); if (o) { const e = o.trim(); return Ar(e) ? parseFloat(e) : e } return Et(i) ? Cr(i, t, n + 1) : i } const Pr = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]), jr = e => e === Nt || e === Vt, Nr = (e, t) => parseFloat(e.split(", ")[t]), Mr = (e, t) => (n, r) => { let { transform: i } = r; if ("none" === i || !i) return 0; const o = i.match(/^matrix3d\((.+)\)$/u); if (o) return Nr(o[1], t); { const t = i.match(/^matrix\((.+)\)$/u); return t ? Nr(t[1], e) : 0 } }, Tr = new Set(["x", "y", "z"]), Ir = gt.filter((e => !Tr.has(e))); const Lr = { width: (e, t) => { let { x: n } = e, { paddingLeft: r = "0", paddingRight: i = "0" } = t; return n.max - n.min - parseFloat(r) - parseFloat(i) }, height: (e, t) => { let { y: n } = e, { paddingTop: r = "0", paddingBottom: i = "0" } = t; return n.max - n.min - parseFloat(r) - parseFloat(i) }, top: (e, t) => { let { top: n } = t; return parseFloat(n) }, left: (e, t) => { let { left: n } = t; return parseFloat(n) }, bottom: (e, t) => { let { y: n } = e, { top: r } = t; return parseFloat(r) + (n.max - n.min) }, right: (e, t) => { let { x: n } = e, { left: r } = t; return parseFloat(r) + (n.max - n.min) }, x: Mr(4, 13), y: Mr(5, 14) }; Lr.translateX = Lr.x, Lr.translateY = Lr.y; const Rr = e => t => t.test(e), Dr = [Nt, Vt, Ft, Bt, Wt, Ut, { test: e => "auto" === e, parse: e => e }], zr = e => Dr.find(Rr(e)), Or = new Set; let Br = !1, Fr = !1; function Vr() { if (Fr) { const e = Array.from(Or).filter((e => e.needsMeasurement)), t = new Set(e.map((e => e.element))), n = new Map; t.forEach((e => { const t = function (e) { const t = []; return Ir.forEach((n => { const r = e.getValue(n); void 0 !== r && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) })), t }(e); t.length && (n.set(e, t), e.render()) })), e.forEach((e => e.measureInitialState())), t.forEach((e => { e.render(); const t = n.get(e); t && t.forEach((t => { let [n, r] = t; var i; null === (i = e.getValue(n)) || void 0 === i || i.set(r) })) })), e.forEach((e => e.measureEndState())), e.forEach((e => { void 0 !== e.suspendedScrollY && window.scrollTo(0, e.suspendedScrollY) })) } Fr = !1, Br = !1, Or.forEach((e => e.complete())), Or.clear() } function Ur() { Or.forEach((e => { e.readKeyframes(), e.needsMeasurement && (Fr = !0) })) } class Wr { constructor(e, t, n, r, i) { let o = arguments.length > 5 && void 0 !== arguments[5] && arguments[5]; this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = t, this.name = n, this.motionValue = r, this.element = i, this.isAsync = o } scheduleResolve() { this.isScheduled = !0, this.isAsync ? (Or.add(this), Br || (Br = !0, Tn.read(Ur), Tn.resolveKeyframes(Vr))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: e, name: t, element: n, motionValue: r } = this; for (let i = 0; i < e.length; i++)if (null === e[i]) if (0 === i) { const i = null === r || void 0 === r ? void 0 : r.get(), o = e[e.length - 1]; if (void 0 !== i) e[0] = i; else if (n && t) { const r = n.readValue(t, o); void 0 !== r && null !== r && (e[0] = r) } void 0 === e[0] && (e[0] = o), r && void 0 === i && r.set(e[0]) } else e[i] = e[i - 1] } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete() { this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Or.delete(this) } cancel() { this.isComplete || (this.isScheduled = !1, Or.delete(this)) } resume() { this.isComplete || this.scheduleResolve() } } const Hr = (e, t) => n => Boolean(zt(n) && Dt.test(n) && n.startsWith(e) || t && !function (e) { return null == e }(n) && Object.prototype.hasOwnProperty.call(n, t)), Yr = (e, t, n) => r => { if (!zt(r)) return r; const [i, o, a, s] = r.match(Lt); return { [e]: parseFloat(i), [t]: parseFloat(o), [n]: parseFloat(a), alpha: void 0 !== s ? parseFloat(s) : 1 } }, Xr = { ...Nt, transform: e => Math.round((e => jt(0, 255, e))(e)) }, Qr = { test: Hr("rgb", "red"), parse: Yr("red", "green", "blue"), transform: e => { let { red: t, green: n, blue: r, alpha: i = 1 } = e; return "rgba(" + Xr.transform(t) + ", " + Xr.transform(n) + ", " + Xr.transform(r) + ", " + It(Mt.transform(i)) + ")" } }; const qr = { test: Hr("#"), parse: function (e) { let t = "", n = "", r = "", i = ""; return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), { red: parseInt(t, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: i ? parseInt(i, 16) / 255 : 1 } }, transform: Qr.transform }, Zr = { test: Hr("hsl", "hue"), parse: Yr("hue", "saturation", "lightness"), transform: e => { let { hue: t, saturation: n, lightness: r, alpha: i = 1 } = e; return "hsla(" + Math.round(t) + ", " + Ft.transform(It(n)) + ", " + Ft.transform(It(r)) + ", " + It(Mt.transform(i)) + ")" } }, Kr = { test: e => Qr.test(e) || qr.test(e) || Zr.test(e), parse: e => Qr.test(e) ? Qr.parse(e) : Zr.test(e) ? Zr.parse(e) : qr.parse(e), transform: e => zt(e) ? e : e.hasOwnProperty("red") ? Qr.transform(e) : Zr.transform(e) }; const Gr = "number", Jr = "color", _r = "var", $r = "var(", ei = "${}", ti = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function ni(e) { const t = e.toString(), n = [], r = { color: [], number: [], var: [] }, i = []; let o = 0; const a = t.replace(ti, (e => (Kr.test(e) ? (r.color.push(o), i.push(Jr), n.push(Kr.parse(e))) : e.startsWith($r) ? (r.var.push(o), i.push(_r), n.push(e)) : (r.number.push(o), i.push(Gr), n.push(parseFloat(e))), ++o, ei))).split(ei); return { values: n, split: a, indexes: r, types: i } } function ri(e) { return ni(e).values } function ii(e) { const { split: t, types: n } = ni(e), r = t.length; return e => { let i = ""; for (let o = 0; o < r; o++)if (i += t[o], void 0 !== e[o]) { const t = n[o]; i += t === Gr ? It(e[o]) : t === Jr ? Kr.transform(e[o]) : e[o] } return i } } const oi = e => "number" === typeof e ? 0 : e; const ai = { test: function (e) { var t, n; return isNaN(e) && zt(e) && ((null === (t = e.match(Lt)) || void 0 === t ? void 0 : t.length) || 0) + ((null === (n = e.match(Rt)) || void 0 === n ? void 0 : n.length) || 0) > 0 }, parse: ri, createTransformer: ii, getAnimatableNone: function (e) { const t = ri(e); return ii(e)(t.map(oi)) } }, si = new Set(["brightness", "contrast", "saturate", "opacity"]); function li(e) { const [t, n] = e.slice(0, -1).split("("); if ("drop-shadow" === t) return e; const [r] = n.match(Lt) || []; if (!r) return e; const i = n.replace(r, ""); let o = si.has(t) ? 1 : 0; return r !== n && (o *= 100), t + "(" + o + i + ")" } const ci = /\b([a-z-]*)\(.*?\)/gu, ui = { ...ai, getAnimatableNone: e => { const t = e.match(ci); return t ? t.map(li).join(" ") : e } }, di = { ...Xt, color: Kr, backgroundColor: Kr, outlineColor: Kr, fill: Kr, stroke: Kr, borderColor: Kr, borderTopColor: Kr, borderRightColor: Kr, borderBottomColor: Kr, borderLeftColor: Kr, filter: ui, WebkitFilter: ui }, hi = e => di[e]; function fi(e, t) { let n = hi(e); return n !== ui && (n = ai), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0 } const pi = new Set(["auto", "none", "0"]); class mi extends Wr { constructor(e, t, n, r) { super(e, t, n, r, null === r || void 0 === r ? void 0 : r.owner, !0) } readKeyframes() { const { unresolvedKeyframes: e, element: t, name: n } = this; if (!t.current) return; super.readKeyframes(); for (let s = 0; s < e.length; s++) { let n = e[s]; if ("string" === typeof n && (n = n.trim(), Et(n))) { const r = Cr(n, t.current); void 0 !== r && (e[s] = r), s === e.length - 1 && (this.finalKeyframe = n) } } if (this.resolveNoneKeyframes(), !Pr.has(n) || 2 !== e.length) return; const [r, i] = e, o = zr(r), a = zr(i); if (o !== a) if (jr(o) && jr(a)) for (let s = 0; s < e.length; s++) { const t = e[s]; "string" === typeof t && (e[s] = parseFloat(t)) } else this.needsMeasurement = !0 } resolveNoneKeyframes() { const { unresolvedKeyframes: e, name: t } = this, n = []; for (let i = 0; i < e.length; i++)("number" === typeof (r = e[i]) ? 0 === r : null === r || "none" === r || "0" === r || wr(r)) && n.push(i); var r; n.length && function (e, t, n) { let r, i = 0; for (; i < e.length && !r;) { const t = e[i]; "string" === typeof t && !pi.has(t) && ni(t).values.length && (r = e[i]), i++ } if (r && n) for (const o of t) e[o] = fi(n, r) }(e, n, t) } measureInitialState() { const { element: e, unresolvedKeyframes: t, name: n } = this; if (!e.current) return; "height" === n && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Lr[n](e.measureViewportBox(), window.getComputedStyle(e.current)), t[0] = this.measuredOrigin; const r = t[t.length - 1]; void 0 !== r && e.getValue(n, r).jump(r, !1) } measureEndState() { var e; const { element: t, name: n, unresolvedKeyframes: r } = this; if (!t.current) return; const i = t.getValue(n); i && i.jump(this.measuredOrigin, !1); const o = r.length - 1, a = r[o]; r[o] = Lr[n](t.measureViewportBox(), window.getComputedStyle(t.current)), null !== a && void 0 === this.finalKeyframe && (this.finalKeyframe = a), (null === (e = this.removedTransforms) || void 0 === e ? void 0 : e.length) && this.removedTransforms.forEach((e => { let [n, r] = e; t.getValue(n).set(r) })), this.resolveNoneKeyframes() } } function gi(e) { let t; return () => (void 0 === t && (t = e()), t) } const vi = (e, t) => "zIndex" !== t && (!("number" !== typeof e && !Array.isArray(e)) || !("string" !== typeof e || !ai.test(e) && "0" !== e || e.startsWith("url("))); class yi { constructor(e) { let { autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: o = 0, repeatType: a = "loop", ...s } = e; this.isStopped = !1, this.hasAttemptedResolve = !1, this.options = { autoplay: t, delay: n, type: r, repeat: i, repeatDelay: o, repeatType: a, ...s }, this.updateFinishedPromise() } get resolved() { return this._resolved || this.hasAttemptedResolve || (Ur(), Vr()), this._resolved } onKeyframesResolved(e, t) { this.hasAttemptedResolve = !0; const { name: n, type: r, velocity: i, delay: o, onComplete: a, onUpdate: s, isGenerator: l } = this.options; if (!l && !function (e, t, n, r) { const i = e[0]; if (null === i) return !1; if ("display" === t || "visibility" === t) return !0; const o = e[e.length - 1], a = vi(i, t), s = vi(o, t); return kr(a === s, "You are trying to animate ".concat(t, ' from "').concat(i, '" to "').concat(o, '". ').concat(i, " is not an animatable value - to enable this animation set ").concat(i, " to a value animatable to ").concat(o, " via the `style` property.")), !(!a || !s) && (function (e) { const t = e[0]; if (1 === e.length) return !0; for (let n = 0; n < e.length; n++)if (e[n] !== t) return !0 }(e) || "spring" === n && r) }(e, n, r, i)) { if (mr || !o) return null === s || void 0 === s || s(vr(e, this.options, t)), null === a || void 0 === a || a(), void this.resolveFinishedPromise(); this.options.duration = 0 } const c = this.initPlayback(e, t); !1 !== c && (this._resolved = { keyframes: e, finalKeyframe: t, ...c }, this.onPostResolved()) } onPostResolved() { } then(e, t) { return this.currentFinishedPromise.then(e, t) } updateFinishedPromise() { this.currentFinishedPromise = new Promise((e => { this.resolveFinishedPromise = e })) } } function bi(e, t) { return t ? e * (1e3 / t) : 0 } const xi = 5; function wi(e, t, n) { const r = Math.max(t - xi, 0); return bi(n - e(r), t - r) } const ki = .001, Si = .01, Ai = 10, Ei = .05, Ci = 1; function Pi(e) { let t, n, { duration: r = 800, bounce: i = .25, velocity: o = 0, mass: a = 1 } = e; kr(r <= lr(Ai), "Spring duration must be 10 seconds or less"); let s = 1 - i; s = jt(Ei, Ci, s), r = jt(Si, Ai, cr(r)), s < 1 ? (t = e => { const t = e * s, n = t * r, i = t - o, a = Ni(e, s), l = Math.exp(-n); return ki - i / a * l }, n = e => { const n = e * s * r, i = n * o + o, a = Math.pow(s, 2) * Math.pow(e, 2) * r, l = Math.exp(-n), c = Ni(Math.pow(e, 2), s); return (-t(e) + ki > 0 ? -1 : 1) * ((i - a) * l) / c }) : (t = e => Math.exp(-e * r) * ((e - o) * r + 1) - ki, n = e => Math.exp(-e * r) * (r * r * (o - e))); const l = function (e, t, n) { let r = n; for (let i = 1; i < ji; i++)r -= e(r) / t(r); return r }(t, n, 5 / r); if (r = lr(r), isNaN(l)) return { stiffness: 100, damping: 10, duration: r }; { const e = Math.pow(l, 2) * a; return { stiffness: e, damping: 2 * s * Math.sqrt(a * e), duration: r } } } const ji = 12; function Ni(e, t) { return e * Math.sqrt(1 - t * t) } const Mi = ["duration", "bounce"], Ti = ["stiffness", "damping", "mass"]; function Ii(e, t) { return t.some((t => void 0 !== e[t])) } function Li(e) { let { keyframes: t, restDelta: n, restSpeed: r, ...i } = e; const o = t[0], a = t[t.length - 1], s = { done: !1, value: o }, { stiffness: l, damping: c, mass: u, duration: d, velocity: h, isResolvedFromDuration: f } = function (e) { let t = { velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: !1, ...e }; if (!Ii(e, Ti) && Ii(e, Mi)) { const n = Pi(e); t = { ...t, ...n, mass: 1 }, t.isResolvedFromDuration = !0 } return t }({ ...i, velocity: -cr(i.velocity || 0) }), p = h || 0, m = c / (2 * Math.sqrt(l * u)), g = a - o, v = cr(Math.sqrt(l / u)), y = Math.abs(g) < 5; let b; if (r || (r = y ? .01 : 2), n || (n = y ? .005 : .5), m < 1) { const e = Ni(v, m); b = t => { const n = Math.exp(-m * v * t); return a - n * ((p + m * v * g) / e * Math.sin(e * t) + g * Math.cos(e * t)) } } else if (1 === m) b = e => a - Math.exp(-v * e) * (g + (p + v * g) * e); else { const e = v * Math.sqrt(m * m - 1); b = t => { const n = Math.exp(-m * v * t), r = Math.min(e * t, 300); return a - n * ((p + m * v * g) * Math.sinh(r) + e * g * Math.cosh(r)) / e } } return { calculatedDuration: f && d || null, next: e => { const t = b(e); if (f) s.done = e >= d; else { let i = p; 0 !== e && (i = m < 1 ? wi(b, e, t) : 0); const o = Math.abs(i) <= r, l = Math.abs(a - t) <= n; s.done = o && l } return s.value = s.done ? a : t, s } } } function Ri(e) { let { keyframes: t, velocity: n = 0, power: r = .8, timeConstant: i = 325, bounceDamping: o = 10, bounceStiffness: a = 500, modifyTarget: s, min: l, max: c, restDelta: u = .5, restSpeed: d } = e; const h = t[0], f = { done: !1, value: h }, p = e => void 0 === l ? c : void 0 === c || Math.abs(l - e) < Math.abs(c - e) ? l : c; let m = r * n; const g = h + m, v = void 0 === s ? g : s(g); v !== g && (m = v - h); const y = e => -m * Math.exp(-e / i), b = e => v + y(e), x = e => { const t = y(e), n = b(e); f.done = Math.abs(t) <= u, f.value = f.done ? v : n }; let w, k; const S = e => { var t; (t = f.value, void 0 !== l && t < l || void 0 !== c && t > c) && (w = e, k = Li({ keyframes: [f.value, p(f.value)], velocity: wi(b, e, f.value), damping: o, stiffness: a, restDelta: u, restSpeed: d })) }; return S(0), { calculatedDuration: null, next: e => { let t = !1; return k || void 0 !== w || (t = !0, x(e), S(e)), void 0 !== w && e >= w ? k.next(e - w) : (!t && x(e), f) } } } const Di = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, zi = 1e-7, Oi = 12; function Bi(e, t, n, r) { if (e === t && n === r) return Mn; const i = t => function (e, t, n, r, i) { let o, a, s = 0; do { a = t + (n - t) / 2, o = Di(a, r, i) - e, o > 0 ? n = a : t = a } while (Math.abs(o) > zi && ++s < Oi); return a }(t, 0, 1, e, n); return e => 0 === e || 1 === e ? e : Di(i(e), t, r) } const Fi = Bi(.42, 0, 1, 1), Vi = Bi(0, 0, .58, 1), Ui = Bi(.42, 0, .58, 1), Wi = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, Hi = e => t => 1 - e(1 - t), Yi = e => 1 - Math.sin(Math.acos(e)), Xi = Hi(Yi), Qi = Wi(Yi), qi = Bi(.33, 1.53, .69, .99), Zi = Hi(qi), Ki = Wi(Zi), Gi = { linear: Mn, easeIn: Fi, easeInOut: Ui, easeOut: Vi, circIn: Yi, circInOut: Qi, circOut: Xi, backIn: Zi, backInOut: Ki, backOut: qi, anticipate: e => (e *= 2) < 1 ? .5 * Zi(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))) }, Ji = e => { if (Array.isArray(e)) { Sr(4 === e.length, "Cubic bezier arrays must contain four numerical values."); const [t, n, r, i] = e; return Bi(t, n, r, i) } return "string" === typeof e ? (Sr(void 0 !== Gi[e], "Invalid easing type '".concat(e, "'")), Gi[e]) : e }, _i = (e, t, n) => { const r = t - e; return 0 === r ? 1 : (n - e) / r }, $i = (e, t, n) => e + (t - e) * n; function eo(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function to(e, t) { return n => n > 0 ? t : e } const no = (e, t, n) => { const r = e * e, i = n * (t * t - r) + r; return i < 0 ? 0 : Math.sqrt(i) }, ro = [qr, Qr, Zr]; function io(e) { const t = (n = e, ro.find((e => e.test(n)))); var n; if (kr(Boolean(t), "'".concat(e, "' is not an animatable color. Use the equivalent color code instead.")), !Boolean(t)) return !1; let r = t.parse(e); return t === Zr && (r = function (e) { let { hue: t, saturation: n, lightness: r, alpha: i } = e; t /= 360, n /= 100, r /= 100; let o = 0, a = 0, s = 0; if (n) { const e = r < .5 ? r * (1 + n) : r + n - r * n, i = 2 * r - e; o = eo(i, e, t + 1 / 3), a = eo(i, e, t), s = eo(i, e, t - 1 / 3) } else o = a = s = r; return { red: Math.round(255 * o), green: Math.round(255 * a), blue: Math.round(255 * s), alpha: i } }(r)), r } const oo = (e, t) => { const n = io(e), r = io(t); if (!n || !r) return to(e, t); const i = { ...n }; return e => (i.red = no(n.red, r.red, e), i.green = no(n.green, r.green, e), i.blue = no(n.blue, r.blue, e), i.alpha = $i(n.alpha, r.alpha, e), Qr.transform(i)) }, ao = new Set(["none", "hidden"]); function so(e, t) { return n => $i(e, t, n) } function lo(e) { return "number" === typeof e ? so : "string" === typeof e ? Et(e) ? to : Kr.test(e) ? oo : ho : Array.isArray(e) ? co : "object" === typeof e ? Kr.test(e) ? oo : uo : to } function co(e, t) { const n = [...e], r = n.length, i = e.map(((e, n) => lo(e)(e, t[n]))); return e => { for (let t = 0; t < r; t++)n[t] = i[t](e); return n } } function uo(e, t) { const n = { ...e, ...t }, r = {}; for (const i in n) void 0 !== e[i] && void 0 !== t[i] && (r[i] = lo(e[i])(e[i], t[i])); return e => { for (const t in r) n[t] = r[t](e); return n } } const ho = (e, t) => { const n = ai.createTransformer(t), r = ni(e), i = ni(t); return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? ao.has(e) && !i.values.length || ao.has(t) && !r.values.length ? function (e, t) { return ao.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e }(e, t) : Hn(co(function (e, t) { var n; const r = [], i = { color: 0, var: 0, number: 0 }; for (let o = 0; o < t.values.length; o++) { const a = t.types[o], s = e.indexes[a][i[a]], l = null !== (n = e.values[s]) && void 0 !== n ? n : 0; r[o] = l, i[a]++ } return r }(r, i), i.values), n) : (kr(!0, "Complex values '".concat(e, "' and '").concat(t, "' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.")), to(e, t)) }; function fo(e, t, n) { if ("number" === typeof e && "number" === typeof t && "number" === typeof n) return $i(e, t, n); return lo(e)(e, t) } function po(e, t) { let { clamp: n = !0, ease: r, mixer: i } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const o = e.length; if (Sr(o === t.length, "Both input and output ranges must be the same length"), 1 === o) return () => t[0]; if (2 === o && e[0] === e[1]) return () => t[1]; e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse()); const a = function (e, t, n) { const r = [], i = n || fo, o = e.length - 1; for (let a = 0; a < o; a++) { let n = i(e[a], e[a + 1]); if (t) { const e = Array.isArray(t) ? t[a] || Mn : t; n = Hn(e, n) } r.push(n) } return r }(t, r, i), s = a.length, l = t => { let n = 0; if (s > 1) for (; n < e.length - 2 && !(t < e[n + 1]); n++); const r = _i(e[n], e[n + 1], t); return a[n](r) }; return n ? t => l(jt(e[0], e[o - 1], t)) : l } function mo(e) { const t = [0]; return function (e, t) { const n = e[e.length - 1]; for (let r = 1; r <= t; r++) { const i = _i(0, t, r); e.push($i(n, 1, i)) } }(t, e.length - 1), t } function go(e) { let { duration: t = 300, keyframes: n, times: r, ease: i = "easeInOut" } = e; const o = (e => Array.isArray(e) && "number" !== typeof e[0])(i) ? i.map(Ji) : Ji(i), a = { done: !1, value: n[0] }, s = function (e, t) { return e.map((e => e * t)) }(r && r.length === n.length ? r : mo(n), t), l = po(s, n, { ease: Array.isArray(o) ? o : (c = n, u = o, c.map((() => u || Ui)).splice(0, c.length - 1)) }); var c, u; return { calculatedDuration: t, next: e => (a.value = l(e), a.done = e >= t, a) } } const vo = e => { const t = t => { let { timestamp: n } = t; return e(n) }; return { start: () => Tn.update(t, !0), stop: () => In(t), now: () => Ln.isProcessing ? Ln.timestamp : xr.now() } }, yo = { decay: Ri, inertia: Ri, tween: go, keyframes: go, spring: Li }, bo = e => e / 100; class xo extends yi { constructor(e) { let { KeyframeResolver: t = Wr, ...n } = e; super(n), this.holdTime = null, this.startTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.state = "idle", this.stop = () => { if (this.resolver.cancel(), this.isStopped = !0, "idle" === this.state) return; this.teardown(); const { onStop: e } = this.options; e && e() }; const { name: r, motionValue: i, keyframes: o } = this.options, a = (e, t) => this.onKeyframesResolved(e, t); r && i && i.owner ? this.resolver = i.owner.resolveKeyframes(o, a, r, i) : this.resolver = new t(o, a, r, i), this.resolver.scheduleResolve() } initPlayback(e) { const { type: t = "keyframes", repeat: n = 0, repeatDelay: r = 0, repeatType: i, velocity: o = 0 } = this.options, a = yo[t] || go; let s, l; a !== go && "number" !== typeof e[0] && (s = Hn(bo, fo(e[0], e[1])), e = [0, 100]); const c = a({ ...this.options, keyframes: e }); "mirror" === i && (l = a({ ...this.options, keyframes: [...e].reverse(), velocity: -o })), null === c.calculatedDuration && (c.calculatedDuration = function (e) { let t = 0, n = e.next(t); for (; !n.done && t < 2e4;)t += 50, n = e.next(t); return t >= 2e4 ? 1 / 0 : t }(c)); const { calculatedDuration: u } = c, d = u + r; return { generator: c, mirroredGenerator: l, mapPercentToKeyframes: s, calculatedDuration: u, resolvedDuration: d, totalDuration: d * (n + 1) - r } } onPostResolved() { const { autoplay: e = !0 } = this.options; this.play(), "paused" !== this.pendingPlayState && e ? this.state = this.pendingPlayState : this.pause() } tick(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const { resolved: n } = this; if (!n) { const { keyframes: e } = this.options; return { done: !0, value: e[e.length - 1] } } const { finalKeyframe: r, generator: i, mirroredGenerator: o, mapPercentToKeyframes: a, keyframes: s, calculatedDuration: l, totalDuration: c, resolvedDuration: u } = n; if (null === this.startTime) return i.next(0); const { delay: d, repeat: h, repeatType: f, repeatDelay: p, onUpdate: m } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - c / this.speed, this.startTime)), t ? this.currentTime = e : null !== this.holdTime ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed; const g = this.currentTime - d * (this.speed >= 0 ? 1 : -1), v = this.speed >= 0 ? g < 0 : g > c; this.currentTime = Math.max(g, 0), "finished" === this.state && null === this.holdTime && (this.currentTime = c); let y = this.currentTime, b = i; if (h) { const e = Math.min(this.currentTime, c) / u; let t = Math.floor(e), n = e % 1; !n && e >= 1 && (n = 1), 1 === n && t--, t = Math.min(t, h + 1); Boolean(t % 2) && ("reverse" === f ? (n = 1 - n, p && (n -= p / u)) : "mirror" === f && (b = o)), y = jt(0, 1, n) * u } const x = v ? { done: !1, value: s[0] } : b.next(y); a && (x.value = a(x.value)); let { done: w } = x; v || null === l || (w = this.speed >= 0 ? this.currentTime >= c : this.currentTime <= 0); const k = null === this.holdTime && ("finished" === this.state || "running" === this.state && w); return k && void 0 !== r && (x.value = vr(s, this.options, r)), m && m(x.value), k && this.finish(), x } get duration() { const { resolved: e } = this; return e ? cr(e.calculatedDuration) : 0 } get time() { return cr(this.currentTime) } set time(e) { e = lr(e), this.currentTime = e, null !== this.holdTime || 0 === this.speed ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed) } get speed() { return this.playbackSpeed } set speed(e) { const t = this.playbackSpeed !== e; this.playbackSpeed = e, t && (this.time = cr(this.currentTime)) } play() { if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) return void (this.pendingPlayState = "running"); if (this.isStopped) return; const { driver: e = vo, onPlay: t } = this.options; this.driver || (this.driver = e((e => this.tick(e)))), t && t(); const n = this.driver.now(); null !== this.holdTime ? this.startTime = n - this.holdTime : this.startTime && "finished" !== this.state || (this.startTime = n), "finished" === this.state && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start() } pause() { var e; this._resolved ? (this.state = "paused", this.holdTime = null !== (e = this.currentTime) && void 0 !== e ? e : 0) : this.pendingPlayState = "paused" } complete() { "running" !== this.state && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null } finish() { this.teardown(), this.state = "finished"; const { onComplete: e } = this.options; e && e() } cancel() { null !== this.cancelTime && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise() } teardown() { this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel() } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(e) { return this.startTime = 0, this.tick(e, !0) } } const wo = e => Array.isArray(e) && "number" === typeof e[0]; function ko(e) { return Boolean(!e || "string" === typeof e && e in Ao || wo(e) || Array.isArray(e) && e.every(ko)) } const So = e => { let [t, n, r, i] = e; return "cubic-bezier(".concat(t, ", ").concat(n, ", ").concat(r, ", ").concat(i, ")") }, Ao = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: So([0, .65, .55, 1]), circOut: So([.55, 0, 1, .45]), backIn: So([.31, .01, .66, -.59]), backOut: So([.33, 1.53, .69, .99]) }; function Eo(e) { return Co(e) || Ao.easeOut } function Co(e) { return e ? wo(e) ? So(e) : Array.isArray(e) ? e.map(Eo) : Ao[e] : void 0 } const Po = gi((() => Object.hasOwnProperty.call(Element.prototype, "animate"))); class jo extends yi { constructor(e) { super(e); const { name: t, motionValue: n, keyframes: r } = this.options; this.resolver = new mi(r, ((e, t) => this.onKeyframesResolved(e, t)), t, n), this.resolver.scheduleResolve() } initPlayback(e, t) { var n; let { duration: r = 300, times: i, ease: o, type: a, motionValue: s, name: l } = this.options; if (!(null === (n = s.owner) || void 0 === n ? void 0 : n.current)) return !1; if ("spring" === (c = this.options).type || !ko(c.ease)) { const { onComplete: t, onUpdate: n, motionValue: s, ...l } = this.options, c = function (e, t) { const n = new xo({ ...t, keyframes: e, repeat: 0, delay: 0, isGenerator: !0 }); let r = { done: !1, value: e[0] }; const i = []; let o = 0; for (; !r.done && o < 2e4;)r = n.sample(o), i.push(r.value), o += 10; return { times: void 0, keyframes: i, duration: o - 10, ease: "linear" } }(e, l); 1 === (e = c.keyframes).length && (e[1] = e[0]), r = c.duration, i = c.times, o = c.ease, a = "keyframes" } var c; const u = function (e, t, n) { let { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: a = "loop", ease: s, times: l } = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const c = { [t]: n }; l && (c.offset = l); const u = Co(s); return Array.isArray(u) && (c.easing = u), e.animate(c, { delay: r, duration: i, easing: Array.isArray(u) ? "linear" : u, fill: "both", iterations: o + 1, direction: "reverse" === a ? "alternate" : "normal" }) }(s.owner.current, l, e, { ...this.options, duration: r, times: i, ease: o }); return u.startTime = xr.now(), this.pendingTimeline ? (u.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : u.onfinish = () => { const { onComplete: n } = this.options; s.set(vr(e, this.options, t)), n && n(), this.cancel(), this.resolveFinishedPromise() }, { animation: u, duration: r, times: i, type: a, ease: o, keyframes: e } } get duration() { const { resolved: e } = this; if (!e) return 0; const { duration: t } = e; return cr(t) } get time() { const { resolved: e } = this; if (!e) return 0; const { animation: t } = e; return cr(t.currentTime || 0) } set time(e) { const { resolved: t } = this; if (!t) return; const { animation: n } = t; n.currentTime = lr(e) } get speed() { const { resolved: e } = this; if (!e) return 1; const { animation: t } = e; return t.playbackRate } set speed(e) { const { resolved: t } = this; if (!t) return; const { animation: n } = t; n.playbackRate = e } get state() { const { resolved: e } = this; if (!e) return "idle"; const { animation: t } = e; return t.playState } attachTimeline(e) { if (this._resolved) { const { resolved: t } = this; if (!t) return Mn; const { animation: n } = t; n.timeline = e, n.onfinish = null } else this.pendingTimeline = e; return Mn } play() { if (this.isStopped) return; const { resolved: e } = this; if (!e) return; const { animation: t } = e; "finished" === t.playState && this.updateFinishedPromise(), t.play() } pause() { const { resolved: e } = this; if (!e) return; const { animation: t } = e; t.pause() } stop() { if (this.resolver.cancel(), this.isStopped = !0, "idle" === this.state) return; const { resolved: e } = this; if (!e) return; const { animation: t, keyframes: n, duration: r, type: i, ease: o, times: a } = e; if ("idle" === t.playState || "finished" === t.playState) return; if (this.time) { const { motionValue: e, onUpdate: t, onComplete: s, ...l } = this.options, c = new xo({ ...l, keyframes: n, duration: r, type: i, ease: o, times: a, isGenerator: !0 }), u = lr(this.time); e.setWithVelocity(c.sample(u - 10).value, c.sample(u).value, 10) } const { onStop: s } = this.options; s && s(), this.cancel() } complete() { const { resolved: e } = this; e && e.animation.finish() } cancel() { const { resolved: e } = this; e && e.animation.cancel() } static supports(e) { const { motionValue: t, name: n, repeatDelay: r, repeatType: i, damping: o, type: a } = e; return Po() && n && kn.has(n) && t && t.owner && t.owner.current instanceof HTMLElement && !t.owner.getProps().onUpdate && !r && "mirror" !== i && 0 !== o && "inertia" !== a } } const No = gi((() => void 0 !== window.ScrollTimeline)); class Mo { constructor(e) { this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean) } then(e, t) { return Promise.all(this.animations).then(e).catch(t) } getAll(e) { return this.animations[0][e] } setAll(e, t) { for (let n = 0; n < this.animations.length; n++)this.animations[n][e] = t } attachTimeline(e) { const t = this.animations.map((t => { if (!No() || !t.attachTimeline) return t.pause(), function (e, t) { let n; const r = () => { const { currentTime: r } = t, i = (null === r ? 0 : r.value) / 100; n !== i && e(i), n = i }; return Tn.update(r, !0), () => In(r) }((e => { t.time = t.duration * e }), e); t.attachTimeline(e) })); return () => { t.forEach(((e, t) => { e && e(), this.animations[t].stop() })) } } get time() { return this.getAll("time") } set time(e) { this.setAll("time", e) } get speed() { return this.getAll("speed") } set speed(e) { this.setAll("speed", e) } get duration() { let e = 0; for (let t = 0; t < this.animations.length; t++)e = Math.max(e, this.animations[t].duration); return e } runAll(e) { this.animations.forEach((t => t[e]())) } play() { this.runAll("play") } pause() { this.runAll("pause") } cancel() { this.runAll("cancel") } complete() { this.runAll("complete") } } const To = function (e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, i = arguments.length > 4 ? arguments[4] : void 0, o = arguments.length > 5 ? arguments[5] : void 0, a = arguments.length > 6 ? arguments[6] : void 0; return s => { const l = pr(r, e) || {}, c = l.delay || r.delay || 0; let { elapsed: u = 0 } = r; u -= lr(c); let d = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: t.getVelocity(), ...l, delay: -u, onUpdate: e => { t.set(e), l.onUpdate && l.onUpdate(e) }, onComplete: () => { s(), l.onComplete && l.onComplete(), a && a() }, onStop: a, name: e, motionValue: t, element: o ? void 0 : i }; (function (e) { let { when: t, delay: n, delayChildren: r, staggerChildren: i, staggerDirection: o, repeat: a, repeatType: s, repeatDelay: l, from: c, elapsed: u, ...d } = e; return !!Object.keys(d).length })(l) || (d = { ...d, ...fr(e, d) }), d.duration && (d.duration = lr(d.duration)), d.repeatDelay && (d.repeatDelay = lr(d.repeatDelay)), void 0 !== d.from && (d.keyframes[0] = d.from); let h = !1; if ((!1 === d.type || 0 === d.duration && !d.repeatDelay) && (d.duration = 0, 0 === d.delay && (h = !0)), (mr || Fe) && (h = !0, d.duration = 0, d.delay = 0), h && !o && void 0 !== t.get()) { const e = vr(d.keyframes, l); if (void 0 !== e) return Tn.update((() => { d.onUpdate(e), d.onComplete() })), new Mo([]) } return !o && jo.supports(d) ? new jo(d) : new xo(d) } }; class Io { constructor() { this.subscriptions = [] } add(e) { return An(this.subscriptions, e), () => En(this.subscriptions, e) } notify(e, t, n) { const r = this.subscriptions.length; if (r) if (1 === r) this.subscriptions[0](e, t, n); else for (let i = 0; i < r; i++) { const r = this.subscriptions[i]; r && r(e, t, n) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const Lo = { current: void 0 }; class Ro { constructor(e) { var t = this; let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.version = "11.3.8", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = function (e) { let n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; const r = xr.now(); t.updatedAt !== r && t.setPrevFrameValue(), t.prev = t.current, t.setCurrent(e), t.current !== t.prev && t.events.change && t.events.change.notify(t.current), n && t.events.renderRequest && t.events.renderRequest.notify(t.current) }, this.hasAnimated = !1, this.setCurrent(e), this.owner = n.owner } setCurrent(e) { var t; this.current = e, this.updatedAt = xr.now(), null === this.canTrackVelocity && void 0 !== e && (this.canTrackVelocity = (t = this.current, !isNaN(parseFloat(t)))) } setPrevFrameValue() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.current; this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt } onChange(e) { return this.on("change", e) } on(e, t) { this.events[e] || (this.events[e] = new Io); const n = this.events[e].add(t); return "change" === e ? () => { n(), Tn.read((() => { this.events.change.getSize() || this.stop() })) } : n } clearListeners() { for (const e in this.events) this.events[e].clear() } attach(e, t) { this.passiveEffect = e, this.stopPassiveEffect = t } set(e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; t && this.passiveEffect ? this.passiveEffect(e, this.updateAndNotify) : this.updateAndNotify(e, t) } setWithVelocity(e, t, n) { this.set(t), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - n } jump(e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]; this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, t && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } get() { return Lo.current && Lo.current.push(this), this.current } getPrevious() { return this.prev } getVelocity() { const e = xr.now(); if (!this.canTrackVelocity || void 0 === this.prevFrameValue || e - this.updatedAt > 30) return 0; const t = Math.min(this.updatedAt - this.prevUpdatedAt, 30); return bi(parseFloat(this.current) - parseFloat(this.prevFrameValue), t) } start(e) { return this.stop(), new Promise((t => { this.hasAnimated = !0, this.animation = e(t), this.events.animationStart && this.events.animationStart.notify() })).then((() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() })) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function Do(e, t) { return new Ro(e, t) } function zo(e, t, n) { e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Do(n)) } function Oo(e) { return e.getProps()[Be] } class Bo extends Ro { constructor() { super(...arguments), this.output = [], this.counts = new Map } add(e) { const t = Sn(e); if (!t) return; const n = this.counts.get(t) || 0; this.counts.set(t, n + 1), 0 === n && (this.output.push(t), this.update()); let r = !1; return () => { if (r) return; r = !0; const e = this.counts.get(t) - 1; this.counts.set(t, e), 0 === e && (En(this.output, t), this.update()) } } update() { this.set(this.output.length ? this.output.join(", ") : "auto") } } function Fo(e, t) { var n; if (!e.applyWillChange) return; let r = e.getValue("willChange"); return r || (null === (n = e.props.style) || void 0 === n ? void 0 : n.willChange) || (r = new Bo("auto"), e.addValue("willChange", r)), i = r, Boolean(bt(i) && i.add) ? r.add(t) : void 0; var i } function Vo(e, t) { let { protectedKeys: n, needsAnimating: r } = e; const i = n.hasOwnProperty(t) && !0 !== r[t]; return r[t] = !1, i } function Uo(e, t) { let { delay: n = 0, transitionOverride: r, type: i } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; var o; let { transition: a = e.getDefaultTransition(), transitionEnd: s, ...l } = t; r && (a = r); const c = [], u = i && e.animationState && e.animationState.getState()[i]; for (const d in l) { const t = e.getValue(d, null !== (o = e.latestValues[d]) && void 0 !== o ? o : null), r = l[d]; if (void 0 === r || u && Vo(u, d)) continue; const i = { delay: n, elapsed: 0, ...pr(a || {}, d) }; let s = !1; if (window.HandoffAppearAnimations) { const n = Oo(e); if (n) { const e = window.HandoffAppearAnimations(n, d, t, Tn); null !== e && (i.elapsed = e, s = !0) } } t.start(To(d, t, r, e.shouldReduceMotion && vt.has(d) ? { type: !1 } : i, e, s, Fo(e, d))); const h = t.animation; h && c.push(h) } return s && Promise.all(c).then((() => { Tn.update((() => { s && function (e, t) { const n = sr(e, t); let { transitionEnd: r = {}, transition: i = {}, ...o } = n || {}; o = { ...o, ...r }; for (const a in o) zo(e, a, xn(o[a])) }(e, s) })) })), c } function Wo(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; var r; const i = sr(e, t, "exit" === n.type ? null === (r = e.presenceContext) || void 0 === r ? void 0 : r.custom : void 0); let { transition: o = e.getDefaultTransition() || {} } = i || {}; n.transitionOverride && (o = n.transitionOverride); const a = i ? () => Promise.all(Uo(e, i, n)) : () => Promise.resolve(), s = e.variantChildren && e.variantChildren.size ? function () { let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; const { delayChildren: i = 0, staggerChildren: a, staggerDirection: s } = o; return function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, o = arguments.length > 5 ? arguments[5] : void 0; const a = [], s = (e.variantChildren.size - 1) * r, l = 1 === i ? function () { return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0) * r } : function () { return s - (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0) * r }; return Array.from(e.variantChildren).sort(Ho).forEach(((e, r) => { e.notify("AnimationStart", t), a.push(Wo(e, t, { ...o, delay: n + l(r) }).then((() => e.notify("AnimationComplete", t)))) })), Promise.all(a) }(e, t, i + r, a, s, n) } : () => Promise.resolve(), { when: l } = o; if (l) { const [e, t] = "beforeChildren" === l ? [a, s] : [s, a]; return e().then((() => t())) } return Promise.all([a(), s(n.delay)]) } function Ho(e, t) { return e.sortNodePosition(t) } const Yo = [...et].reverse(), Xo = et.length; function Qo(e) { return t => Promise.all(t.map((t => { let { animation: n, options: r } = t; return function (e, t) { let n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (e.notify("AnimationStart", t), Array.isArray(t)) { const i = t.map((t => Wo(e, t, r))); n = Promise.all(i) } else if ("string" === typeof t) n = Wo(e, t, r); else { const i = "function" === typeof t ? sr(e, t, r.custom) : t; n = Promise.all(Uo(e, i, r)) } return n.then((() => { Tn.postRender((() => { e.notify("AnimationComplete", t) })) })) }(e, n, r) }))) } function qo(e, t) { return "string" === typeof t ? t !== e : !!Array.isArray(t) && !ar(t, e) } function Zo() { return { isActive: arguments.length > 0 && void 0 !== arguments[0] && arguments[0], protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function Ko() { return { animate: Zo(!0), whileInView: Zo(), whileHover: Zo(), whileTap: Zo(), whileDrag: Zo(), whileFocus: Zo(), exit: Zo() } } let Go = 0; const Jo = { animation: { Feature: class extends Kn { constructor(e) { super(e), e.animationState || (e.animationState = function (e) { let t = Qo(e), n = Ko(), r = !0; const i = t => (n, r) => { var i; const o = sr(e, r, "exit" === t ? null === (i = e.presenceContext) || void 0 === i ? void 0 : i.custom : void 0); if (o) { const { transition: e, transitionEnd: t, ...r } = o; n = { ...n, ...r, ...t } } return n }; function o(o) { const a = e.getProps(), s = e.getVariantContext(!0) || {}, l = [], c = new Set; let u = {}, d = 1 / 0; for (let t = 0; t < Xo; t++) { const h = Yo[t], f = n[h], p = void 0 !== a[h] ? a[h] : s[h], m = _e(p), g = h === o ? f.isActive : null; !1 === g && (d = t); let v = p === s[h] && p !== a[h] && m; if (v && r && e.manuallyAnimateOnMount && (v = !1), f.protectedKeys = { ...u }, !f.isActive && null === g || !p && !f.prevProp || $e(p) || "boolean" === typeof p) continue; let y = qo(f.prevProp, p) || h === o && f.isActive && !v && m || t > d && m, b = !1; const x = Array.isArray(p) ? p : [p]; let w = x.reduce(i(h), {}); !1 === g && (w = {}); const { prevResolvedValues: k = {} } = f, S = { ...k, ...w }, A = t => { y = !0, c.has(t) && (b = !0, c.delete(t)), f.needsAnimating[t] = !0; const n = e.getValue(t); n && (n.liveStyle = !1) }; for (const e in S) { const t = w[e], n = k[e]; if (u.hasOwnProperty(e)) continue; let r = !1; r = yn(t) && yn(n) ? !ar(t, n) : t !== n, r ? void 0 !== t && null !== t ? A(e) : c.add(e) : void 0 !== t && c.has(e) ? A(e) : f.protectedKeys[e] = !0 } f.prevProp = p, f.prevResolvedValues = w, f.isActive && (u = { ...u, ...w }), r && e.blockInitialAnimation && (y = !1), !y || v && !b || l.push(...x.map((e => ({ animation: e, options: { type: h } })))) } if (c.size) { const t = {}; c.forEach((n => { const r = e.getBaseTarget(n), i = e.getValue(n); i && (i.liveStyle = !0), t[n] = null !== r && void 0 !== r ? r : null })), l.push({ animation: t }) } let h = Boolean(l.length); return !r || !1 !== a.initial && a.initial !== a.animate || e.manuallyAnimateOnMount || (h = !1), r = !1, h ? t(l) : Promise.resolve() } return { animateChanges: o, setActive: function (t, r) { var i; if (n[t].isActive === r) return Promise.resolve(); null === (i = e.variantChildren) || void 0 === i || i.forEach((e => { var n; return null === (n = e.animationState) || void 0 === n ? void 0 : n.setActive(t, r) })), n[t].isActive = r; const a = o(t); for (const e in n) n[e].protectedKeys = {}; return a }, setAnimateFunction: function (n) { t = n(e) }, getState: () => n, reset: () => { n = Ko(), r = !0 } } }(e)) } updateAnimationControlsSubscription() { const { animate: e } = this.node.getProps(); $e(e) && (this.unmountControls = e.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: e } = this.node.getProps(), { animate: t } = this.node.prevProps || {}; e !== t && this.updateAnimationControlsSubscription() } unmount() { var e; this.node.animationState.reset(), null === (e = this.unmountControls) || void 0 === e || e.call(this) } } }, exit: { Feature: class extends Kn { constructor() { super(...arguments), this.id = Go++ } update() { if (!this.node.presenceContext) return; const { isPresent: e, onExitComplete: t } = this.node.presenceContext, { isPresent: n } = this.node.prevPresenceContext || {}; if (!this.node.animationState || e === n) return; const r = this.node.animationState.setActive("exit", !e); t && !e && r.then((() => t(this.id))) } mount() { const { register: e } = this.node.presenceContext || {}; e && (this.unmount = e(this.id)) } unmount() { } } } }, _o = (e, t) => Math.abs(e - t); class $o { constructor(e, t) { let { transformPagePoint: n, contextWindow: r, dragSnapToOrigin: i = !1 } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => { if (!this.lastMoveEvent || !this.lastMoveEventInfo) return; const e = na(this.lastMoveEventInfo, this.history), t = null !== this.startEvent, n = function (e, t) { const n = _o(e.x, t.x), r = _o(e.y, t.y); return Math.sqrt(n ** 2 + r ** 2) }(e.offset, { x: 0, y: 0 }) >= 3; if (!t && !n) return; const { point: r } = e, { timestamp: i } = Ln; this.history.push({ ...r, timestamp: i }); const { onStart: o, onMove: a } = this.handlers; t || (o && o(this.lastMoveEvent, e), this.startEvent = this.lastMoveEvent), a && a(this.lastMoveEvent, e) }, this.handlePointerMove = (e, t) => { this.lastMoveEvent = e, this.lastMoveEventInfo = ea(t, this.transformPagePoint), Tn.update(this.updatePoint, !0) }, this.handlePointerUp = (e, t) => { this.end(); const { onEnd: n, onSessionEnd: r, resumeAnimation: i } = this.handlers; if (this.dragSnapToOrigin && i && i(), !this.lastMoveEvent || !this.lastMoveEventInfo) return; const o = na("pointercancel" === e.type ? this.lastMoveEventInfo : ea(t, this.transformPagePoint), this.history); this.startEvent && n && n(e, o), r && r(e, o) }, !Bn(e)) return; this.dragSnapToOrigin = i, this.handlers = t, this.transformPagePoint = n, this.contextWindow = r || window; const o = ea(Fn(e), this.transformPagePoint), { point: a } = o, { timestamp: s } = Ln; this.history = [{ ...a, timestamp: s }]; const { onSessionStart: l } = t; l && l(e, na(o, this.history)), this.removeListeners = Hn(Un(this.contextWindow, "pointermove", this.handlePointerMove), Un(this.contextWindow, "pointerup", this.handlePointerUp), Un(this.contextWindow, "pointercancel", this.handlePointerUp)) } updateHandlers(e) { this.handlers = e } end() { this.removeListeners && this.removeListeners(), In(this.updatePoint) } } function ea(e, t) { return t ? { point: t(e.point) } : e } function ta(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function na(e, t) { let { point: n } = e; return { point: n, delta: ta(n, ia(t)), offset: ta(n, ra(t)), velocity: oa(t, .1) } } function ra(e) { return e[0] } function ia(e) { return e[e.length - 1] } function oa(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let n = e.length - 1, r = null; const i = ia(e); for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > lr(t)));)n--; if (!r) return { x: 0, y: 0 }; const o = cr(i.timestamp - r.timestamp); if (0 === o) return { x: 0, y: 0 }; const a = { x: (i.x - r.x) / o, y: (i.y - r.y) / o }; return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a } const aa = .9999, sa = 1.0001, la = -.01, ca = .01; function ua(e) { return e.max - e.min } function da(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5; e.origin = r, e.originPoint = $i(t.min, t.max, e.origin), e.scale = ua(n) / ua(t), e.translate = $i(n.min, n.max, e.origin) - e.originPoint, (e.scale >= aa && e.scale <= sa || isNaN(e.scale)) && (e.scale = 1), (e.translate >= la && e.translate <= ca || isNaN(e.translate)) && (e.translate = 0) } function ha(e, t, n, r) { da(e.x, t.x, n.x, r ? r.originX : void 0), da(e.y, t.y, n.y, r ? r.originY : void 0) } function fa(e, t, n) { e.min = n.min + t.min, e.max = e.min + ua(t) } function pa(e, t, n) { e.min = t.min - n.min, e.max = e.min + ua(t) } function ma(e, t, n) { pa(e.x, t.x, n.x), pa(e.y, t.y, n.y) } function ga(e, t, n) { return { min: void 0 !== t ? e.min + t : void 0, max: void 0 !== n ? e.max + n - (e.max - e.min) : void 0 } } function va(e, t) { let n = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r } } const ya = .35; function ba(e, t, n) { return { min: xa(e, t), max: xa(e, n) } } function xa(e, t) { return "number" === typeof e ? e : e[t] || 0 } const wa = () => ({ x: { translate: 0, scale: 1, origin: 0, originPoint: 0 }, y: { translate: 0, scale: 1, origin: 0, originPoint: 0 } }), ka = () => ({ x: { min: 0, max: 0 }, y: { min: 0, max: 0 } }); function Sa(e) { return [e("x"), e("y")] } function Aa(e) { let { top: t, left: n, right: r, bottom: i } = e; return { x: { min: n, max: r }, y: { min: t, max: i } } } function Ea(e) { return void 0 === e || 1 === e } function Ca(e) { let { scale: t, scaleX: n, scaleY: r } = e; return !Ea(t) || !Ea(n) || !Ea(r) } function Pa(e) { return Ca(e) || ja(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function ja(e) { return Na(e.x) || Na(e.y) } function Na(e) { return e && "0%" !== e } function Ma(e, t, n) { return n + t * (e - n) } function Ta(e, t, n, r, i) { return void 0 !== i && (e = Ma(e, i, r)), Ma(e, n, r) + t } function Ia(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 ? arguments[4] : void 0; e.min = Ta(e.min, t, n, r, i), e.max = Ta(e.max, t, n, r, i) } function La(e, t) { let { x: n, y: r } = t; Ia(e.x, n.translate, n.scale, n.originPoint), Ia(e.y, r.translate, r.scale, r.originPoint) } const Ra = .999999999999, Da = 1.0000000000001; function za(e, t) { e.min = e.min + t, e.max = e.max + t } function Oa(e, t, n, r) { let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .5; Ia(e, t, n, $i(e.min, e.max, i), r) } function Ba(e, t) { Oa(e.x, t.x, t.scaleX, t.scale, t.originX), Oa(e.y, t.y, t.scaleY, t.scale, t.originY) } function Fa(e, t) { return Aa(function (e, t) { if (!t) return e; const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } }(e.getBoundingClientRect(), t)) } const Va = e => { let { current: t } = e; return t ? t.ownerDocument.defaultView : null }, Ua = new WeakMap; class Wa { constructor(e) { this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ka(), this.visualElement = e } start(e) { let { snapToCursor: t = !1 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const { presenceContext: n } = this.visualElement; if (n && !1 === n.isPresent) return; const { dragSnapToOrigin: r } = this.getProps(); this.panSession = new $o(e, { onSessionStart: e => { const { dragSnapToOrigin: n } = this.getProps(); n ? this.pauseAnimation() : this.stopAnimation(), t && this.snapToCursor(Fn(e, "page").point) }, onStart: (e, t) => { var n; const { drag: r, dragPropagation: i, onDragStart: o } = this.getProps(); if (r && !i && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = qn(r), !this.openGlobalLock)) return; this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Sa((e => { let t = this.getAxisMotionValue(e).get() || 0; if (Ft.test(t)) { const { projection: n } = this.visualElement; if (n && n.layout) { const r = n.layout.layoutBox[e]; if (r) { t = ua(r) * (parseFloat(t) / 100) } } } this.originPoint[e] = t })), o && Tn.postRender((() => o(e, t))), null === (n = this.removeWillChange) || void 0 === n || n.call(this), this.removeWillChange = Fo(this.visualElement, "transform"); const { animationState: a } = this.visualElement; a && a.setActive("whileDrag", !0) }, onMove: (e, t) => { const { dragPropagation: n, dragDirectionLock: r, onDirectionLock: i, onDrag: o } = this.getProps(); if (!n && !this.openGlobalLock) return; const { offset: a } = t; if (r && null === this.currentDirection) return this.currentDirection = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10, n = null; Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"); return n }(a), void (null !== this.currentDirection && i && i(this.currentDirection)); this.updateAxis("x", t.point, a), this.updateAxis("y", t.point, a), this.visualElement.render(), o && o(e, t) }, onSessionEnd: (e, t) => this.stop(e, t), resumeAnimation: () => Sa((e => { var t; return "paused" === this.getAnimationState(e) && (null === (t = this.getAxisMotionValue(e).animation) || void 0 === t ? void 0 : t.play()) })) }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: r, contextWindow: Va(this.visualElement) }) } stop(e, t) { var n; null === (n = this.removeWillChange) || void 0 === n || n.call(this); const r = this.isDragging; if (this.cancel(), !r) return; const { velocity: i } = t; this.startAnimation(i); const { onDragEnd: o } = this.getProps(); o && Tn.postRender((() => o(e, t))) } cancel() { this.isDragging = !1; const { projection: e, animationState: t } = this.visualElement; e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: n } = this.getProps(); !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), t && t.setActive("whileDrag", !1) } updateAxis(e, t, n) { const { drag: r } = this.getProps(); if (!n || !Ha(e, r, this.currentDirection)) return; const i = this.getAxisMotionValue(e); let o = this.originPoint[e] + n[e]; this.constraints && this.constraints[e] && (o = function (e, t, n) { let { min: r, max: i } = t; return void 0 !== r && e < r ? e = n ? $i(r, e, n.min) : Math.max(e, r) : void 0 !== i && e > i && (e = n ? $i(i, e, n.max) : Math.min(e, i)), e }(o, this.constraints[e], this.elastic[e])), i.set(o) } resolveConstraints() { var e; const { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : null === (e = this.visualElement.projection) || void 0 === e ? void 0 : e.layout, i = this.constraints; t && Xe(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : this.constraints = !(!t || !r) && function (e, t) { let { top: n, left: r, bottom: i, right: o } = t; return { x: ga(e.x, r, o), y: ga(e.y, n, i) } }(r.layoutBox, t), this.elastic = function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ya; return !1 === e ? e = 0 : !0 === e && (e = ya), { x: ba(e, "left", "right"), y: ba(e, "top", "bottom") } }(n), i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && Sa((e => { !1 !== this.constraints && this.getAxisMotionValue(e) && (this.constraints[e] = function (e, t) { const n = {}; return void 0 !== t.min && (n.min = t.min - e.min), void 0 !== t.max && (n.max = t.max - e.min), n }(r.layoutBox[e], this.constraints[e])) })) } resolveRefConstraints() { const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps(); if (!e || !Xe(e)) return !1; const n = e.current; Sr(null !== n, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."); const { projection: r } = this.visualElement; if (!r || !r.layout) return !1; const i = function (e, t, n) { const r = Fa(e, n), { scroll: i } = t; return i && (za(r.x, i.offset.x), za(r.y, i.offset.y)), r }(n, r.root, this.visualElement.getTransformPagePoint()); let o = function (e, t) { return { x: va(e.x, t.x), y: va(e.y, t.y) } }(r.layout.layoutBox, i); if (t) { const e = t(function (e) { let { x: t, y: n } = e; return { top: n.min, right: t.max, bottom: n.max, left: t.min } }(o)); this.hasMutatedConstraints = !!e, e && (o = Aa(e)) } return o } startAnimation(e) { const { drag: t, dragMomentum: n, dragElastic: r, dragTransition: i, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), s = this.constraints || {}, l = Sa((a => { if (!Ha(a, t, this.currentDirection)) return; let l = s && s[a] || {}; o && (l = { min: 0, max: 0 }); const c = r ? 200 : 1e6, u = r ? 40 : 1e7, d = { type: "inertia", velocity: n ? e[a] : 0, bounceStiffness: c, bounceDamping: u, timeConstant: 750, restDelta: 1, restSpeed: 10, ...i, ...l }; return this.startAxisValueAnimation(a, d) })); return Promise.all(l).then(a) } startAxisValueAnimation(e, t) { const n = this.getAxisMotionValue(e); return n.start(To(e, n, 0, t, this.visualElement, !1, Fo(this.visualElement, e))) } stopAnimation() { Sa((e => this.getAxisMotionValue(e).stop())) } pauseAnimation() { Sa((e => { var t; return null === (t = this.getAxisMotionValue(e).animation) || void 0 === t ? void 0 : t.pause() })) } getAnimationState(e) { var t; return null === (t = this.getAxisMotionValue(e).animation) || void 0 === t ? void 0 : t.state } getAxisMotionValue(e) { const t = "_drag".concat(e.toUpperCase()), n = this.visualElement.getProps(), r = n[t]; return r || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0) } snapToCursor(e) { Sa((t => { const { drag: n } = this.getProps(); if (!Ha(t, n, this.currentDirection)) return; const { projection: r } = this.visualElement, i = this.getAxisMotionValue(t); if (r && r.layout) { const { min: n, max: o } = r.layout.layoutBox[t]; i.set(e[t] - $i(n, o, .5)) } })) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: e, dragConstraints: t } = this.getProps(), { projection: n } = this.visualElement; if (!Xe(t) || !n || !this.constraints) return; this.stopAnimation(); const r = { x: 0, y: 0 }; Sa((e => { const t = this.getAxisMotionValue(e); if (t && !1 !== this.constraints) { const n = t.get(); r[e] = function (e, t) { let n = .5; const r = ua(e), i = ua(t); return i > r ? n = _i(t.min, t.max - r, e.min) : r > i && (n = _i(e.min, e.max - i, t.min)), jt(0, 1, n) }({ min: n, max: n }, this.constraints[e]) } })); const { transformTemplate: i } = this.visualElement.getProps(); this.visualElement.current.style.transform = i ? i({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), Sa((t => { if (!Ha(t, e, null)) return; const n = this.getAxisMotionValue(t), { min: i, max: o } = this.constraints[t]; n.set($i(i, o, r[t])) })) } addListeners() { if (!this.visualElement.current) return; Ua.set(this.visualElement, this); const e = Un(this.visualElement.current, "pointerdown", (e => { const { drag: t, dragListener: n = !0 } = this.getProps(); t && n && this.start(e) })), t = () => { const { dragConstraints: e } = this.getProps(); Xe(e) && e.current && (this.constraints = this.resolveRefConstraints()) }, { projection: n } = this.visualElement, r = n.addEventListener("measure", t); n && !n.layout && (n.root && n.root.updateScroll(), n.updateLayout()), Tn.read(t); const i = On(window, "resize", (() => this.scalePositionWithinConstraints())), o = n.addEventListener("didUpdate", (e => { let { delta: t, hasLayoutChanged: n } = e; this.isDragging && n && (Sa((e => { const n = this.getAxisMotionValue(e); n && (this.originPoint[e] += t[e].translate, n.set(n.get() + t[e].translate)) })), this.visualElement.render()) })); return () => { i(), e(), r(), o && o() } } getProps() { const e = this.visualElement.getProps(), { drag: t = !1, dragDirectionLock: n = !1, dragPropagation: r = !1, dragConstraints: i = !1, dragElastic: o = ya, dragMomentum: a = !0 } = e; return { ...e, drag: t, dragDirectionLock: n, dragPropagation: r, dragConstraints: i, dragElastic: o, dragMomentum: a } } } function Ha(e, t, n) { return (!0 === t || t === e) && (null === n || n === e) } const Ya = e => (t, n) => { e && Tn.postRender((() => e(t, n))) }; const Xa = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; function Qa(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } const qa = { correct: (e, t) => { if (!t.target) return e; if ("string" === typeof e) { if (!Vt.test(e)) return e; e = parseFloat(e) } const n = Qa(e, t.target.x), r = Qa(e, t.target.y); return "".concat(n, "% ").concat(r, "%") } }, Za = { correct: (e, t) => { let { treeScale: n, projectionDelta: r } = t; const i = e, o = ai.parse(e); if (o.length > 5) return i; const a = ai.createTransformer(e), s = "number" !== typeof o[0] ? 1 : 0, l = r.x.scale * n.x, c = r.y.scale * n.y; o[0 + s] /= l, o[1 + s] /= c; const u = $i(l, c, .5); return "number" === typeof o[2 + s] && (o[2 + s] /= u), "number" === typeof o[3 + s] && (o[3 + s] /= u), a(o) } }; class Ka extends i.Component { componentDidMount() { const { visualElement: e, layoutGroup: t, switchLayoutGroup: n, layoutId: r } = this.props, { projection: i } = e; var o; o = Ja, Object.assign(mt, o), i && (t.group && t.group.add(i), n && n.register && r && n.register(i), i.root.didUpdate(), i.addEventListener("animationComplete", (() => { this.safeToRemove() })), i.setOptions({ ...i.options, onExitComplete: () => this.safeToRemove() })), Xa.hasEverUpdated = !0 } getSnapshotBeforeUpdate(e) { const { layoutDependency: t, visualElement: n, drag: r, isPresent: i } = this.props, o = n.projection; return o ? (o.isPresent = i, r || e.layoutDependency !== t || void 0 === t ? o.willUpdate() : this.safeToRemove(), e.isPresent !== i && (i ? o.promote() : o.relegate() || Tn.postRender((() => { const e = o.getStack(); e && e.members.length || this.safeToRemove() }))), null) : null } componentDidUpdate() { const { projection: e } = this.props.visualElement; e && (e.root.didUpdate(), He.postRender((() => { !e.currentAnimation && e.isLead() && this.safeToRemove() }))) } componentWillUnmount() { const { visualElement: e, layoutGroup: t, switchLayoutGroup: n } = this.props, { projection: r } = e; r && (r.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(r), n && n.deregister && n.deregister(r)) } safeToRemove() { const { safeToRemove: e } = this.props; e && e() } render() { return null } } function Ga(e) { const [t, n] = function () { const e = (0, i.useContext)(Le); if (null === e) return [!0, null]; const { isPresent: t, onExitComplete: n, register: r } = e, o = (0, i.useId)(); return (0, i.useEffect)((() => r(o)), []), !t && n ? [!1, () => n && n(o)] : [!0] }(), r = (0, i.useContext)(lt); return (0, Me.jsx)(Ka, { ...e, layoutGroup: r, switchLayoutGroup: (0, i.useContext)(Qe), isPresent: t, safeToRemove: n }) } const Ja = { borderRadius: { ...qa, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: qa, borderTopRightRadius: qa, borderBottomLeftRadius: qa, borderBottomRightRadius: qa, boxShadow: Za }, _a = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], $a = _a.length, es = e => "string" === typeof e ? parseFloat(e) : e, ts = e => "number" === typeof e || Vt.test(e); function ns(e, t) { return void 0 !== e[t] ? e[t] : e.borderRadius } const rs = os(0, .5, Xi), is = os(.5, .95, Mn); function os(e, t, n) { return r => r < e ? 0 : r > t ? 1 : n(_i(e, t, r)) } function as(e, t) { e.min = t.min, e.max = t.max } function ss(e, t) { as(e.x, t.x), as(e.y, t.y) } function ls(e, t) { e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin } function cs(e, t, n, r, i) { return e = Ma(e -= t, 1 / n, r), void 0 !== i && (e = Ma(e, 1 / i, r)), e } function us(e, t, n, r, i) { let [o, a, s] = n; !function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5, i = arguments.length > 4 ? arguments[4] : void 0, o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : e, a = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : e; Ft.test(t) && (t = parseFloat(t), t = $i(a.min, a.max, t / 100) - a.min); if ("number" !== typeof t) return; let s = $i(o.min, o.max, r); e === o && (s -= t), e.min = cs(e.min, t, n, s, i), e.max = cs(e.max, t, n, s, i) }(e, t[o], t[a], t[s], t.scale, r, i) } const ds = ["x", "scaleX", "originX"], hs = ["y", "scaleY", "originY"]; function fs(e, t, n, r) { us(e.x, t, ds, n ? n.x : void 0, r ? r.x : void 0), us(e.y, t, hs, n ? n.y : void 0, r ? r.y : void 0) } function ps(e) { return 0 === e.translate && 1 === e.scale } function ms(e) { return ps(e.x) && ps(e.y) } function gs(e, t) { return Math.round(e.x.min) === Math.round(t.x.min) && Math.round(e.x.max) === Math.round(t.x.max) && Math.round(e.y.min) === Math.round(t.y.min) && Math.round(e.y.max) === Math.round(t.y.max) } function vs(e) { return ua(e.x) / ua(e.y) } function ys(e, t) { return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint } class bs { constructor() { this.members = [] } add(e) { An(this.members, e), e.scheduleRender() } remove(e) { if (En(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) { const e = this.members[this.members.length - 1]; e && this.promote(e) } } relegate(e) { const t = this.members.findIndex((t => e === t)); if (0 === t) return !1; let n; for (let r = t; r >= 0; r--) { const e = this.members[r]; if (!1 !== e.isPresent) { n = e; break } } return !!n && (this.promote(n), !0) } promote(e, t) { const n = this.lead; if (e !== n && (this.prevLead = n, this.lead = e, e.show(), n)) { n.instance && n.scheduleRender(), e.scheduleRender(), e.resumeFrom = n, t && (e.resumeFrom.preserveOpacity = !0), n.snapshot && (e.snapshot = n.snapshot, e.snapshot.latestValues = n.animationValues || n.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0); const { crossfade: r } = e.options; !1 === r && n.hide() } } exitAnimationComplete() { this.members.forEach((e => { const { options: t, resumingFrom: n } = e; t.onExitComplete && t.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete() })) } scheduleRender() { this.members.forEach((e => { e.instance && e.scheduleRender(!1) })) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } const xs = (e, t) => e.depth - t.depth; class ws { constructor() { this.children = [], this.isDirty = !1 } add(e) { An(this.children, e), this.isDirty = !0 } remove(e) { En(this.children, e), this.isDirty = !0 } forEach(e) { this.isDirty && this.children.sort(xs), this.isDirty = !1, this.children.forEach(e) } } const ks = { type: "projectionFrame", totalNodes: 0, resolvedTargetDeltas: 0, recalculatedProjection: 0 }, Ss = ["", "X", "Y", "Z"], As = { visibility: "hidden" }; let Es = 0; function Cs(e, t, n, r) { const { latestValues: i } = t; i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function Ps(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return !1; const { visualElement: t } = e.options; return !!t && (!!Oo(t) || !(!e.parent || e.parent.hasCheckedOptimisedAppear) && Ps(e.parent)) } function js(e) { let { attachResizeListener: t, defaultParent: n, measureScroll: r, checkIsScrollRoot: i, resetTransform: o } = e; return class { constructor() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null === n || void 0 === n ? void 0 : n(); this.id = Es++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, window.MotionDebug && (ks.totalNodes = ks.resolvedTargetDeltas = ks.recalculatedProjection = 0), this.nodes.forEach(Ts), this.nodes.forEach(Bs), this.nodes.forEach(Fs), this.nodes.forEach(Is), window.MotionDebug && window.MotionDebug.record(ks) }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = e, this.root = t ? t.root || t : this, this.path = t ? [...t.path, t] : [], this.parent = t, this.depth = t ? t.depth + 1 : 0; for (let n = 0; n < this.path.length; n++)this.path[n].shouldResetTransform = !0; this.root === this && (this.nodes = new ws) } addEventListener(e, t) { return this.eventHandlers.has(e) || this.eventHandlers.set(e, new Io), this.eventHandlers.get(e).add(t) } notifyListeners(e) { const t = this.eventHandlers.get(e); for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; t && t.notify(...r) } hasListeners(e) { return this.eventHandlers.has(e) } mount(e) { let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.root.hasTreeAnimated; if (this.instance) return; var r; this.isSVG = (r = e) instanceof SVGElement && "svg" !== r.tagName, this.instance = e; const { layoutId: i, layout: o, visualElement: a } = this.options; if (a && !a.current && a.mount(e), this.root.nodes.add(this), this.parent && this.parent.children.add(this), n && (o || i) && (this.isLayoutDirty = !0), t) { let n; const r = () => this.root.updateBlockedByResize = !1; t(e, (() => { this.root.updateBlockedByResize = !0, n && n(), n = function (e, t) { const n = xr.now(), r = i => { let { timestamp: o } = i; const a = o - n; a >= t && (In(r), e(a - t)) }; return Tn.read(r, !0), () => In(r) }(r, 250), Xa.hasAnimatedSinceResize && (Xa.hasAnimatedSinceResize = !1, this.nodes.forEach(Os)) })) } i && this.root.registerSharedNode(i, this), !1 !== this.options.animate && a && (i || o) && this.addEventListener("didUpdate", (e => { let { delta: t, hasLayoutChanged: n, hasRelativeTargetChanged: r, layout: i } = e; if (this.isTreeAnimationBlocked()) return this.target = void 0, void (this.relativeTarget = void 0); const o = this.options.transition || a.getDefaultTransition() || Xs, { onLayoutAnimationStart: s, onLayoutAnimationComplete: l } = a.getProps(), c = !this.targetLayout || !gs(this.targetLayout, i) || r, u = !n && r; if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || u || n && (c || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(t, u); const e = { ...pr(o, "layout"), onPlay: s, onComplete: l }; (a.shouldReduceMotion || this.options.layoutRoot) && (e.delay = 0, e.type = !1), this.startAnimation(e) } else n || Os(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = i })) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const e = this.getStack(); e && e.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, In(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Vs), this.animationId++) } getTransformTemplate() { const { visualElement: e } = this.options; return e && e.getProps().transformTemplate } willUpdate() { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) return void (this.options.onExitComplete && this.options.onExitComplete()); if (window.HandoffCancelAllAnimations && Ps(this) && window.HandoffCancelAllAnimations(), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let i = 0; i < this.path.length; i++) { const e = this.path[i]; e.shouldResetTransform = !0, e.updateScroll("snapshot"), e.options.layoutRoot && e.willUpdate(!1) } const { layoutId: t, layout: n } = this.options; if (void 0 === t && !n) return; const r = this.getTransformTemplate(); this.prevTransformTemplateValue = r ? r(this.latestValues, "") : void 0, this.updateSnapshot(), e && this.notifyListeners("willUpdate") } update() { this.updateScheduled = !1; if (this.isUpdateBlocked()) return this.unblockUpdate(), this.clearAllSnapshots(), void this.nodes.forEach(Rs); this.isUpdating || this.nodes.forEach(Ds), this.isUpdating = !1, this.nodes.forEach(zs), this.nodes.forEach(Ns), this.nodes.forEach(Ms), this.clearAllSnapshots(); const e = xr.now(); Ln.delta = jt(0, 1e3 / 60, e - Ln.timestamp), Ln.timestamp = e, Ln.isProcessing = !0, Rn.update.process(Ln), Rn.preRender.process(Ln), Rn.render.process(Ln), Ln.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, He.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(Ls), this.sharedNodes.forEach(Us) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Tn.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { Tn.postRender((() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() })) } updateSnapshot() { !this.snapshot && this.instance && (this.snapshot = this.measure()) } updateLayout() { if (!this.instance) return; if (this.updateScroll(), (!this.options.alwaysMeasureLayout || !this.isLead()) && !this.isLayoutDirty) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let n = 0; n < this.path.length; n++) { this.path[n].updateScroll() } const e = this.layout; this.layout = this.measure(!1), this.layoutCorrected = ka(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: t } = this.options; t && t.notify("LayoutMeasure", this.layout.layoutBox, e ? e.layoutBox : void 0) } updateScroll() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "measure", t = Boolean(this.options.layoutScroll && this.instance); this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === e && (t = !1), t && (this.scroll = { animationId: this.root.animationId, phase: e, isRoot: i(this.instance), offset: r(this.instance) }) } resetTransform() { if (!o) return; const e = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, t = this.projectionDelta && !ms(this.projectionDelta), n = this.getTransformTemplate(), r = n ? n(this.latestValues, "") : void 0, i = r !== this.prevTransformTemplateValue; e && (t || Pa(this.latestValues) || i) && (o(this.instance, r), this.shouldResetTransform = !1, this.scheduleRender()) } measure() { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; const t = this.measurePageBox(); let n = this.removeElementScroll(t); var r; return e && (n = this.removeTransform(n)), Zs((r = n).x), Zs(r.y), { animationId: this.root.animationId, measuredBox: t, layoutBox: n, latestValues: {}, source: this.id } } measurePageBox() { const { visualElement: e } = this.options; if (!e) return ka(); const t = e.measureViewportBox(), { scroll: n } = this.root; return n && (za(t.x, n.offset.x), za(t.y, n.offset.y)), t } removeElementScroll(e) { const t = ka(); ss(t, e); for (let n = 0; n < this.path.length; n++) { const r = this.path[n], { scroll: i, options: o } = r; if (r !== this.root && i && o.layoutScroll) { if (i.isRoot) { ss(t, e); const { scroll: n } = this.root; n && (za(t.x, -n.offset.x), za(t.y, -n.offset.y)) } za(t.x, i.offset.x), za(t.y, i.offset.y) } } return t } applyTransform(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = ka(); ss(n, e); for (let r = 0; r < this.path.length; r++) { const e = this.path[r]; !t && e.options.layoutScroll && e.scroll && e !== e.root && Ba(n, { x: -e.scroll.offset.x, y: -e.scroll.offset.y }), Pa(e.latestValues) && Ba(n, e.latestValues) } return Pa(this.latestValues) && Ba(n, this.latestValues), n } removeTransform(e) { const t = ka(); ss(t, e); for (let n = 0; n < this.path.length; n++) { const e = this.path[n]; if (!e.instance) continue; if (!Pa(e.latestValues)) continue; Ca(e.latestValues) && e.updateSnapshot(); const r = ka(); ss(r, e.measurePageBox()), fs(t, e.latestValues, e.snapshot ? e.snapshot.layoutBox : void 0, r) } return Pa(this.latestValues) && fs(t, this.latestValues), t } setTargetDelta(e) { this.targetDelta = e, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(e) { this.options = { ...this.options, ...e, crossfade: void 0 === e.crossfade || e.crossfade } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ln.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta() { let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; var t; const n = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = n.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = n.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = n.isSharedProjectionDirty); const r = Boolean(this.resumingFrom) || this !== n; if (!(e || r && this.isSharedProjectionDirty || this.isProjectionDirty || (null === (t = this.parent) || void 0 === t ? void 0 : t.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: i, layoutId: o } = this.options; if (this.layout && (i || o)) { if (this.resolvedRelativeTargetAt = Ln.timestamp, !this.targetDelta && !this.relativeTarget) { const e = this.getClosestProjectingParent(); e && e.layout && 1 !== this.animationProgress ? (this.relativeParent = e, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ka(), this.relativeTargetOrigin = ka(), ma(this.relativeTargetOrigin, this.layout.layoutBox, e.layout.layoutBox), ss(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } if (this.relativeTarget || this.targetDelta) { var a, s, l; if (this.target || (this.target = ka(), this.targetWithTransforms = ka()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), a = this.target, s = this.relativeTarget, l = this.relativeParent.target, fa(a.x, s.x, l.x), fa(a.y, s.y, l.y)) : this.targetDelta ? (Boolean(this.resumingFrom) ? this.target = this.applyTransform(this.layout.layoutBox) : ss(this.target, this.layout.layoutBox), La(this.target, this.targetDelta)) : ss(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) { this.attemptToResolveRelativeTarget = !1; const e = this.getClosestProjectingParent(); e && Boolean(e.resumingFrom) === Boolean(this.resumingFrom) && !e.options.layoutScroll && e.target && 1 !== this.animationProgress ? (this.relativeParent = e, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ka(), this.relativeTargetOrigin = ka(), ma(this.relativeTargetOrigin, this.target, e.target), ss(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0 } window.MotionDebug && ks.resolvedTargetDeltas++ } } } getClosestProjectingParent() { if (this.parent && !Ca(this.parent.latestValues) && !ja(this.parent.latestValues)) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } calcProjection() { var e; const t = this.getLead(), n = Boolean(this.resumingFrom) || this !== t; let r = !0; if ((this.isProjectionDirty || (null === (e = this.parent) || void 0 === e ? void 0 : e.isProjectionDirty)) && (r = !1), n && (this.isSharedProjectionDirty || this.isTransformDirty) && (r = !1), this.resolvedRelativeTargetAt === Ln.timestamp && (r = !1), r) return; const { layout: i, layoutId: o } = this.options; if (this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !i && !o) return; ss(this.layoutCorrected, this.layout.layoutBox); const a = this.treeScale.x, s = this.treeScale.y; !function (e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; const i = n.length; if (!i) return; let o, a; t.x = t.y = 1; for (let s = 0; s < i; s++) { o = n[s], a = o.projectionDelta; const { visualElement: i } = o.options; i && i.props.style && "contents" === i.props.style.display || (r && o.options.layoutScroll && o.scroll && o !== o.root && Ba(e, { x: -o.scroll.offset.x, y: -o.scroll.offset.y }), a && (t.x *= a.x.scale, t.y *= a.y.scale, La(e, a)), r && Pa(o.latestValues) && Ba(e, o.latestValues)) } t.x < Da && t.x > Ra && (t.x = 1), t.y < Da && t.y > Ra && (t.y = 1) }(this.layoutCorrected, this.treeScale, this.path, n), !t.layout || t.target || 1 === this.treeScale.x && 1 === this.treeScale.y || (t.target = t.layout.layoutBox, t.targetWithTransforms = ka()); const { target: l } = t; l ? (this.projectionDelta && this.prevProjectionDelta ? (ls(this.prevProjectionDelta.x, this.projectionDelta.x), ls(this.prevProjectionDelta.y, this.projectionDelta.y)) : this.createProjectionDeltas(), ha(this.projectionDelta, this.layoutCorrected, l, this.latestValues), this.treeScale.x === a && this.treeScale.y === s && ys(this.projectionDelta.x, this.prevProjectionDelta.x) && ys(this.projectionDelta.y, this.prevProjectionDelta.y) || (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", l)), window.MotionDebug && ks.recalculatedProjection++) : this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender() { let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]; if (this.options.scheduleRender && this.options.scheduleRender(), e) { const e = this.getStack(); e && e.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = wa(), this.projectionDelta = wa(), this.projectionDeltaWithTransform = wa() } setAnimationOrigin(e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = this.snapshot, r = n ? n.latestValues : {}, i = { ...this.latestValues }, o = wa(); this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !t; const a = ka(), s = (n ? n.source : void 0) !== (this.layout ? this.layout.source : void 0), l = this.getStack(), c = !l || l.members.length <= 1, u = Boolean(s && !c && !0 === this.options.crossfade && !this.path.some(Ys)); let d; this.animationProgress = 0, this.mixTargetDelta = t => { const n = t / 1e3; var l, h, f, p, m, g; Ws(o.x, e.x, n), Ws(o.y, e.y, n), this.setTargetDelta(o), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (ma(a, this.layout.layoutBox, this.relativeParent.layout.layoutBox), f = this.relativeTarget, p = this.relativeTargetOrigin, m = a, g = n, Hs(f.x, p.x, m.x, g), Hs(f.y, p.y, m.y, g), d && (l = this.relativeTarget, h = d, l.x.min === h.x.min && l.x.max === h.x.max && l.y.min === h.y.min && l.y.max === h.y.max) && (this.isProjectionDirty = !1), d || (d = ka()), ss(d, this.relativeTarget)), s && (this.animationValues = i, function (e, t, n, r, i, o) { i ? (e.opacity = $i(0, void 0 !== n.opacity ? n.opacity : 1, rs(r)), e.opacityExit = $i(void 0 !== t.opacity ? t.opacity : 1, 0, is(r))) : o && (e.opacity = $i(void 0 !== t.opacity ? t.opacity : 1, void 0 !== n.opacity ? n.opacity : 1, r)); for (let a = 0; a < $a; a++) { const i = "border".concat(_a[a], "Radius"); let o = ns(t, i), s = ns(n, i); void 0 === o && void 0 === s || (o || (o = 0), s || (s = 0), 0 === o || 0 === s || ts(o) === ts(s) ? (e[i] = Math.max($i(es(o), es(s), r), 0), (Ft.test(s) || Ft.test(o)) && (e[i] += "%")) : e[i] = s) } (t.rotate || n.rotate) && (e.rotate = $i(t.rotate || 0, n.rotate || 0, r)) }(i, r, this.latestValues, n, u, c)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = n }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(e) { this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (In(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Tn.update((() => { Xa.hasAnimatedSinceResize = !0, this.currentAnimation = function (e, t, n) { const r = bt(e) ? e : Do(e); return r.start(To("", r, t, n)), r.animation }(0, 1e3, { ...e, onUpdate: t => { this.mixTargetDelta(t), e.onUpdate && e.onUpdate(t) }, onComplete: () => { e.onComplete && e.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 })) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const e = this.getStack(); e && e.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1e3), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const e = this.getLead(); let { targetWithTransforms: t, target: n, layout: r, latestValues: i } = e; if (t && n && r) { if (this !== e && this.layout && r && Ks(this.options.animationType, this.layout.layoutBox, r.layoutBox)) { n = this.target || ka(); const t = ua(this.layout.layoutBox.x); n.x.min = e.target.x.min, n.x.max = n.x.min + t; const r = ua(this.layout.layoutBox.y); n.y.min = e.target.y.min, n.y.max = n.y.min + r } ss(t, n), Ba(t, i), ha(this.projectionDeltaWithTransform, this.layoutCorrected, t, i) } } registerSharedNode(e, t) { this.sharedNodes.has(e) || this.sharedNodes.set(e, new bs); this.sharedNodes.get(e).add(t); const n = t.options.initialPromotionConfig; t.promote({ transition: n ? n.transition : void 0, preserveFollowOpacity: n && n.shouldPreserveFollowOpacity ? n.shouldPreserveFollowOpacity(t) : void 0 }) } isLead() { const e = this.getStack(); return !e || e.lead === this } getLead() { var e; const { layoutId: t } = this.options; return t && (null === (e = this.getStack()) || void 0 === e ? void 0 : e.lead) || this } getPrevLead() { var e; const { layoutId: t } = this.options; return t ? null === (e = this.getStack()) || void 0 === e ? void 0 : e.prevLead : void 0 } getStack() { const { layoutId: e } = this.options; if (e) return this.root.sharedNodes.get(e) } promote() { let { needsReset: e, transition: t, preserveFollowOpacity: n } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const r = this.getStack(); r && r.promote(this, n), e && (this.projectionDelta = void 0, this.needsReset = !0), t && this.setOptions({ transition: t }) } relegate() { const e = this.getStack(); return !!e && e.relegate(this) } resetSkewAndRotation() { const { visualElement: e } = this.options; if (!e) return; let t = !1; const { latestValues: n } = e; if ((n.z || n.rotate || n.rotateX || n.rotateY || n.rotateZ || n.skewX || n.skewY) && (t = !0), !t) return; const r = {}; n.z && Cs("z", e, r, this.animationValues); for (let i = 0; i < Ss.length; i++)Cs("rotate".concat(Ss[i]), e, r, this.animationValues), Cs("skew".concat(Ss[i]), e, r, this.animationValues); e.render(); for (const i in r) e.setStaticValue(i, r[i]), this.animationValues && (this.animationValues[i] = r[i]); e.scheduleRender() } getProjectionStyles(e) { var t, n; if (!this.instance || this.isSVG) return; if (!this.isVisible) return As; const r = { visibility: "" }, i = this.getTransformTemplate(); if (this.needsReset) return this.needsReset = !1, r.opacity = "", r.pointerEvents = wn(null === e || void 0 === e ? void 0 : e.pointerEvents) || "", r.transform = i ? i(this.latestValues, "") : "none", r; const o = this.getLead(); if (!this.projectionDelta || !this.layout || !o.target) { const t = {}; return this.options.layoutId && (t.opacity = void 0 !== this.latestValues.opacity ? this.latestValues.opacity : 1, t.pointerEvents = wn(null === e || void 0 === e ? void 0 : e.pointerEvents) || ""), this.hasProjected && !Pa(this.latestValues) && (t.transform = i ? i({}, "") : "none", this.hasProjected = !1), t } const a = o.animationValues || o.latestValues; this.applyTransformsToTarget(), r.transform = function (e, t, n) { let r = ""; const i = e.x.translate / t.x, o = e.y.translate / t.y, a = (null === n || void 0 === n ? void 0 : n.z) || 0; if ((i || o || a) && (r = "translate3d(".concat(i, "px, ").concat(o, "px, ").concat(a, "px) ")), 1 === t.x && 1 === t.y || (r += "scale(".concat(1 / t.x, ", ").concat(1 / t.y, ") ")), n) { const { transformPerspective: e, rotate: t, rotateX: i, rotateY: o, skewX: a, skewY: s } = n; e && (r = "perspective(".concat(e, "px) ").concat(r)), t && (r += "rotate(".concat(t, "deg) ")), i && (r += "rotateX(".concat(i, "deg) ")), o && (r += "rotateY(".concat(o, "deg) ")), a && (r += "skewX(".concat(a, "deg) ")), s && (r += "skewY(".concat(s, "deg) ")) } const s = e.x.scale * t.x, l = e.y.scale * t.y; return 1 === s && 1 === l || (r += "scale(".concat(s, ", ").concat(l, ")")), r || "none" }(this.projectionDeltaWithTransform, this.treeScale, a), i && (r.transform = i(a, r.transform)); const { x: s, y: l } = this.projectionDelta; r.transformOrigin = "".concat(100 * s.origin, "% ").concat(100 * l.origin, "% 0"), o.animationValues ? r.opacity = o === this ? null !== (n = null !== (t = a.opacity) && void 0 !== t ? t : this.latestValues.opacity) && void 0 !== n ? n : 1 : this.preserveOpacity ? this.latestValues.opacity : a.opacityExit : r.opacity = o === this ? void 0 !== a.opacity ? a.opacity : "" : void 0 !== a.opacityExit ? a.opacityExit : 0; for (const c in mt) { if (void 0 === a[c]) continue; const { correct: e, applyTo: t } = mt[c], n = "none" === r.transform ? a[c] : e(a[c], o); if (t) { const e = t.length; for (let i = 0; i < e; i++)r[t[i]] = n } else r[c] = n } return this.options.layoutId && (r.pointerEvents = o === this ? wn(null === e || void 0 === e ? void 0 : e.pointerEvents) || "" : "none"), r } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach((e => { var t; return null === (t = e.currentAnimation) || void 0 === t ? void 0 : t.stop() })), this.root.nodes.forEach(Rs), this.root.sharedNodes.clear() } } } function Ns(e) { e.updateLayout() } function Ms(e) { var t; const n = (null === (t = e.resumeFrom) || void 0 === t ? void 0 : t.snapshot) || e.snapshot; if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) { const { layoutBox: t, measuredBox: r } = e.layout, { animationType: i } = e.options, o = n.source !== e.layout.source; "size" === i ? Sa((e => { const r = o ? n.measuredBox[e] : n.layoutBox[e], i = ua(r); r.min = t[e].min, r.max = r.min + i })) : Ks(i, n.layoutBox, t) && Sa((r => { const i = o ? n.measuredBox[r] : n.layoutBox[r], a = ua(t[r]); i.max = i.min + a, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[r].max = e.relativeTarget[r].min + a) })); const a = wa(); ha(a, t, n.layoutBox); const s = wa(); o ? ha(s, e.applyTransform(r, !0), n.measuredBox) : ha(s, t, n.layoutBox); const l = !ms(a); let c = !1; if (!e.resumeFrom) { const r = e.getClosestProjectingParent(); if (r && !r.resumeFrom) { const { snapshot: i, layout: o } = r; if (i && o) { const a = ka(); ma(a, n.layoutBox, i.layoutBox); const s = ka(); ma(s, t, o.layoutBox), gs(a, s) || (c = !0), r.options.layoutRoot && (e.relativeTarget = s, e.relativeTargetOrigin = a, e.relativeParent = r) } } } e.notifyListeners("didUpdate", { layout: t, snapshot: n, delta: s, layoutDelta: a, hasLayoutChanged: l, hasRelativeTargetChanged: c }) } else if (e.isLead()) { const { onExitComplete: t } = e.options; t && t() } e.options.transition = void 0 } function Ts(e) { window.MotionDebug && ks.totalNodes++, e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = Boolean(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function Is(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function Ls(e) { e.clearSnapshot() } function Rs(e) { e.clearMeasurements() } function Ds(e) { e.isLayoutDirty = !1 } function zs(e) { const { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function Os(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function Bs(e) { e.resolveTargetDelta() } function Fs(e) { e.calcProjection() } function Vs(e) { e.resetSkewAndRotation() } function Us(e) { e.removeLeadSnapshot() } function Ws(e, t, n) { e.translate = $i(t.translate, 0, n), e.scale = $i(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint } function Hs(e, t, n, r) { e.min = $i(t.min, n.min, r), e.max = $i(t.max, n.max, r) } function Ys(e) { return e.animationValues && void 0 !== e.animationValues.opacityExit } const Xs = { duration: .45, ease: [.4, 0, .1, 1] }, Qs = e => "undefined" !== typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), qs = Qs("applewebkit/") && !Qs("chrome/") ? Math.round : Mn; function Zs(e) { e.min = qs(e.min), e.max = qs(e.max) } function Ks(e, t, n) { return "position" === e || "preserve-aspect" === e && (r = vs(t), i = vs(n), o = .2, !(Math.abs(r - i) <= o)); var r, i, o } const Gs = js({ attachResizeListener: (e, t) => On(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Js = { current: void 0 }, _s = js({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!Js.current) { const e = new Gs({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), Js.current = e } return Js.current }, resetTransform: (e, t) => { e.style.transform = void 0 !== t ? t : "none" }, checkIsScrollRoot: e => Boolean("fixed" === window.getComputedStyle(e).position) }), $s = { pan: { Feature: class extends Kn { constructor() { super(...arguments), this.removePointerDownListener = Mn } onPointerDown(e) { this.session = new $o(e, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: Va(this.node) }) } createPanHandlers() { const { onPanSessionStart: e, onPanStart: t, onPan: n, onPanEnd: r } = this.node.getProps(); return { onSessionStart: Ya(e), onStart: Ya(t), onMove: n, onEnd: (e, t) => { delete this.session, r && Tn.postRender((() => r(e, t))) } } } mount() { this.removePointerDownListener = Un(this.node.current, "pointerdown", (e => this.onPointerDown(e))) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } }, drag: { Feature: class extends Kn { constructor(e) { super(e), this.removeGroupControls = Mn, this.removeListeners = Mn, this.controls = new Wa(e) } mount() { const { dragControls: e } = this.node.getProps(); e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Mn } unmount() { this.removeGroupControls(), this.removeListeners() } }, ProjectionNode: _s, MeasureLayout: Ga } }, el = { current: null }, tl = { current: !1 }; const nl = new WeakMap, rl = [...Dr, Kr, ai], il = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"], ol = tt.length; class al { scrapeMotionValuesFromProps(e, t, n) { return {} } constructor(e) { let { parent: t, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: o, visualState: a } = e, s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.applyWillChange = !1, this.resolveKeyframes = (e, t, n, r) => new this.KeyframeResolver(e, t, n, r, this), this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = Wr, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.isRenderScheduled = !1, this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.isRenderScheduled = !1, this.scheduleRender = () => { this.isRenderScheduled || (this.isRenderScheduled = !0, Tn.render(this.render, !1, !0)) }; const { latestValues: l, renderState: c } = a; this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = c, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = s, this.blockInitialAnimation = Boolean(o), this.isControllingVariants = nt(n), this.isVariantNode = rt(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = Boolean(t && t.current); const { willChange: u, ...d } = this.scrapeMotionValuesFromProps(n, {}, this); for (const h in d) { const e = d[h]; void 0 !== l[h] && bt(e) && e.set(l[h], !1) } } mount(e) { this.current = e, nl.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach(((e, t) => this.bindToMotionValue(t, e))), tl.current || function () { if (tl.current = !0, Re) if (window.matchMedia) { const e = window.matchMedia("(prefers-reduced-motion)"), t = () => el.current = e.matches; e.addListener(t), t() } else el.current = !1 }(), this.shouldReduceMotion = "never" !== this.reducedMotionConfig && ("always" === this.reducedMotionConfig || el.current), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext) } unmount() { nl.delete(this.current), this.projection && this.projection.unmount(), In(this.notifyUpdate), In(this.render), this.valueSubscriptions.forEach((e => e())), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this); for (const e in this.events) this.events[e].clear(); for (const e in this.features) { const t = this.features[e]; t && (t.unmount(), t.isMounted = !1) } this.current = null } bindToMotionValue(e, t) { const n = vt.has(e), r = t.on("change", (t => { this.latestValues[e] = t, this.props.onUpdate && Tn.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0) })), i = t.on("renderRequest", this.scheduleRender); this.valueSubscriptions.set(e, (() => { r(), i(), t.owner && t.stop() })) } sortNodePosition(e) { return this.current && this.sortInstanceNodePosition && this.type === e.type ? this.sortInstanceNodePosition(this.current, e.current) : 0 } updateFeatures() { let e = "animation"; for (e in st) { const t = st[e]; if (!t) continue; const { isEnabled: n, Feature: r } = t; if (!this.features[e] && r && n(this.props) && (this.features[e] = new r(this)), this.features[e]) { const t = this.features[e]; t.isMounted ? t.update() : (t.mount(), t.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ka() } getStaticValue(e) { return this.latestValues[e] } setStaticValue(e, t) { this.latestValues[e] = t } update(e, t) { (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t; for (let n = 0; n < il.length; n++) { const t = il[n]; this.propEventSubscriptions[t] && (this.propEventSubscriptions[t](), delete this.propEventSubscriptions[t]); const r = e["on" + t]; r && (this.propEventSubscriptions[t] = this.on(t, r)) } this.prevMotionValues = function (e, t, n) { for (const r in t) { const i = t[r], o = n[r]; if (bt(i)) e.addValue(r, i); else if (bt(o)) e.addValue(r, Do(i, { owner: e })); else if (o !== i) if (e.hasValue(r)) { const t = e.getValue(r); !0 === t.liveStyle ? t.jump(i) : t.hasAnimated || t.set(i) } else { const t = e.getStaticValue(r); e.addValue(r, Do(void 0 !== t ? t : i, { owner: e })) } } for (const r in n) void 0 === t[r] && e.removeValue(r); return t }(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(e) { return this.props.variants ? this.props.variants[e] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } getVariantContext() { if (arguments.length > 0 && void 0 !== arguments[0] && arguments[0]) return this.parent ? this.parent.getVariantContext() : void 0; if (!this.isControllingVariants) { const e = this.parent && this.parent.getVariantContext() || {}; return void 0 !== this.props.initial && (e.initial = this.props.initial), e } const e = {}; for (let t = 0; t < ol; t++) { const n = tt[t], r = this.props[n]; (_e(r) || !1 === r) && (e[n] = r) } return e } addVariantChild(e) { const t = this.getClosestVariantNode(); if (t) return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e) } addValue(e, t) { const n = this.values.get(e); t !== n && (n && this.removeValue(e), this.bindToMotionValue(e, t), this.values.set(e, t), this.latestValues[e] = t.get()) } removeValue(e) { this.values.delete(e); const t = this.valueSubscriptions.get(e); t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState) } hasValue(e) { return this.values.has(e) } getValue(e, t) { if (this.props.values && this.props.values[e]) return this.props.values[e]; let n = this.values.get(e); return void 0 === n && void 0 !== t && (n = Do(null === t ? void 0 : t, { owner: this }), this.addValue(e, n)), n } readValue(e, t) { var n; let r = void 0 === this.latestValues[e] && this.current ? null !== (n = this.getBaseTargetFromProps(this.props, e)) && void 0 !== n ? n : this.readValueFromInstance(this.current, e, this.options) : this.latestValues[e]; var i; return void 0 !== r && null !== r && ("string" === typeof r && (Ar(r) || wr(r)) ? r = parseFloat(r) : (i = r, !rl.find(Rr(i)) && ai.test(t) && (r = fi(e, t))), this.setBaseTarget(e, bt(r) ? r.get() : r)), bt(r) ? r.get() : r } setBaseTarget(e, t) { this.baseTarget[e] = t } getBaseTarget(e) { var t; const { initial: n } = this.props; let r; if ("string" === typeof n || "object" === typeof n) { const i = gn(this.props, n, null === (t = this.presenceContext) || void 0 === t ? void 0 : t.custom); i && (r = i[e]) } if (n && void 0 !== r) return r; const i = this.getBaseTargetFromProps(this.props, e); return void 0 === i || bt(i) ? void 0 !== this.initialValues[e] && void 0 === r ? void 0 : this.baseTarget[e] : i } on(e, t) { return this.events[e] || (this.events[e] = new Io), this.events[e].add(t) } notify(e) { if (this.events[e]) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; this.events[e].notify(...n) } } } class sl extends al { constructor() { super(...arguments), this.KeyframeResolver = mi } sortInstanceNodePosition(e, t) { return 2 & e.compareDocumentPosition(t) ? 1 : -1 } getBaseTargetFromProps(e, t) { return e.style ? e.style[t] : void 0 } removeValueFromRenderState(e, t) { let { vars: n, style: r } = t; delete n[e], delete r[e] } } class ll extends sl { constructor() { super(...arguments), this.type = "html", this.applyWillChange = !0, this.renderInstance = un } readValueFromInstance(e, t) { if (vt.has(t)) { const e = hi(t); return e && e.default || 0 } { const r = (n = e, window.getComputedStyle(n)), i = (St(t) ? r.getPropertyValue(t) : r[t]) || 0; return "string" === typeof i ? i.trim() : i } var n } measureInstanceViewportBox(e, t) { let { transformPagePoint: n } = t; return Fa(e, n) } build(e, t, n) { Qt(e, t, n.transformTemplate) } scrapeMotionValuesFromProps(e, t, n) { return fn(e, t, n) } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: e } = this.props; bt(e) && (this.childSubscription = e.on("change", (e => { this.current && (this.current.textContent = "".concat(e)) }))) } } class cl extends sl { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = ka } getBaseTargetFromProps(e, t) { return e[t] } readValueFromInstance(e, t) { if (vt.has(t)) { const e = hi(t); return e && e.default || 0 } return t = dn.has(t) ? t : Oe(t), e.getAttribute(t) } scrapeMotionValuesFromProps(e, t, n) { return pn(e, t, n) } build(e, t, n) { on(e, t, this.isSVGTag, n.transformTemplate) } renderInstance(e, t, n, r) { hn(e, t, 0, r) } mount(e) { this.isSVGTag = sn(e.tagName), super.mount(e) } } const ul = (e, t) => pt(e) ? new cl(t) : new ll(t, { allowProjection: e !== i.Fragment }), dl = { ...Jo, ...or, ...$s, ...{ layout: { ProjectionNode: _s, MeasureLayout: Ga } } }, hl = ht(((e, t) => function (e, t, n, r) { let { forwardMotionProps: i = !1 } = t; return { ...pt(e) ? Dn : zn, preloadedFeatures: n, useRender: cn(i), createVisualElement: r, Component: e } }(e, t, dl, ul))); function fl(e) { let { text: t, variant: n = "primary" } = e; return (0, Me.jsxs)("div", { className: "button-container", children: [" ", (0, Me.jsx)("div", { className: "sm:mt-[1%] mt-[3%]  items-center gap-5", children: (0, Me.jsxs)(hl.button, { initial: { "--x": "100%", scale: 1 }, animate: { "--x": "-100%" }, whileTap: { scale: .97 }, transition: { repeat: 1 / 0, repeatType: "loop", repeatDelay: 1, type: "spring", stiffness: 20, damping: 15, mass: 2, scale: { type: "spring", stiffness: 10, damping: 5, mass: .1 } }, className: "rounded-[8px] px-5 py-2.5 relative ".concat("primary" === n ? "radial-gradient text-white" : "bg-[#fd1d1d] hover:bg-[#fd1d1d] text-white"), children: [(0, Me.jsx)("span", { className: "  tracking-wide font-medium h-full w-full block relative linear-mask", children: t }), (0, Me.jsx)("span", { className: "block absolute inset-0 rounded-md p-px linear-overlay" })] }) })] }) } function pl() { return (0, Me.jsxs)("div", { className: "relative h-screen full ", children: [(0, Me.jsx)("div", { className: "absolute inset-0 z-10 bg-transparent" }), (0, Me.jsx)("div", { className: "absolute bottom-[15%] w-full z-20 h-full", children: (0, Me.jsxs)("div", { className: "w-full h-full flex flex-col justify-end pb-8 max-w-[1440px] mx-auto px-[5%]", children: [(0, Me.jsxs)("h1", { className: "text-white font-bold text-[45px] leading-[50px]", children: ["Powering Crypto ", (0, Me.jsx)("br", { className: "hidden md:flex " }), "Adoption"] }), (0, Me.jsx)("p", { className: "text-white font-medium sm:text-lg text-base sm:w-[500px] w-full mt-[3%] mb-4", children: "An ERC-4337 toolkit for RWA and DePIN enhancing gasless transactions, social login, multichain support and much more, making DeFi accessible and secure" }), (0, Me.jsxs)("div", { className: "flex flex-wrap gap-4", children: [(0, Me.jsx)("a", { href: "https://app.magmarinfra.com/login", target: "_blank", rel: "noopener noreferrer", children: (0, Me.jsx)(fl, { text: "Enter Dapp" }) }), (0, Me.jsx)("a", { href: "https://drive.google.com/file/d/16DNG9GsCsFv2CIRognhU_jhXgQ6K9L-F/view", target: "_blank", rel: "noopener noreferrer", children: (0, Me.jsx)(fl, { text: "MagmarInfra LLC", variant: "secondary" }) })] })] }) }), (0, Me.jsx)("video", { src: "/video/Hero.mp4", autoPlay: !0, loop: !0, muted: !0, className: "absolute inset-0 z-0 object-cover pointer-events-none size-full" })] }) } const ml = [{ title: "Gasless Transactions", description: "Enable zero-gas transactions using ERC-4337 toolkit and Paymaster, making DeFi more accessible by removing transaction cost concerns.", src: "house.jpg", link: "/", imageUrl: "Vidz3.mp4" }, { title: "Account Abstraction ", description: "Provides multi-factor authentication (MFA) and customizable security settings through smart contract accounts.", src: "house.jpg", link: "/", imageUrl: "Vidz1.mp4" }, { title: "Modular Smart Accounts", description: "Deploy ERC-4337 compliant smart contract wallets with features like automated transactions, multi-signature security, and social recovery.", src: "house.jpg", link: "/", imageUrl: "Vidz2.mp4" }, { title: "Powering RWA & DePIN", description: "Supports Real World Asset (RWA) with gasless transactions and compliance features, while enabling DePIN through automated on-chain IoT interactions.", src: "house.jpg", link: "/", imageUrl: "Vidz4.mp4" }, { title: "Social Recovery", description: "Provides secure account recovery through trusted contacts if private key is lost, with multi-step verification process.", src: "house.jpg", link: "/", imageUrl: "Vidz5.mp4" }], gl = e => (e => e && "object" === typeof e && e.mix)(e) ? e.mix : void 0; function vl(e, t) { const n = function (e) { const t = vn((() => Do(e))), { isStatic: n } = (0, i.useContext)(Te); if (n) { const [, n] = (0, i.useState)(e); (0, i.useEffect)((() => t.on("change", n)), []) } return t }(t()), r = () => n.set(t()); return r(), De((() => { const t = () => Tn.preRender(r, !1, !0), n = e.map((e => e.on("change", t))); return () => { n.forEach((e => e())), In(r) } })), n } function yl(e, t, n, r) { if ("function" === typeof e) return function (e) { Lo.current = [], e(); const t = vl(Lo.current, e); return Lo.current = void 0, t }(e); const i = "function" === typeof t ? t : function () { const e = !Array.isArray(arguments.length <= 0 ? void 0 : arguments[0]), t = e ? 0 : -1, n = 0 + t < 0 || arguments.length <= 0 + t ? void 0 : arguments[0 + t], r = 2 + t < 0 || arguments.length <= 2 + t ? void 0 : arguments[2 + t], i = 3 + t < 0 || arguments.length <= 3 + t ? void 0 : arguments[3 + t], o = po(1 + t < 0 || arguments.length <= 1 + t ? void 0 : arguments[1 + t], r, { mixer: gl(r[0]), ...i }); return e ? o(n) : o }(t, n, r); return Array.isArray(e) ? bl(e, i) : bl([e], (e => { let [t] = e; return i(t) })) } function bl(e, t) { const n = vn((() => [])); return vl(e, (() => { n.length = 0; const r = e.length; for (let t = 0; t < r; t++)n[t] = e[t].get(); return t(n) })) } const xl = e => { let { i: t, title: n, description: r, imageUrl: o, src: a, url: s, color: l, progress: c, range: u, targetScale: d } = e; const h = (0, i.useRef)(null), f = yl(c, u, [1, d]); return (0, Me.jsx)("div", { ref: h, className: "sticky top-0 left-0 flex items-center justify-center w-full h-screen md:mt-5", children: (0, Me.jsxs)(hl.div, { style: { backgroundColor: l, scale: f, top: "calc(-5vh + ".concat(25 * t, "px)") }, className: "flex flex-col sm:inline items-center relative sm:h-[470px] h-fit w-full rounded-[25px] sm:p-[50px] p-[5%] origin-top border border-[#353637] overflow-hidden bg-gradient-to-br from-black via-black to-red-900/20", children: [(0, Me.jsx)("div", { className: "absolute inset-0  bg-black z-[40] rounded-[40px]" }), (0, Me.jsx)("video", { className: "md:absolute right-0 -top-[20px] lg:top-0  md:w-[45%] z-[50] w-[100%] object-cover md:object-contain", autoPlay: !0, muted: !0, loop: !0, playsInline: !0, children: (0, Me.jsx)("source", { src: "/video/".concat(o), type: "video/mp4" }) }), (0, Me.jsxs)("div", { className: "grid sm:grid-cols-2 grid-cols-1 items-center h-full relative z-[100]", children: [(0, Me.jsx)("div", { className: "col-span-1", children: (0, Me.jsxs)("div", { className: "flex flex-col", children: [(0, Me.jsx)("h2", { className: "sm:text-[40px] md:text-[30px] text-[24px] text-white font-bold leading-[40px] ", children: n }), (0, Me.jsx)("p", { className: "text-white sm:text-base text-sm my-[3%] max-w-[95%] newFont ", children: r })] }) }), (0, Me.jsx)("div", { className: "col-span-1", children: (0, Me.jsx)(hl.div, {}) })] })] }) }) }; const wl = new WeakMap; let kl; function Sl(e) { let { target: t, contentRect: n, borderBoxSize: r } = e; var i; null === (i = wl.get(t)) || void 0 === i || i.forEach((e => { e({ target: t, contentSize: n, get size() { return function (e, t) { if (t) { const { inlineSize: e, blockSize: n } = t[0]; return { width: e, height: n } } return e instanceof SVGElement && "getBBox" in e ? e.getBBox() : { width: e.offsetWidth, height: e.offsetHeight } }(t, r) } }) })) } function Al(e) { e.forEach(Sl) } function El(e, t) { kl || "undefined" !== typeof ResizeObserver && (kl = new ResizeObserver(Al)); const n = function (e, t, n) { var r; if ("string" === typeof e) { let i = document; t && (Sr(Boolean(t.current), "Scope provided, but no element detected."), i = t.current), n ? (null !== (r = n[e]) && void 0 !== r || (n[e] = i.querySelectorAll(e)), e = n[e]) : e = i.querySelectorAll(e) } else e instanceof Element && (e = [e]); return Array.from(e || []) }(e); return n.forEach((e => { let n = wl.get(e); n || (n = new Set, wl.set(e, n)), n.add(t), null === kl || void 0 === kl || kl.observe(e) })), () => { n.forEach((e => { const n = wl.get(e); null === n || void 0 === n || n.delete(t), (null === n || void 0 === n ? void 0 : n.size) || null === kl || void 0 === kl || kl.unobserve(e) })) } } const Cl = new Set; let Pl; function jl(e) { return Cl.add(e), Pl || (Pl = () => { const e = { width: window.innerWidth, height: window.innerHeight }, t = { target: window, size: e, contentSize: e }; Cl.forEach((e => e(t))) }, window.addEventListener("resize", Pl)), () => { Cl.delete(e), !Cl.size && Pl && (Pl = void 0) } } const Nl = 50, Ml = () => ({ time: 0, x: { current: 0, offset: [], progress: 0, scrollLength: 0, targetOffset: 0, targetLength: 0, containerLength: 0, velocity: 0 }, y: { current: 0, offset: [], progress: 0, scrollLength: 0, targetOffset: 0, targetLength: 0, containerLength: 0, velocity: 0 } }), Tl = { x: { length: "Width", position: "Left" }, y: { length: "Height", position: "Top" } }; function Il(e, t, n, r) { const i = n[t], { length: o, position: a } = Tl[t], s = i.current, l = n.time; i.current = e["scroll".concat(a)], i.scrollLength = e["scroll".concat(o)] - e["client".concat(o)], i.offset.length = 0, i.offset[0] = 0, i.offset[1] = i.scrollLength, i.progress = _i(0, i.scrollLength, i.current); const c = r - l; i.velocity = c > Nl ? 0 : bi(i.current - s, c) } const Ll = { Enter: [[0, 1], [1, 1]], Exit: [[0, 0], [1, 0]], Any: [[1, 0], [0, 1]], All: [[0, 0], [1, 1]] }, Rl = { start: 0, center: .5, end: 1 }; function Dl(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = 0; if (e in Rl && (e = Rl[e]), "string" === typeof e) { const t = parseFloat(e); e.endsWith("px") ? r = t : e.endsWith("%") ? e = t / 100 : e.endsWith("vw") ? r = t / 100 * document.documentElement.clientWidth : e.endsWith("vh") ? r = t / 100 * document.documentElement.clientHeight : e = t } return "number" === typeof e && (r = t * e), n + r } const zl = [0, 0]; function Ol(e, t, n, r) { let i = Array.isArray(e) ? e : zl, o = 0, a = 0; return "number" === typeof e ? i = [e, e] : "string" === typeof e && (i = (e = e.trim()).includes(" ") ? e.split(" ") : [e, Rl[e] ? e : "0"]), o = Dl(i[0], n, r), a = Dl(i[1], t), o - a } const Bl = { x: 0, y: 0 }; function Fl(e, t, n) { const { offset: r = Ll.All } = n, { target: i = e, axis: o = "y" } = n, a = "y" === o ? "height" : "width", s = i !== e ? function (e, t) { const n = { x: 0, y: 0 }; let r = e; for (; r && r !== t;)if (r instanceof HTMLElement) n.x += r.offsetLeft, n.y += r.offsetTop, r = r.offsetParent; else if ("svg" === r.tagName) { const e = r.getBoundingClientRect(); r = r.parentElement; const t = r.getBoundingClientRect(); n.x += e.left - t.left, n.y += e.top - t.top } else { if (!(r instanceof SVGGraphicsElement)) break; { const { x: e, y: t } = r.getBBox(); n.x += e, n.y += t; let i = null, o = r.parentNode; for (; !i;)"svg" === o.tagName && (i = o), o = r.parentNode; r = i } } return n }(i, e) : Bl, l = i === e ? { width: e.scrollWidth, height: e.scrollHeight } : function (e) { return "getBBox" in e && "svg" !== e.tagName ? e.getBBox() : { width: e.clientWidth, height: e.clientHeight } }(i), c = { width: e.clientWidth, height: e.clientHeight }; t[o].offset.length = 0; let u = !t[o].interpolate; const d = r.length; for (let h = 0; h < d; h++) { const e = Ol(r[h], c[a], l[a], s[o]); u || e === t[o].interpolatorOffsets[h] || (u = !0), t[o].offset[h] = e } u && (t[o].interpolate = po(t[o].offset, mo(r)), t[o].interpolatorOffsets = [...t[o].offset]), t[o].progress = t[o].interpolate(t[o].current) } function Vl(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; return { measure: () => function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e, n = arguments.length > 2 ? arguments[2] : void 0; if (n.x.targetOffset = 0, n.y.targetOffset = 0, t !== e) { let r = t; for (; r && r !== e;)n.x.targetOffset += r.offsetLeft, n.y.targetOffset += r.offsetTop, r = r.offsetParent } n.x.targetLength = t === e ? t.scrollWidth : t.clientWidth, n.y.targetLength = t === e ? t.scrollHeight : t.clientHeight, n.x.containerLength = e.clientWidth, n.y.containerLength = e.clientHeight }(e, r.target, n), update: t => { !function (e, t, n) { Il(e, "x", t, n), Il(e, "y", t, n), t.time = n }(e, n, t), (r.offset || r.target) && Fl(e, n, r) }, notify: () => t(n) } } const Ul = new WeakMap, Wl = new WeakMap, Hl = new WeakMap, Yl = e => e === document.documentElement ? window : e; function Xl(e) { let { container: t = document.documentElement, ...n } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = Hl.get(t); r || (r = new Set, Hl.set(t, r)); const i = Ml(), o = Vl(t, e, i, n); if (r.add(o), !Ul.has(t)) { const e = () => { for (const e of r) e.measure() }, n = () => { for (const e of r) e.update(Ln.timestamp) }, i = () => { for (const e of r) e.notify() }, o = () => { Tn.read(e, !1, !0), Tn.read(n, !1, !0), Tn.update(i, !1, !0) }; Ul.set(t, o); const l = Yl(t); window.addEventListener("resize", o, { passive: !0 }), t !== document.documentElement && Wl.set(t, (s = o, "function" === typeof (a = t) ? jl(a) : El(a, s))), l.addEventListener("scroll", o, { passive: !0 }) } var a, s; const l = Ul.get(t); return Tn.read(l, !1, !0), () => { var e; In(l); const n = Hl.get(t); if (!n) return; if (n.delete(o), n.size) return; const r = Ul.get(t); Ul.delete(t), r && (Yl(t).removeEventListener("scroll", r), null === (e = Wl.get(t)) || void 0 === e || e(), window.removeEventListener("resize", r)) } } function Ql(e, t) { kr(Boolean(!t || t.current), "You have defined a ".concat(e, " options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its `layoutEffect: false` option.")) } const ql = () => ({ scrollX: Do(0), scrollY: Do(0), scrollXProgress: Do(0), scrollYProgress: Do(0) }); function Zl(e) { return Zl = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Zl(e) } function Kl(e) { var t = function (e, t) { if ("object" != Zl(e) || !e) return e; var n = e[Symbol.toPrimitive]; if (void 0 !== n) { var r = n.call(e, t || "default"); if ("object" != Zl(r)) return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(e, "string"); return "symbol" == Zl(t) ? t : t + "" } function Gl(e, t, n) { return (t = Kl(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function Jl(e, t, n) { return Math.max(e, Math.min(t, n)) } class _l { advance(e) { var t; if (!this.isRunning) return; let n = !1; if (this.lerp) this.value = (r = this.value, i = this.to, o = 60 * this.lerp, a = e, function (e, t, n) { return (1 - n) * e + n * t }(r, i, 1 - Math.exp(-o * a))), Math.round(this.value) === this.to && (this.value = this.to, n = !0); else { this.currentTime += e; const t = Jl(0, this.currentTime / this.duration, 1); n = t >= 1; const r = n ? 1 : this.easing(t); this.value = this.from + (this.to - this.from) * r } var r, i, o, a; null !== (t = this.onUpdate) && void 0 !== t && t.call(this, this.value, n), n && this.stop() } stop() { this.isRunning = !1 } fromTo(e, t, n) { let { lerp: r = .1, duration: i = 1, easing: o = e => e, onStart: a, onUpdate: s } = n; this.from = this.value = e, this.to = t, this.lerp = r, this.duration = i, this.easing = o, this.currentTime = 0, this.isRunning = !0, null !== a && void 0 !== a && a(), this.onUpdate = s } } class $l { constructor() { let { wrapper: e, content: t, autoResize: n = !0, debounce: r = 250 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; Gl(this, "resize", (() => { this.onWrapperResize(), this.onContentResize() })), Gl(this, "onWrapperResize", (() => { this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight) })), Gl(this, "onContentResize", (() => { this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth) })), this.wrapper = e, this.content = t, n && (this.debouncedResize = function (e, t) { let n; return function () { let r = arguments, i = this; clearTimeout(n), n = setTimeout((function () { e.apply(i, r) }), t) } }(this.resize, r), this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize() } destroy() { var e, t; null !== (e = this.wrapperResizeObserver) && void 0 !== e && e.disconnect(), null !== (t = this.contentResizeObserver) && void 0 !== t && t.disconnect(), window.removeEventListener("resize", this.debouncedResize, !1) } get limit() { return { x: this.scrollWidth - this.width, y: this.scrollHeight - this.height } } } class ec { constructor() { this.events = {} } emit(e) { let t = this.events[e] || []; for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)r[i - 1] = arguments[i]; for (let o = 0, a = t.length; o < a; o++)t[o](...r) } on(e, t) { var n; return null !== (n = this.events[e]) && void 0 !== n && n.push(t) || (this.events[e] = [t]), () => { var n; this.events[e] = null === (n = this.events[e]) || void 0 === n ? void 0 : n.filter((e => t !== e)) } } off(e, t) { var n; this.events[e] = null === (n = this.events[e]) || void 0 === n ? void 0 : n.filter((e => t !== e)) } destroy() { this.events = {} } } const tc = 100 / 6; class nc { constructor(e, t) { let { wheelMultiplier: n = 1, touchMultiplier: r = 1 } = t; Gl(this, "onTouchStart", (e => { const { clientX: t, clientY: n } = e.targetTouches ? e.targetTouches[0] : e; this.touchStart.x = t, this.touchStart.y = n, this.lastDelta = { x: 0, y: 0 }, this.emitter.emit("scroll", { deltaX: 0, deltaY: 0, event: e }) })), Gl(this, "onTouchMove", (e => { const { clientX: t, clientY: n } = e.targetTouches ? e.targetTouches[0] : e, r = -(t - this.touchStart.x) * this.touchMultiplier, i = -(n - this.touchStart.y) * this.touchMultiplier; this.touchStart.x = t, this.touchStart.y = n, this.lastDelta = { x: r, y: i }, this.emitter.emit("scroll", { deltaX: r, deltaY: i, event: e }) })), Gl(this, "onTouchEnd", (e => { this.emitter.emit("scroll", { deltaX: this.lastDelta.x, deltaY: this.lastDelta.y, event: e }) })), Gl(this, "onWheel", (e => { let { deltaX: t, deltaY: n, deltaMode: r } = e; t *= 1 === r ? tc : 2 === r ? this.windowWidth : 1, n *= 1 === r ? tc : 2 === r ? this.windowHeight : 1, t *= this.wheelMultiplier, n *= this.wheelMultiplier, this.emitter.emit("scroll", { deltaX: t, deltaY: n, event: e }) })), Gl(this, "onWindowResize", (() => { this.windowWidth = window.innerWidth, this.windowHeight = window.innerHeight })), this.element = e, this.wheelMultiplier = n, this.touchMultiplier = r, this.touchStart = { x: null, y: null }, this.emitter = new ec, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, { passive: !1 }), this.element.addEventListener("touchstart", this.onTouchStart, { passive: !1 }), this.element.addEventListener("touchmove", this.onTouchMove, { passive: !1 }), this.element.addEventListener("touchend", this.onTouchEnd, { passive: !1 }) } on(e, t) { return this.emitter.on(e, t) } destroy() { this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, { passive: !1 }), this.element.removeEventListener("touchstart", this.onTouchStart, { passive: !1 }), this.element.removeEventListener("touchmove", this.onTouchMove, { passive: !1 }), this.element.removeEventListener("touchend", this.onTouchEnd, { passive: !1 }) } } class rc { constructor() { let { wrapper: e = window, content: t = document.documentElement, wheelEventsTarget: n = e, eventsTarget: r = n, smoothWheel: i = !0, syncTouch: o = !1, syncTouchLerp: a = .075, touchInertiaMultiplier: s = 35, duration: l, easing: c = e => Math.min(1, 1.001 - Math.pow(2, -10 * e)), lerp: u = !l && .1, infinite: d = !1, orientation: h = "vertical", gestureOrientation: f = "vertical", touchMultiplier: p = 1, wheelMultiplier: m = 1, autoResize: g = !0, __experimental__naiveDimensions: v = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.__isSmooth = !1, this.__isScrolling = !1, this.__isStopped = !1, this.__isLocked = !1, this.onVirtualScroll = e => { let { deltaX: t, deltaY: n, event: r } = e; if (r.ctrlKey) return; const i = r.type.includes("touch"), o = r.type.includes("wheel"); if (this.options.syncTouch && i && "touchstart" === r.type && !this.isStopped && !this.isLocked) return void this.reset(); const a = 0 === t && 0 === n, s = "vertical" === this.options.gestureOrientation && 0 === n || "horizontal" === this.options.gestureOrientation && 0 === t; if (a || s) return; let l = r.composedPath(); if (l = l.slice(0, l.indexOf(this.rootElement)), l.find((e => { var t, n, r, a, s; return (null === (t = e.hasAttribute) || void 0 === t ? void 0 : t.call(e, "data-lenis-prevent")) || i && (null === (n = e.hasAttribute) || void 0 === n ? void 0 : n.call(e, "data-lenis-prevent-touch")) || o && (null === (r = e.hasAttribute) || void 0 === r ? void 0 : r.call(e, "data-lenis-prevent-wheel")) || (null === (a = e.classList) || void 0 === a ? void 0 : a.contains("lenis")) && !(null === (s = e.classList) || void 0 === s ? void 0 : s.contains("lenis-stopped")) }))) return; if (this.isStopped || this.isLocked) return void r.preventDefault(); if (this.isSmooth = this.options.syncTouch && i || this.options.smoothWheel && o, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop(); r.preventDefault(); let c = n; "both" === this.options.gestureOrientation ? c = Math.abs(n) > Math.abs(t) ? n : t : "horizontal" === this.options.gestureOrientation && (c = t); const u = i && this.options.syncTouch, d = i && "touchend" === r.type && Math.abs(c) > 5; d && (c = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + c, Object.assign({ programmatic: !1 }, u ? { lerp: d ? this.options.syncTouchLerp : 1 } : { lerp: this.options.lerp, duration: this.options.duration, easing: this.options.easing })) }, this.onNativeScroll = () => { if (!this.__preventNextScrollEvent && !this.isScrolling) { const e = this.animatedScroll; this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - e), this.emit() } }, window.lenisVersion = "1.0.42", e !== document.documentElement && e !== document.body || (e = window), this.options = { wrapper: e, content: t, wheelEventsTarget: n, eventsTarget: r, smoothWheel: i, syncTouch: o, syncTouchLerp: a, touchInertiaMultiplier: s, duration: l, easing: c, lerp: u, infinite: d, gestureOrientation: f, orientation: h, touchMultiplier: p, wheelMultiplier: m, autoResize: g, __experimental__naiveDimensions: v }, this.animate = new _l, this.emitter = new ec, this.dimensions = new $l({ wrapper: e, content: t, autoResize: g }), this.toggleClassName("lenis", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = o || i, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll = new nc(r, { touchMultiplier: p, wheelMultiplier: m }), this.virtualScroll.on("scroll", this.onVirtualScroll) } destroy() { this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClassName("lenis", !1), this.toggleClassName("lenis-smooth", !1), this.toggleClassName("lenis-scrolling", !1), this.toggleClassName("lenis-stopped", !1), this.toggleClassName("lenis-locked", !1) } on(e, t) { return this.emitter.on(e, t) } off(e, t) { return this.emitter.off(e, t) } setScroll(e) { this.isHorizontal ? this.rootElement.scrollLeft = e : this.rootElement.scrollTop = e } resize() { this.dimensions.resize() } emit() { this.emitter.emit("scroll", this) } reset() { this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop() } start() { this.isStopped && (this.isStopped = !1, this.reset()) } stop() { this.isStopped || (this.isStopped = !0, this.animate.stop(), this.reset()) } raf(e) { const t = e - (this.time || e); this.time = e, this.animate.advance(.001 * t) } scrollTo(e) { let { offset: t = 0, immediate: n = !1, lock: r = !1, duration: i = this.options.duration, easing: o = this.options.easing, lerp: a = !i && this.options.lerp, onComplete: s, force: l = !1, programmatic: c = !0 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!this.isStopped && !this.isLocked || l) { if (["top", "left", "start"].includes(e)) e = 0; else if (["bottom", "right", "end"].includes(e)) e = this.limit; else { let n; if ("string" == typeof e ? n = document.querySelector(e) : (null == e ? void 0 : e.nodeType) && (n = e), n) { if (this.options.wrapper !== window) { const e = this.options.wrapper.getBoundingClientRect(); t -= this.isHorizontal ? e.left : e.top } const r = n.getBoundingClientRect(); e = (this.isHorizontal ? r.left : r.top) + this.animatedScroll } } if ("number" == typeof e) { if (e += t, e = Math.round(e), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : e = Jl(0, e, this.limit), n) return this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), void (null == s || s(this)); if (!c) { if (e === this.targetScroll) return; this.targetScroll = e } this.animate.fromTo(this.animatedScroll, e, { duration: i, easing: o, lerp: a, onStart: () => { r && (this.isLocked = !0), this.isScrolling = !0 }, onUpdate: (e, t) => { this.isScrolling = !0, this.velocity = e - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = e, this.setScroll(this.scroll), c && (this.targetScroll = e), t || this.emit(), t && (this.reset(), this.emit(), null == s || s(this), this.__preventNextScrollEvent = !0, requestAnimationFrame((() => { delete this.__preventNextScrollEvent }))) } }) } } } get rootElement() { return this.options.wrapper === window ? document.documentElement : this.options.wrapper } get limit() { return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"] } get isHorizontal() { return "horizontal" === this.options.orientation } get actualScroll() { return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop } get scroll() { return this.options.infinite ? (this.animatedScroll % (e = this.limit) + e) % e : this.animatedScroll; var e } get progress() { return 0 === this.limit ? 1 : this.scroll / this.limit } get isSmooth() { return this.__isSmooth } set isSmooth(e) { this.__isSmooth !== e && (this.__isSmooth = e, this.toggleClassName("lenis-smooth", e)) } get isScrolling() { return this.__isScrolling } set isScrolling(e) { this.__isScrolling !== e && (this.__isScrolling = e, this.toggleClassName("lenis-scrolling", e)) } get isStopped() { return this.__isStopped } set isStopped(e) { this.__isStopped !== e && (this.__isStopped = e, this.toggleClassName("lenis-stopped", e)) } get isLocked() { return this.__isLocked } set isLocked(e) { this.__isLocked !== e && (this.__isLocked = e, this.toggleClassName("lenis-locked", e)) } get className() { let e = "lenis"; return this.isStopped && (e += " lenis-stopped"), this.isLocked && (e += " lenis-locked"), this.isScrolling && (e += " lenis-scrolling"), this.isSmooth && (e += " lenis-smooth"), e } toggleClassName(e, t) { this.rootElement.classList.toggle(e, t), this.emitter.emit("className change", this) } } function ic() { const e = (0, i.useRef)(null), { scrollYProgress: t } = function () { let { container: e, target: t, layoutEffect: n = !0, ...r } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const o = vn(ql); return (n ? De : i.useEffect)((() => (Ql("target", t), Ql("container", e), Xl((e => { let { x: t, y: n } = e; o.scrollX.set(t.current), o.scrollXProgress.set(t.progress), o.scrollY.set(n.current), o.scrollYProgress.set(n.progress) }), { ...r, container: (null === e || void 0 === e ? void 0 : e.current) || void 0, target: (null === t || void 0 === t ? void 0 : t.current) || void 0 }))), [e, t, JSON.stringify(r.offset)]), o }({ target: e, offset: ["start start", "end end"] }); return (0, i.useEffect)((() => { const e = new rc; requestAnimationFrame((function t(n) { e.raf(n), requestAnimationFrame(t) })) })), (0, Me.jsx)("main", { ref: e, className: "relative flex items-center justify-center flex-col  -mt-[10%] px-[5%]", id: "offers", children: ml.map(((e, n) => { const r = 1 - .05 * (ml.length - n); return (0, Me.jsx)(xl, { i: n, ...e, progress: t, range: [.25 * n, 1], targetScale: r }, "p_".concat(n)) })) }) } const oc = n.p + "static/media/bg.6ec3205349cc3c90b87262679bdfb72f.svg", ac = e => { let { heading: t, subparagraph: n, paragraph: r } = e; return (0, Me.jsxs)("div", { className: "relative bg-[#3a3a3a] py-[5%] px-[4%] rounded-xl", style: { backgroundImage: "url(".concat(oc, ")"), backgroundSize: "cover", backgroundPosition: "center" }, children: [(0, Me.jsx)("h2", { className: "sm:text-4xl text-xl font-semibold text-white mb-2", children: t }), (0, Me.jsx)("p", { className: "sm:text-base text-sm text-white sm:mb-4 sm:mt-[7%]", children: n }), (0, Me.jsx)("p", { className: "sm:text-base text-sm text-white sm:mb-4 mt-[5%] sm:mt-[7%]", children: r })] }) }, sc = () => { const [e, t] = (0, i.useState)(0), n = (0, i.useRef)(); (0, i.useEffect)((() => { n.current.focus() }), []); const r = [{ title: "Gas Sponsorship", heading: "Gas Sponsorship", subparagraph: "Gas Sponsorship removes the obstacle of gas fees, making it easier for new users to engage with blockchain technology. By eliminating this financial barrier, users can interact with decentralized applications (dApps) without worrying about the cost of transactions, fostering wider adoption and a smoother onboarding experience.", paragraph: "This innovative solution allows dApps to cover transaction costs on behalf of their users. With flexible sponsorship models, dApps can tailor their approach to fit different scenarios, ensuring they can support their user base effectively. This flexibility not only enhances user experience but also encourages more robust interaction within the blockchain ecosystem.", background: "GasSponsorship.png" }, { title: "Self-Custody", heading: "Self-Custody", subparagraph: "Self-Custody allows you to maintain full control over your digital assets, ensuring that you are the sole owner and manager of your funds. By eliminating the need for third-party custodians or intermediaries, you retain direct access to your cryptocurrencies, giving you complete autonomy over transactions and holdings.", paragraph: "This approach enhances security and privacy for your crypto holdings, as it reduces the risks associated with external breaches and data leaks. With self-custody, your assets are safeguarded from potential threats posed by third-party custodians, providing a more secure and private method to manage your digital wealth.", background: "Selfcustody.png" }, { title: "ERC-4337 Support", heading: "ERC-4337 Support", subparagraph: "ERC-4337 Support leverages the latest account abstraction standard to enhance the user experience in the blockchain ecosystem. This standard simplifies interactions with blockchain accounts, making them more intuitive and user-friendly without compromising on security. By abstracting account management complexities, users can enjoy a seamless experience that aligns more closely with traditional financial systems, thereby lowering the barrier to entry for newcomers.", paragraph: "In addition to simplifying the user experience, ERC-4337 enables advanced features such as recovery options and spending limits. These features provide added layers of security and flexibility, allowing users to set predefined parameters for account usage and recover their accounts in case of loss. This enhanced functionality ensures that users can manage their digital assets with greater confidence and control, fostering a more secure and adaptable blockchain environment.", background: "ERC-4337Support.png" }, { title: "Batch Transactions", heading: "Batch Transactions", subparagraph: "Batch transactions allow users to execute multiple operations in a single transaction, optimizing both time and resources. This method significantly saves on gas fees and helps to reduce blockchain congestion by bundling several actions together, ensuring smoother and more efficient network performance.", paragraph: "In addition to cost efficiency, batch transactions streamline complex DeFi interactions by simplifying the process of executing multiple smart contract operations simultaneously. This not only enhances the user experience but also contributes to a more robust and scalable decentralized finance ecosystem.", background: "BatchTransactions.png" }, { title: "Social Login", heading: "Social Login", subparagraph: "Social Login simplifies the onboarding process by allowing users to sign in using their existing social media accounts, eliminating the need to create new usernames and passwords. This user-friendly approach enhances convenience and reduces friction, making it easier for individuals to access services without the hassle of remembering complex seed phrases or additional login credentials.", paragraph: "This feature seamlessly integrates with popular platforms such as Google, Facebook, and Twitter, providing a smooth and secure login experience. By leveraging trusted social media networks, Social Login ensures a quick and reliable authentication process, fostering a more engaging and accessible user experience across various applications and websites.", background: "Social Login.png" }, { title: "Modular Smart Contracts", heading: "Modular Smart Contracts", subparagraph: "Modular Smart Contracts offer a flexible and upgradeable wallet architecture, enabling users to adapt and enhance their wallets seamlessly. This approach allows for the easy addition of new features and capabilities, ensuring that users can customize their wallets to meet their specific needs and preferences without disrupting the existing functionality. The modular nature of these contracts ensures that each component operates independently, allowing for targeted upgrades and modifications.", paragraph: "Moreover, this architecture is designed to be future-proof, safeguarding your wallet against the rapid evolution of blockchain technology. As new advancements and innovations emerge, modular smart contracts enable swift integration of these developments, keeping your wallet up-to-date and secure. This proactive adaptability ensures that users remain at the forefront of technological progress, maintaining optimal functionality and security in an ever-changing blockchain landscape.", background: "ModularSmartContracts.png" }, { title: "Multi-Chain Support", heading: "Multi-Chain Support", subparagraph: "Multi-chain support enables the management of assets across multiple blockchain networks, providing users with unparalleled flexibility and control over their digital holdings. This feature simplifies the complexity of interacting with different blockchains, ensuring that users can efficiently and securely handle their assets without needing to switch between various platforms or interfaces.", paragraph: "With seamless cross-chain transactions and interactions, users can effortlessly transfer and manage their assets across different blockchain ecosystems. The unified interface integrates diverse crypto ecosystems into a single, cohesive platform, streamlining the user experience and enhancing overall efficiency. This holistic approach to multi-chain support empowers users to maximize their engagement and potential within the crypto space.", background: "Multi-chain Support.png" }, { title: "Easy User Onboarding", heading: "Easy User Onboarding", subparagraph: "Magmar allows users to integrate social login into your games simplifying the process of onboarding new users to the platform. This cuts out the account creation process removing the biggest hurdle in onboarding new gamers to the platform.", paragraph: "Additionally, when the user interface is governed by smart contracts, you don\u2019t need to remember long seed phrases. Even when you forget your password, you can easily recover your account by making changes to the code.", background: "EasyUserOnboarding.png" }]; return (0, Me.jsx)("div", { className: "px-[5%] ", id: "features", children: (0, Me.jsxs)("div", { className: "grid sm:grid-cols-5 grid-cols-1 sm:gap-4", children: [(0, Me.jsx)("div", { className: "col-span-2 sm:mb-0 mb-4", children: (0, Me.jsx)(ac, { heading: r[e].heading, paragraph: r[e].paragraph, subparagraph: r[e].subparagraph }) }), (0, Me.jsx)("div", { className: "col-span-3", children: (0, Me.jsxs)("div", { className: "grid sm:grid-cols-3 grid-cols-1 gap-4", children: [(0, Me.jsx)("div", { className: "col-span-1 space-y-4", children: r.slice(0, 3).map(((r, i) => (0, Me.jsxs)("div", { onClick: () => t(i), ref: 0 === i ? n : null, className: "relative  cursor-pointer  w-full sm:h-[250px] h-[40px]   uppercase sm:text-[20px] font-semibold  rounded-[16px] ".concat(e === i ? " text-white border border-[#fd1d1d]" : " text-white"), children: [(0, Me.jsxs)("h5", { className: "absolute sm:top-[4%] top-[20%] left-[4%] z-[10] ", children: [" ", r.title] }), (0, Me.jsx)("img", { className: " absolute md:flex hidden  left-0 w-full h-full object-cover rounded-[16px]", src: r.background, alt: "background" })] }, i))) }), (0, Me.jsx)("div", { className: "col-span-1 space-y-4 sm:mt-[50%]", children: r.slice(3, 6).map(((n, r) => (0, Me.jsxs)("div", { onClick: () => t(r + 3), className: "relative cursor-pointer  w-full sm:h-[250px] h-[40px] uppercase sm:text-[20px] font-semibold rounded-[16px] hover:border-[2px] hover:border-[#3a3a3a] ".concat(e === r + 3 ? " text-white border border-[#fd1d1d]" : "text-white"), children: [(0, Me.jsxs)("h5", { className: "absolute sm:top-[4%] top-[20%] left-[4%] z-[10] ", children: [" ", n.title] }), (0, Me.jsx)("img", { className: "absolute md:flex hidden  left-0 w-full h-full object-cover rounded-[16px]", src: n.background, alt: "background" })] }, r + 3))) }), (0, Me.jsx)("div", { className: "col-span-1 space-y-4", children: r.slice(6, 8).map(((n, r) => (0, Me.jsxs)("div", { onClick: () => t(r + 6), className: "relative cursor-pointer  w-full sm:h-[250px] h-[40px] uppercase sm:text-[20px] font-semibold rounded-[16px] hover:border-[2px] hover:border-[#3a3a3a] ".concat(e === r + 6 ? " text-white border border-[#fd1d1d]" : "text-white"), children: [(0, Me.jsxs)("h5", { className: "absolute sm:top-[4%] top-[20%] left-[4%] z-[10] ", children: [" ", n.title] }), (0, Me.jsx)("img", { className: "absolute md:flex hidden  left-0 w-full h-full object-cover rounded-[16px]", src: n.background, alt: "background" })] }, r + 6))) })] }) })] }) }) }; var lc = n(751), cc = n(173), uc = n.n(cc), dc = n(381), hc = n.n(dc), fc = ["accept", "acceptCharset", "accessKey", "action", "allowFullScreen", "allowTransparency", "alt", "async", "autoComplete", "autoFocus", "autoPlay", "capture", "cellPadding", "cellSpacing", "challenge", "charSet", "checked", "cite", "classID", "className", "colSpan", "cols", "content", "contentEditable", "contextMenu", "controls", "controlsList", "coords", "crossOrigin", "data", "dateTime", "default", "defer", "dir", "disabled", "download", "draggable", "encType", "form", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "headers", "height", "hidden", "high", "href", "hrefLang", "htmlFor", "httpEquiv", "icon", "id", "inputMode", "integrity", "is", "keyParams", "keyType", "kind", "label", "lang", "list", "loop", "low", "manifest", "marginHeight", "marginWidth", "max", "maxLength", "media", "mediaGroup", "method", "min", "minLength", "multiple", "muted", "name", "noValidate", "nonce", "open", "optimum", "pattern", "placeholder", "poster", "preload", "profile", "radioGroup", "readOnly", "rel", "required", "reversed", "role", "rowSpan", "rows", "sandbox", "scope", "scoped", "scrolling", "seamless", "selected", "shape", "size", "sizes", "span", "spellCheck", "src", "srcDoc", "srcLang", "srcSet", "start", "step", "style", "summary", "tabIndex", "target", "title", "type", "useMap", "value", "width", "wmode", "wrap"], pc = ["about", "datatype", "inlist", "prefix", "property", "resource", "typeof", "vocab"], mc = ["onCopy", "onCut", "onPaste", "onCompositionEnd", "onCompositionStart", "onCompositionUpdate", "onKeyDown", "onKeyPress", "onKeyUp", "onFocus", "onBlur", "onChange", "onInput", "onInvalid", "onReset", "onSubmit", "onClick", "onContextMenu", "onDoubleClick", "onDrag", "onDragEnd", "onDragEnter", "onDragExit", "onDragLeave", "onDragOver", "onDragStart", "onDrop", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseOut", "onMouseOver", "onMouseUp", "onPointerDown", "onPointerMove", "onPointerUp", "onPointerCancel", "onGotPointerCapture", "onLostPointerCapture", "onPointerEnter", "onPointerLeave", "onPointerOver", "onPointerOut", "onSelect", "onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart", "onScroll", "onWheel", "onAbort", "onCanPlay", "onCanPlayThrough", "onDurationChange", "onEmptied", "onEncrypted", "onEnded", "onError", "onLoadedData", "onLoadedMetadata", "onLoadStart", "onPause", "onPlay", "onPlaying", "onProgress", "onRateChange", "onSeeked", "onSeeking", "onStalled", "onSuspend", "onTimeUpdate", "onVolumeChange", "onWaiting", "onLoad", "onError", "onAnimationStart", "onAnimationEnd", "onAnimationIteration", "onTransitionEnd", "onToggle"], gc = /data-([a-zA-Z0-9\-]*)/, vc = /aria-([a-zA-Z0-9\-]*)/; const yc = function (e, t, n) { void 0 === e && (e = {}), void 0 === t && (t = []), void 0 === n && (n = []); var r = Object.assign({}, e), i = Object.keys(r).filter((function (e) { return -1 === t.indexOf(e) && (n.indexOf(e) > -1 || (-1 !== fc.indexOf(e) || (-1 !== pc.indexOf(e) || (!!gc.test(e) || (!!vc.test(e) || -1 !== mc.indexOf(e)))))) })); return Object.keys(r).forEach((function (e) { -1 === i.indexOf(e) && delete r[e] })), r }; function bc(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, r) } return n } function xc(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? bc(Object(n), !0).forEach((function (t) { wc(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bc(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } function wc(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function kc(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function Sc(e, t) { return Sc = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e }, Sc(e, t) } var Ac = function (e) { var t, n; function r(t) { var n; return (n = e.call(this, t) || this).onScrollThrottled = hc()(n.onScroll.bind(kc(n)), t.throttleScroll, { trailing: !1 }), n.onResizeThrottled = hc()(n.onResize.bind(kc(n)), t.throttleResize, { trailing: !1 }), n.state = { inViewport: !1, progress: 0, lastScrollPosition: null, lastScrollTime: null }, n } n = e, (t = r).prototype = Object.create(n.prototype), t.prototype.constructor = t, Sc(t, n); var o = r.prototype; return o.componentDidMount = function () { addEventListener("resize", this.onResizeThrottled), addEventListener("scroll", this.onScrollThrottled), this.props.triggerOnLoad && this.checkStatus() }, o.componentDidUpdate = function (e, t) { e.throttleScroll !== this.props.throttleScroll && (removeEventListener("scroll", this.onScrollThrottled), this.onScrollThrottled = hc()(this.onScroll.bind(this), this.props.throttleScroll, { trailing: !1 }), addEventListener("scroll", this.onScrollThrottled)), e.throttleResize !== this.props.throttleResize && (removeEventListener("resize", this.onResizeThrottled), this.onResizeThrottled = hc()(this.onResize.bind(this), this.props.throttleResize, { trailing: !1 }), addEventListener("resize", this.onResizeThrottled)) }, o.componentWillUnmount = function () { removeEventListener("resize", this.onResizeThrottled), removeEventListener("scroll", this.onScrollThrottled) }, o.onResize = function () { this.checkStatus() }, o.onScroll = function () { this.checkStatus() }, o.checkStatus = function () { var e = this.props, t = e.containerRef, n = e.onEnter, r = e.onExit, i = e.onProgress, o = this.state, a = o.lastScrollPosition, l = o.lastScrollTime, c = s.findDOMNode(this.element).getBoundingClientRect(), u = "string" === typeof t ? document.querySelector(t) : t, d = t === document.documentElement ? Math.max(t.clientHeight, window.innerHeight || 0) : u.clientHeight, h = c.top <= d && c.bottom >= 0, f = window.scrollY, p = a && l ? Math.abs((a - f) / (l - Date.now())) : null; if (h) { var m = Math.max(0, Math.min(1, 1 - c.bottom / (d + c.height))); return this.state.inViewport || (this.setState({ inViewport: h }), n({ progress: m, velocity: p }, this)), i({ progress: m, velocity: p }, this), void this.setState({ lastScrollPosition: f, lastScrollTime: Date.now() }) } if (this.state.inViewport) { var g = c.top <= d ? 1 : 0; this.setState({ lastScrollPosition: f, lastScrollTime: Date.now(), inViewport: h, progress: g }), i({ progress: g, velocity: p }, this), r({ progress: g, velocity: p }, this) } }, o.render = function () { var e = this, t = this.props, n = t.children, r = t.component; return i[i.isValidElement(r) ? "cloneElement" : "createElement"](r, xc(xc({}, yc(this.props, ["onProgress"])), {}, { ref: function (t) { e.element = t } }), n) }, r }(i.Component); Ac.propTypes = { component: uc().oneOfType([uc().element, uc().node]), containerRef: uc().oneOfType([uc().object, uc().string]), throttleResize: uc().number, throttleScroll: uc().number, triggerOnLoad: uc().bool, onEnter: uc().func, onExit: uc().func, onProgress: uc().func }, Ac.defaultProps = { component: "div", containerRef: "undefined" !== typeof document ? document.documentElement : "html", throttleResize: 100, throttleScroll: 100, triggerOnLoad: !0, onEnter: function () { }, onExit: function () { }, onProgress: function () { } }; const Ec = Ac; function Cc() { const [e, t] = (0, i.useState)(!1); return (0, Me.jsx)(Ec, { onEnter: () => t(!0), onExit: () => t(!1), children: (0, Me.jsx)("div", { className: " mt-[2%]  sm:px-[10%]  ", children: (0, Me.jsxs)("div", { className: "grid grid-cols-2   items-center", children: [(0, Me.jsxs)("div", { className: "col-span-1 flex flex-col items-center ", children: [(0, Me.jsxs)("h1", { className: "text-white sm:text-[70px] font-semibold text-[40px]", children: [e && (0, Me.jsx)(lc.Ay, { start: 0, end: 50, duration: 2, delay: 0 }), "M"] }), (0, Me.jsx)("h5", { className: "text-white sm:text-base text-sm", children: "UserOps" })] }), (0, Me.jsxs)("div", { className: "col-span-1 flex  flex-col items-center", children: [(0, Me.jsxs)("h1", { className: "text-white sm:text-[70px] font-semibold text-[40px]", children: [e && (0, Me.jsx)(lc.Ay, { start: 0, end: 1, duration: 2, delay: 0 }), ".2M"] }), (0, Me.jsx)("h5", { className: "text-white sm:text-base text-sm", children: "Smart Accounts" })] }), (0, Me.jsxs)("div", { className: "mt-5 col-span-1 flex flex-col items-center", children: [" ", (0, Me.jsxs)("h1", { className: "text-white sm:text-[70px] font-semibold text-[40px]", children: [e && (0, Me.jsx)(lc.Ay, { start: 0, end: 2, duration: 2, delay: 0 }), "+"] }), (0, Me.jsx)("h5", { className: "text-white sm:text-base text-center text-sm", children: "Users Onboarded" })] }), (0, Me.jsxs)("div", { className: "mt-5 col-span-1 flex flex-col items-center", children: [(0, Me.jsxs)("h1", { className: "text-white sm:text-[70px] font-semibold text-[40px]", children: [e && (0, Me.jsx)(lc.Ay, { start: 0, end: 12, duration: 2, delay: 0 }), "+"] }), (0, Me.jsx)("h5", { className: "text-white sm:text-base text-sm", children: "Volume" })] })] }) }) }) } function Pc() { return (0, Me.jsx)("div", { className: " pb-[10%]  px-[5%]", children: (0, Me.jsxs)("div", { className: "h-[400px] w-full  relative", children: [(0, Me.jsx)("img", { className: "absolute w-full h-full object-cover rounded-[30px]", src: oc, alt: "" }), (0, Me.jsx)("div", { className: " px-[5%] absolute z-[10] flex items-center h-full  text-white", children: (0, Me.jsxs)("div", { className: "grid items-center grid-cols-1 sm:grid-cols-2", children: [(0, Me.jsx)("div", { className: "col-span-1", children: (0, Me.jsx)("h2", { className: "sm:text-[50px] text-[24px] font-bold sm:leading-[50px] leading-[35px]", children: "We set standards for seamless blockchain transactions, so you can scale with effortless UX" }) }), (0, Me.jsx)("div", { className: "w-full col-span-1 ", children: (0, Me.jsx)(Cc, {}) })] }) })] }) }) } var jc = n(818); const Nc = "data:image/png;base64,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", Mc = "data:image/png;base64,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", Tc = "data:image/png;base64,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", Ic = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIsAAAB1CAYAAAB+gRKWAAAACXBIWXMAAAsSAAALEgHS3X78AAASDUlEQVR4nO2deXwT17XH74xG62jzJhljYxuDzWYWG5uEACn7ZghbCPtaEgKkSZuXpPk8krx0ycvS1742gbTw4gAFmqRsgQJJS6Gh7ASCZVaz2WAbS14kWbtGmulnlDivISzSzL0zI6Pv37rnnKv5fWa595xzMYZhQIIE0YAn/qUE0ZIQS4KoSYglQdQQD9JfpcBxrIuGzMknNT1y1OoumSpVdrpSmZkqV5gMBJFklMv1GAAqAID8myFUiGF8raFQq52iWhqDQZs1GKi96fPXXPN5r1R5vOeueD03RJ6WYLTrF9wMlco4KDl5cH+dflCxQf9wN1Lbl8AwHUwfvnDYcd7t/upkq/Pol07nocN2x6EWKuiC6UMqtDux9DcYeoxLMz02PCVlfDeNZgDAMEHvnmGGoSpcrYf3NTfv3tvYuOO8231FSP8oaRdiYe8gszIy5sxI77AwS6UqkkBIbTDn3O5jH92qL/9zQ8NHdopySyMsbsS1WAYnJ/dZmJm5fHRK6iwCw0gJhHRXfOGwc5vVuqG8rnbVWZfrkkTDvCdxKZayNNOjP8nNfaWnVjuMnYMEQooeBtCHHPY9v66+/sZhu/1ovIQN4k0sA5OSit7omv9O969FEu8wR+z23a9eufxipct1IR7mEhdiyVSpTCvzuvzyMZNpIY5hMgmEBA32hfhPt26tfuv6tddtgYBdyrFKWixyHMdXdOr0zLPZOT9Ty2R6CYSEDFco1PzW9Wsvrb158wOpxihZsXTRkJ1W9ejxx756/RAJhCMYRx2OPcvPn1tU5/dbpRabJMUyv2PHOa936fqeWiYzSCAcwXGGqMaXq6qe3NrQsENKcUlKLFqCUP1PQbf3JpnNiyUQjtgwf6yv+9+Vly+/6A+HQ1IISDJiyVarMzb27rMrnySltKgmOhWtrQfnVlqmWAOBZrFjkYRYivSGwg29e+9OUyiyRA9GgtT6/VWzKyrGX/SIu3UgulhGp6YOf79nzy2kjDCKGojEcVCUbeHZyglH7PYTYkUqqlimpaeX/a57j60yDFOIFkQcEaBpz5KzleM/b2r6QoyoRRPLRJN59Ps9euwgcFwlSgBxij8cbl1wtnLsgebmI0LPQBSxjE5NHfZ/vQp3KXBcI7jzdoAnHHLMsVhGHbHbTwo5G8HFUmowFm3p1+8LJY5rBXXczmBXfB87fWrgObe7SqiZCZqD20mtzigvLPw0IRT+6AgiZX3v3jtNCmWSUD4FEwu74La+sPe2NIUiUyifXMBIEqjGjgHqCRMAniTYdeBElkpdUF5Y+LESxwXZXBXsMfRBr8LyMpNpoSDOOMIKJXn1akBkfa1n2m4HzU8vA7TNJuWwwYa6ul+9cOniC6j9CHJnWZyZOV/qQmHRPvXUt0JhYe8s+p/8WNSYomFeRsfnp5jTJ6D2g1ws3Uht3it5Xd5F7YcvRH4+UI8b+z0rytJSoBw4UNrBYwB7syC/PEulTkfpBrlYft2t21q1TAa1/AIFuqeeBBh+579D++QSAGTSzrkyEPLUtwoK3kPpA6lYlnXKXlpsMAxF6QMGykceAYp+/e5qiejUCWgmT5b6NMDwlJQpMzp0mIbKPrIX3DyNJmt/Sek5ldTvKkolSF33IZCZzff8Ge31gub5CwDdLPrm7z1xhUKNg44f696AYJca2Z1lZV7ef0teKAAAzdSp9xUKC67RAO2CBYLExAcdQaS9lNv5VRS2kYil1GDsNzY1bSYK2zDBDAZAzngiaouqMaMBkZsr9WmBGR06LO2j1+fBtotELCvz8t7EMEzyHRq0CxcAXBv9YjImkwHtsqeRxgQDHMMUz+fk/hy6XdgGR6SkDh5gNI6CbRc2suxsoB4/PmaryuJi6X9KAwBGpaZML9Lru8O0CV0sz+XkvAbbJgp0K1ZE7hRciNxdFNJOwcEAJns+N/e/YNqEKpZBSUkPlRgMw2HaRIFy8GCgLOae6ktkZADy8celPMUIw1NSphXqdAWw7EEVy6LMzOUw7SGBfe9Y8kPeljUzZwDMKO1MUAxg+MKOmctg2YMmFpNCmTwqJXUqLHuoUJeNB0Qm/43vyKf0/HlSnea3TDKb5ugIQg3DFjSxTO+QPluO41CCQgWm00JdK1GXlQFZTo7UpvkdSBmRPMlkngLDFjSxTDOnz4ZlCxXa+QsAboBX5Bj5lF4k+c10MMVsngXDDhSxFJBkbjdSWwLDFioin8oT4e/is5/ReGqqVKZ5RwYYjSPMSmUyXztQxDLZnD4Dw6TdJlX39FKAEfDby7E71fLCXtDtwoQttZlsMvN+n4RygcelpUl6S1ZRVBTJS0GFLEXadxaWMWmpvK8Rb7FkqFRpBRqymK8dZGDY1/koCGGkUbd+T0r0hh8YCDmvDxDeYhmSlDQMSPgRxH6xyPPzkfoI19YhtQ8DAsfVDxmNj/Axxfsilxr4BYASTKsF2sWLkPqgfT5AVVaKPdWoKDUYBvEZz1ss/fT6AXxtoIKcPRvgerTdxXw7dwHG7xdzmlFTbNDzenHjJRa1TCbP12h687GBCllGBtBMQfveTTudwLNpk5jTjIlCra4/n/G8xFJAkvlSLWxnHz+YXB7FL7nDCoVxx0/TbC1BpOZpNJyzF3mJpYtG043PeFTIe/YEykcfReojVF8PvJ/uFHOaXMDySdLEdTAvsXRWa7rCmAFUcBzonnv2rmUdsHCvWQMARUlu+veji0bDeVGI1z/aUaXM5jMeBeoxY4A8D3r66XcIVlaCwMF/ij1VTmSp1JwLuHmKRdURygwggalUgFwwH6kPJhwGrneR1nIhJUul4vx5yEssKXLF/WsoBEQz4wkgQ7yp59u7F4SuxO8RQmkKhTgvuEkEwXsnExa42QTI6dOR+qA9HuAp/1DIaUEnWc59yZ+XWKRURKZbujTyGEKJ9+NPAO1wiD1VXqhxXMl1PC+xGAhCEmss8sJCoByCtsV/uLEReLdsiXkcu+WAqaWTQGiUc1984pXggQEM7apXVEFgQLd8GcAwtGdUuVatjm1ZH8eB/qWXgGrEcABoGvh27pTEizGbxM11bNyf66waNgz5rnLQYgGBgwdjGkPOnQPUI0dERMymX7JdGNj2Y/EML7HQgBF3VUqhQJ4Dy3aZcP9hTUxjZFlZgJz1/bRX3ZIlAEO8sXk/aMDQXMfyEktrKOTjM54v5MyZQNahA1If/v37AXUhtlPpdMuX33FfCjcaI+mdYuKkuC878xKLNxxuFWveuMkEyJkzkPpgKAq4PyiPaYyipAQoS++eu64aNQrIu0MtQY4JTzjMOZ+Cl1gcIaqFV+Q8YB8/GOJ6Y+8nfwZ0Q0P0A2QyoFv61D1/wr7DiNmJwR6iOD8NeImlKUiJcjQbUVAAVCNGIPURttmAe+PGmMZopk2Nqn+LomdPoBo5kkd03LEFgy6ug3mJpc7vFyX59F7NAmHh/nAdAIFA1NbwlGRAzou+nFX7w8WRFmVCc9Pv5/zqwOsfrw34a4SerHLQIKDo2xepD+rqVeD/299iGqNdtBjgMSy+ydLSgHbuXA7R8eOGz8/5OGBeYrnu9Ql2yEAEpRLoVqBt1BD5VH7/95GFtGiJPBZHx96/SDP98UilpJBc9XqauLrjJZYrXo+gJ52T06YBmYlzoldUBI8eBcHTp2Mao1v2NKfHIlsheb8XYsgwFz0ezr3leYnlosdzJUTTXsQTjMD2QtHE0CyQC0wwCFyr349pJLuCrCgs5OxTUVoKFP155VFHjYOirDU+H+ekYV5iCdJ0+KLHc4aPjWiJNAskSaQ+vFu3gXB9fdS/j9QlLePXKwf7Zm8LIKjDvh2Ly/Uln/G8PylOtbYe52vjfshysoF63DikPujWVuDZvDmmMeTsWUCWzP+YGSI7G2imQGmhck++4nmteIvluNNxiK+N+6Ff8QznZoHR4tm4CTAeT9S/Z7cZYLZoJ+fNRd66g++14i2Ww3b7PxiGQVYZzuapKIru3lcfBqEbN4B3R2wn+WvZFh4QV5AjbccQFvAHadpzzOE8yscGb7E0BAItZ91uNI8itrMSu3iFEoaJ5KqAUPR6j7TweAR+ibdq+HBAdIPWXPI7HHM49nnCoehXGe8AlGXQvU2N22HYuR31hDIozQLvReD4CRA8GcMhpuzn7jMrkCRbRV52l6LZN9rdyP8aQRHLdqv1Y4ZhwjBstREp60C8wvn1p/KqmMawXbkJhAtpit6FQPkDuNWUIZr2/aXRJg2xXPN6aytcrsMwbLWhHDoUyBAfaOnZtDnm3ioaBH3pboddfITJIYf986ZgkHc6CbTduG1WK9R2ArJktFUmbFITlw4IuBH9iax4Ety5b22Ac22giWWLteEjfzgMraWA/8ABwPjgJ+KxtT+t774HnL/4ZUz7P2349sW2wcgF3+7d0Gw5KMq2q9EGpYIf2rJhczDY+vuevT6abDbz73XO5pPU1wP7Cy8CzRPTI4dHYXJFJJM/NhjAsILwB0C4qREEKyzAv28fYFycUzqAe81awLS6gKK4CGA63TfrP3xfdplIWSzjbAX+w4eBbzu874Wt1oZ1vnA4CMMW1GPvSg3GvruKi05zuKoJEEAzTGjIieP5lz2e6zCsQ80gOuF0nDlid8C7hybgxV8abRsvQxIKQFE39E719VeBUMfQJ7gr7F3lN9XVv4D5D0EXyxG7/auDdvunsO0miI2dNtuG8273VZh/G5Kjevvo9N0/69/fgmMY+n33BN+DomnvoOPHC6p93lqY/w6SrOcKV+uFHTZrbAU3CaCxvr7ud7CFAlAeAp6pUpkPDnjoPCmTSaaHy4NAUzBYO/j48Z4tFP8V29tBVk9R6/dbX79y+Ueo7Cf4PgwAzE+rLi1BIRSAuovC+rq6TQdbWnah9JHg/9lls27YZbN9huovQfYYaiNHren495ISi1ZCLcXaI83BYN3Qkyd6WwMBZCXFyPuzVPu8dS9XVS1hV7RR+3pQoRkm/NzFC/NQCgUI1cznk4Zb2zbfqv+tEL4eRFbfuPHaX5ua9qOeOvLHUBsqmYzY3q/f50V6wzBBHD4gHGhp3j7HYpkaomnkF1IwsbCwhzruKe5/LFOlkl4b9zjkssdzpuz0qcEOihLktAlBe8qxz9T5lZYJ7lBItL4u7YUWKlg/r9IyUSihADEaEJ51uS7NrbSM9YbDTqF9txfYhKYnzpwZec3rvSnklETpVnnEbj+x+GzlOL+IbcbiFXco1DTXYhlpcbnOCz0F0Vqb7m9uPrLk3NkJPoipmO0dVyjUMrfSMvqE02ERY6qCvuDeiYFJSSXlvQp3Jcnlkjo0QmpYA4GaOZaKcWLcUdoQXSws+STZeXOfPnuyVGo05XhxzmWP56vZloqyGp8v+hYPCJBEh+0qj+fauFOnBp5udR6QQDiS4p/2lp1lp08NEVsoQErt2G2BQMuk06dHraurfYdJpGVGlvDfral+ZUZFxSQhP4/vhSQeQ7fzmMk8/u2Cgg+MD+h7jC0QqPnxxYsL9jU3/UMC4XyLJMXCYlIqk9/OL/jt2LTU2Q9KaQnDMPRWq3XNystVL9opintxEyIkK5Y2Hk9Pn/zzrvmrkuRytE36RcYaCFT/tOrSk3saG9GXPHJE8mIBkaPaFLr/yM35z3kZHZ+VS/TQca6wTXbW1t58+zfV1e+4RD44437EhVja6EqSOS/ndn5lbFraXByTwMFYPKBo2rfNai3/VfX1N25I4EsnGuJKLG300em6vNw577WhyckzQJyVm4QZJrjTZlv/5rWrP6v2+aBn4KMkLsXSRk+tNntRZtbSKWbzYo1MliaNqO6MnaLq/3Srfu26uro/1Ph8t6QY4/2Ia7G0oScIxUSTqWyyOX3Ww0bjOBmGSeIEyyBNu/e3NO9i+6P8tanxcz9NI2vUKATtQiz/jkmp1E9MM00ck5o66WGjcTSB41oh/fvCYccXLS172T57nzU17XFQVPT9UiVOuxPLv0MShKJEbygpNRgG9dPrH+qt0xWlKuRZsNZtGAbQTVSwpsLVeupLp/PoSafz8JdO56l4v4PcjXYtljthVirVPbRaU2e1JqWzRp2UoVQZ0hQKbRJBqI1yuRIHQA6wb7ZBGECHGIZyhkKBForyWoMBd30g4Kzx+exXvN6mC263rTEY5NUuNJ544MSSgDtxf65zAuFIiCVBdAAA/gVwXzoInB2jDgAAAABJRU5ErkJggg==", Lc = "data:image/png;base64,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", Rc = "data:image/png;base64,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", Dc = "data:image/png;base64,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", zc = "data:image/png;base64,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", Oc = "data:image/png;base64,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", Bc = "data:image/png;base64,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", Fc = "data:image/png;base64,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"; function Vc() { return (0, Me.jsxs)("div", { className: "text-center text-white mt-[10%] px-[5%] relative", children: [(0, Me.jsxs)("div", { className: "flex flex-col justify-center items-center", children: [" ", (0, Me.jsx)("h2", { className: "font-black sm:text-[40px] text-[30px] sm:px-[20%] px-[5%] leading-[40px] sm:leading-[50px]", children: "Supports all EVM Chains" }), (0, Me.jsx)("p", { className: "sm:w-[600px] sm:text-base text-sm w-full text-white/60", children: "Magmar is going to support all major and even non-mainstream EVM Chains to allow total connectivity." })] }), (0, Me.jsxs)("div", { className: "px-[5%]", children: [(0, Me.jsx)("div", { className: "", children: (0, Me.jsxs)(jc.A, { className: "mq flex ", direction: "right", speed: 60, children: [(0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Nc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Mc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Tc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Ic, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Lc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Rc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Dc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: zc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Oc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Bc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Fc, alt: "" }) })] }) }), (0, Me.jsx)("div", { className: "mt-[-50px]", children: (0, Me.jsxs)(jc.A, { className: "mq", direction: "left", speed: 60, children: [(0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Nc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Mc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Tc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Ic, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Lc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Rc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Dc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: zc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Oc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Bc, alt: "" }) }), (0, Me.jsx)("div", { className: "image_wrapper flex flex-col", children: (0, Me.jsx)("img", { src: Fc, alt: "" }) })] }) })] })] }) } const Uc = n.p + "static/media/aethir.109ba4db9a49a0ea6f81.png", Wc = n.p + "static/media/Akash Network.3c02308d66bda9cecc6d.png", Hc = "data:image/png;base64,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", Yc = "data:image/png;base64,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", Xc = "data:image/png;base64,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", Qc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARIAAAESCAYAAAAxN1ojAAAACXBIWXMAAAsSAAALEgHS3X78AAAgAElEQVR4nO2dCZgdVZXH/4cdRhRhEEFZXBFFB9RxFFCURSQsAQJk30i6k053OkmnOwmdPWTpJVunt3SSTtIJgZCQQCAEQkQBBXRkkREcRh0Uxw0XBJVFIDnznXrVr99SVe+9vi/dL/D/fR+k76uqW6duVf3rLueeK6oKQghx4SCWHiHEFQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcSZQ95pRXj55VccDMEJAE4D5DQAHwBwBACR2C57IXgVwIuA/C+A5+6+a8frvW03IQcyoqoH/A1sbl15vECuAHAlBF8x8RD4shH/JzT9GoDHBbIbwPbiolHP9c5VEHLgckALSVNL69cATBLIpQAOz0I0skn/XCB3AmgoLhr12x6+JFJA3P/tB74BoNJqsd4zkvj8iNctMOqiC77xIu/ZASgkjU0tR0NgtY9iAOcHioR07e8gKtbcaRTIouKiUS/v9wsjBcfuPd++TiBb0p6nrvQpF194wf/xzh1gna0rGpsvU+hPVXWTqp4PBUwI1fsDiP2jsd809lvgdiRsD08fCcUUVX22bfWaywrg8kkP0/nsJD1PKWkS44DobG1Y0XQkgKUQjLWb11lrUIndSVGJiYXExCK+3f8tdTv8L4t3fGp+qduBk0RlZ9uqNXb+qWOKRr/dG2VAeofOGnvi84Lk5+NdDw6UGolCWxQ6NrVWkTGN4P3RKTIhx4dsr4BiRu+VAulpEmsd8VosgtPvdgq+RrKsYYW9vCMSvwBWw0BCjaOzVpFYA0nY/jIUfxHImwo9FIJ/geIYgRyZdrx0iU9ifgnbp69ctfpkAFPHFhf9ufdKhfQUnR+Uzr6RRPEQEd4Hn4IWkqXLGxYAqI6/1Eh4wYEgEfmnqHxXoY8CeBKCn0Dx2/Ky0r2J+TY1t5qIfBSCs6G4XCDfUuj7gPRmUZLIKN6UmO/JP3u+NEhPE9WsSRWVdzsFKSRLli3/MIBNArHh3eC+kMSaiehL1hcrKm3l5aV/yJR/WWmJjcg86/93c1NL69EAhonKFIWeEss8KX97iF6zYeaxY4se3n9XTgoJE4rQvhFqSBIFJySLly47HMAugXxWE+5WYFMD3iehEcDcSRPKX+ruOcvGlfzd/NqamlvXQXC5NV2g+Lx/Yjvf6wLpU1JSTBF5N6EhHfCJNRPiUXBCoqrNcRFJqHkEiMiLEAyumDjhgXydu6y0xLxctzQ1t94BYIGKVvkictm4cWMeytd5yIFBvMM9apSPeBSUkNQtXtJXIKPCOlET0nsgGDN54sRf7g87ykpL3gIwpbG55X8F8pvS0rHf3R/nIYVNWB9JvCJCHYlTMEJSW7/4XwTSEjLykigi0ysnT1rYEzaNLx3X1hPnIYWJ10ciEjlyQ2IUjh+Jor9CT/L/TvMF8X97vKdEhBCE+ZJQR9IomBqJQkeG9IV0ViX3iUpZrxtK3jVw1CZ7CkJIFtXWfV0g52XoG1lQVVXxwwIwl7xb4KhN1hRGjUQxPkPfyAsKvanX7STvKpL6RhLmYnHUJp1eF5KFi2qPA3BF0uQ6pHmtzpk2teqt3raVvLtIatogeCoFidHrQqKqFtXs0FQRSaiZmL/Ipt61smdoaW07FMBnIPgMgI8I5AP+58/mCv0egAVa+q+xY4p+3ZN2revYcDyAswTyCQjM89c8gd8QyG8hMLt+BeDp4UOHvNZTNm3esvXjAjndYoJA8BEANur3MgQ/B/AUgGeuv7bf3iyyCmc/Nm127rr3gwL5PASxawCOEMjf/PK0+/tkn29d8isn+3uQ3hcS6GVBIpKQ3lA9deo7tjbS1NL6foGMAHAxgM978WaT5/ekzi/a29q26lmB3A5B+9jiot/tD7vWruv4DwiKAHzV4t8K5LA0T+Pkl+rvHRtvNn+bdvNMHj50SN7DLdx625bj/IBWgwXymcCaQpc9L2+5fZt5Itdcf22/x+y3rdu2f87chLyO+/SAVm9CMKHf1VfFLzLMIS0pnQN337PrLADXALhIIF9U0UMj8t+3677dT/nl2dHnW5f0mEh3h94f/lWcGTTtP2H7O9Ytvam59ZNQPKXQpQq1cJEnRIY5iG04GMDnFDoPimdXtq0+J992ta9bP02hP4BiFBSfBHBY0lB8ykvmp4+G4koodgC4s2PjzYfn06ZbNt/2USgeh8KG/z8TFfbBTx/j2/Poltu3Xef/eBrUE8cxCvX+g2KMnx6R2lRJHfpNud6c/Enu2nnPcCieBDATwFdsJnqG/A9S1S9YRdWiPu66b/cR3Su5nqFXheSCCy60WbinBkUz86NQ2f+f6k0b9xeNTS3jVPWRoOvPIX2MQu9vbVtVvbJt9ZGupq5pX3fSmrXrtqvqoqztCYhGp6qXQfGDjg03fz4fxbfp1s2DTBBU9bTI6Hbh9nZs2bqtSFXfTvIFSYh4BsXbacKQvD09OloWOrLj7p1H7Lh752Io2tXqHKllFpJ/Shmfax/UXfftvigf5bk/6NWmjQL2RT4CQdHM4NXvnp9x443vqADMDY1N7xXIOq+KmzrDGJGxUMK2W9+AzQuqNEEpGVO8sjt2rV6z9usQ3AaNReDPOE0hs71WjTcx2Q6gaviwITnHNr35llsPs8ngAikLCevgkalD1Is9I7oKwPpQ+wOaKYmjNt1p1tx5190n+hNQzwoMQxCRf8D2f4dizz333rdRIDf0ufSSgorU19tNm9PiCoyUr0gs/d+9bF9eaVjRdDoU31fVa5K+Pgj+sqd+NTNsf7+qtrauXDU9F5tXrW5/76o17W1Ws1HVD2RVEwmxJ2C7Vd/NY/nR9Rs2fjIXuzZuuuVcVf0lFGVh+YeWT3h6RMb9E8giv1D779hx14mq+hAUZ+VgXzbpoQq9eT8/qjnTu52tqsd5hRMQV9X/yv0+X6eqqa0vBTA752jy/m9Z7r+2YtKEaUHnX97QaO30eETylFgnznFoE46f37Ky7R/jxo5pyFQmbavWHATBnVB8Aylf2tCaUpgvRdR2hcWX2bO+Y+OXRwwfmvGebrh505kC2QXgvVEdqvHyzzUOb8T2JLo5arP9zh0WJOteG+XKdHw30/137rr3+cv7XFqdqSx7it5u2hxlL0OoazyQt2UgVNVemuNT8veIrMqHhzEISp8fdO5ly1d8wkQm4/Ex/imQhxX6MAT2RVaBfEihZ0LwJQCfysKeZS2tbU+MKxnz/ejy1zoTkSCHq8T8/DL6rYreD8UPBfKKQo+E4HN+3JazBXJ0huNPUdFt6zo2nDty+LDQT3nHxpuPFsgOhb43C5F40/pOADwokF9YDwQUpwrk6wo91w+rGXh8gH1pzZWwUZsoh7Rtd9xp57dRohOzEInfQXEbgIcF8qKK12FtzaHzBNJPRd8fcfyNO3fdu+fyPpcWxMz03h7+PaizKhfo1WrLa+aJpPZm90Qim/QnlixdftjkiolvJlptnX0QvCfj8UC7qMwvLy8N9B9Y0dQsAvmmjfJA8OmI/OyfDc2tK88oLRkbGBaytW2VjfZMzuL6HrdWmYpuLR41KjCvNe3rjlXRyVBUCOSIkJqSpb8ikArr9wi9q4paPwxmYM3Bt++PEEyDYvvQwYNeCchl0aZbN5uIXCuQegDHh4lIUM0k4b6FnT9JhFLsb1HRE/2/PQJE6FUVnQNF09V9r3wjIJeOHXfvtOBadbYIV0TNZc3d9+w644rL+rwZkEeP0stCEutFl1jPUpeg+Gl/zd48nQrxDqyE/L0bEk+7b7dRlKMAxG/skmXLvySQr2TI/zUorpk4YfzuqEsoLyu1o3Y3NrWcB8WPzTkswp6PQHC1+W6FlEdZmD3obNoIbi0uGjUoU9GOHjXSotNNX7N23S8Uuja1PBPys/TkMCFZv2HjewCMzXC82XvF0MGD/jPKpsEDB9j6zh2bbt1sMWseSjw+Nb/EdHoxZb//7dvvsNnrfTo/iJ3bO2vdCcePuqZv39ui7O97xeVWpqN33L3T+li+kHi+hPw+auezft2ovHqCXu1sVcXrSBxGRFqH63vydq7UzsOg87lvtxrWQSknHhnaeRk7/k1V7ZdJRBIZXzbur+bIp6ovBeSXaM+woONbWtuOU2jfEHs6Rf0xVR2TSxmPvmHkOlVtSL3ezo+EX24nrl3XcXHgPVId6b0j0QtTFQ0dEi0iiQweOOBhb6GzLDtoU+zJ2AGasv+Q0A70WPqPqtr3mquiRSQlzzHe0HR4eQTe456mt0dt/hz2Evg3/EP5OlFOIhH8UmazPeb64rN4ybJjVHV44PFd6bJJE8vvy/V6ystKn/FiuESPsFza1Nx6elpZmDOW6lER1/eC+YKMLS76e652FY26YaJCd4Vdr/8STEg9bu36DmszTIgSIShqhg8dsiZXmwYPGlCvqrdkeMkDmzZp26NGbRSjI0VH0b/f1Vfdla3dd+y4y5qvg+KPVbAI9r1r5z2n5Fom+aZ3hUT1l0EvQcIL/+n8nQuHZi0S3U+/pNBXuy7PG+Y9MiK/ByomTVjd3UsqH1/6bYW2Z7A3rWmiqgMzXG9JyZjiv3a7qFXthXotIv9L2teu/9fkg2DDvR+LKP9fqOrM7toExUQo/hEhUkHCEPo8pArPlq3bzlLVT0SIyOZ+11z1YCYzt9+54z3b79zRd/udO/ZA8RNbmM0fRo8/uyn5H+SVdy/T26M2P1dVW+bBG70JcEg7ddacuafNmzPbefKSqn4fghvF7wToPF9YB5zdKgj2WVU7YbtNLrRwBgeFHP/81MrKeP+INT8i8rc/nEMjqOpCgYy0Byrker7lDXv7NDa32LyZMyOu/4nSkrH3uthUPHrU71etbl9tc1dCrv8QhV4IIF7F9ydvRt2PhSNHDOu2E9aQwQP/tHHTLessZEVoh2na6K+G2oOUURtV/UaGDuLlYbZt236nfdAvhHjzgC70JyCmjxIlGJuy/avdLZd80atC8vBDD/5zxszZP1boOQEi0jmKc4m5PLiea+aMamtXZ922DmJRTZ1Ft1+QYh8SRPDJxMNsrkTiQ5iy/wtVFRXOkeknlo9/fvmKRhtuPDfkof+3FY3Nx5ePL/2Tf/IvZhDRvDg7KfRWa6pEiOhXk4TEnoFwEXkdgtudbVLdKpDxqb4pyDBqk2ZPQBgBhX4paHvnMO/11/ZLC8q1ddv2zgmbRRCcESpCwfZa/+LdAmnq2/fy77mWjSuFEEbgAQjOiZgBPCQfQpIPVPWLnfalfsl8e+Nf8pq6+mMFcnJITcuOj/TxyAVVNT+KcxFc0zoc4n3lNvvlfUbYS+Hvn5dlN1T1CZuBq6LHpOTfad/HO/dd3b7WfvlkhOg8MWrEiJz7a9KNwo9U9I3OaRlhNY2E/YNFJMAhTVU/GjhMG0v8JDHbLbdvOxvAOIH09yY7Rt2P9PxesFnfNnfnmqv67peZ392h14Vkwfx5s6qnz7xWEXvAA4aCz5sxc/b2+TfNvaY37Zy/YJE5YC0LG/pV0fuqp02Nd6TpPjUHrIMStnu/Jxyft1nNuk9/GJB/on0XJQjJ6UgcitaEl0H0bwL5r3zYNLa46O3WtlVPi0rcSS9laPkjCfafZM6CivSheH//J/Jh07Chg9/o2HDzMwC+GDUU3Mk+3Ze+vVNwUvZX1Q+FbReVf9+8Zas1eQ9F6lya6PwfhcLWebrj2n5Xv56PMthfFESoRVVd5b2kCc5hSYICXD195qzzF9w0r9cWqVLoAFF5X2CtKfZFuT9l/70RHruWyNs0e4UelvbFT3a2izuS2QzYEGc42/9wLy8gPw+t4vBUe9BVbX+7azfdm6Ev4tC82BO7/oMTa5RBfREJ+4Z7tKY3g94O2u4ff2zY8QH5/15Fd5lj2/XX9nsSBwiFISTQNaIyU6HHpjUDEH9p26fPmHXWgvnz/tHT9s2bv+BQgUwPeUm9C7CvRtJBipdD+yJix+c0iS0K+xpm8FB9rsusmO9JyP7WDPoggLwsPGY+IxF9MX9N2O9lgbyh0CNC9j8hb2UFPSHopU4S+a6dM7rVJ1zDK/6PoSIRdHzCutI2LaC5//XXPpKva+1JCmJdm5qFC/6hqjUpQ79dNzb2mw0Ndnuo1AnFjM6hSSi6bOwa2vvO9OppSSNLqvo7hb4SMTSbl1gdsZPhnAxD1/GHU1V/GmJPZzovdjW3rPywLcgecf3x8hpbXPSGqv5fhP15sWnt+g6z56So608kwp7E2nIMxa8yDS0HbP+lqs6A4mP9r7920IEqIiikBbIU2gDF84EOY13pAdXTZy7uSbvmzpt/hfkvhNjT+duK1OOmV0/bq6rPJD2kySL0pYU1tSe62le/eOkR5pcR8dC+UDFpQlcV2XwTokUnL31RCr1S1au2hb20j6fs/+MI0flI2+o1ZzvbpPrNDCKaun+wPUjfX6FPBm5PP/4tVd3jexafPrD/9QsG9L/uD67X1tsUjJDULlporuKjI0SkMz35xukzflQ9fWb+nNVCmDP3JnsZtngtl3B7npw5ozrYW1HxnYjrOcR8GlxtNLdyP6wgQkTr4ZT9n1Toy0lfzeSHvt+yhhUnudjU2Nwi3rVFvFRQJM1aVfVmFke9hOUuNsVOgrEZXvLU/dPtQbBDmqp+N2h7Qv5/91eTPHHQwP7fHDSg/12DBvR/x8QiLpwlO01Mahbaw/VA4g30SK9GflFV76uePvPY/WXL7DnzPqnQrd7EwfTzJ9oXOjSt0O+F2N95fEkeTC0LKy8/ndRBPbli4lsWBjG+Xbva7P7+h/txTbuP4mKFfiokf/vjlXElY55Oyf97EfsbQ1euWt3tuVdr1q77N5v8FpF/YNMmbf+g42P8p0LfTr7NSfnbrOjHBg8c8JfuXsPmLVtP3rxlq9u92U8UlJAgpuxVCv1n0Bc28Yuu0JPNf+LG6hmfzbcNs+bM/Q/PJ0RxWOj5/WaDqoYvlRGLM/q3iOOPWbCwJjAQUjbU1i0ebNMIAppNnflb82pPulm6O4NbfenS5Q3dmue0orHZvFbnZsg/bYKiqv4M6nk6h9UYDoZiXnfLynOvz9SsCaqRZLn/sCGDzT/lu/F7nL6/RYyf2137b71ty8e8WpyiZfOWrQs2b9ma1+DarhSckNTVLnrKq4JG95V0/maepo/fWD1jxY3VMz7sct6Zs+YcNHPWnGtmzp6zx4IyQ/HRDCKyT1UHz54149XQPGdUv6rQtpDjO9MLFyysGZ6rvTW19Rer6poI++zfO6oqK9LWwFHVdm9UKbjvxv61AFD3LV3W8IFcbGpY0WQislZVv5zhJVyWemxpid1ybYh6aVV1Umvbqpybg6vWtN8ERb9MohDUR5Lj/pnsH7lx0y13b9x0y/G52H/L5tss+v39Cq/D/xBVrbaI+ptv23pWrmWxv5DUwigUqqZMO9uCEXuLMnUiyUNuKWlzozaX4Q0AHl+0cP6LmS5l+sxZNo/GhmH7AhhuwYIi8k9Nl82dM6s50znm3bTA1mL5BYBjMuR3HwTzZlTf+FhUfgtrag8RiMX0uMmb+5OSH7qGJc1f5DNTqyp/FpRP/eKllRDUZ7jeFwRitYBtFZMmBAUQirO8odGCEW0EcI50GZJ2vbYyQ3lZad+gPJpaWs1f5Nn4PU++nsR0EwTTS8YU/y3KprbVa95rFTeBjE3LL8ksL/FXCI4bfcPI+AvRvm69Fx4z4Pydf5wycviwpKDW6zdsfEQg52Q4nz0P1w8dMijjCgmbbt3cRyBrIIh3zCfkZ05udQKZP6D/dYFBp3qKghUSxMTkJK/PBPhUhpcwKP28QJ7xX2JbEe5VW+QJgMXTtBXsbCU7b0W7LPNLTFfPmzt7UbbXMXfe/FEQrMmUv+fWANnph2V8TCB/8lvY5l/zcf8lLU4rj9QHPJaYM21KVWhVum7xkoP96GdnBeaRbJ+tdmh9QXcJ5LmKSRNeXbq84XCBnGpr7HjBdQQDAByZ+NIEXN8rAvls+fjS0IjyTc2t5gn7YEj5JL5ELwrkHgD236MQ/NEvv3+F4MsALgNwpUBODDk+9XrNr+W4olE3xF+INWvXXSeQLRHHn3LDiOHJQtKx0UJi2pyuIzOczxzybvc+fALz3P2zb781WY6HwKY8FAvkGyHHJ9pTNbD/9T06mplKQQuJUVk19TiI91W4IP5j1Ese8hBnvT06/T8QjLxp7pzIWkMQc+fN77CmdA72WJjJlzwhEdi8nUNStkcd/5A9gNOmVkXe3Lr6JR+H4EdWW8qhvF6DeIJwlCfKuZV3vwnlZdszlVVjc8scgcRnLAe9xCnn2+cva+qVlTlaZhChIPtiQjI6QUja111nz15XNmmicMoNI5OFBLElTu3jtEcgHws7X0p+ewVi93ofBFau1qksgSKUnt41aED/yzKV6f6m4PpIUllcX/sXKL5p0+XjQYPCh2KT2/u5bkf6/glpG/s/tzsiglj7ebRC53d2JAd2yiWf72CF2vwTWyLikFB7049/1nxBMomIMaVqssX4uByKP+aQvwVEsqUW3hfYHxB+/ORsRMQYXzpujsW5TR1ZijifRabzykpVDwmyJ/D41P9SR21S7xFSnrG03tkYI4cPs6Ddl1ps2aD+koCh5IOtX8q8blX16Lj/Tfj+nWnzvRmQ/VO4/yh4IUFMTPYurq+19VrMg/On8cJEyshOys1Pfagzbg8Wmdetc0uh35o/b263h+7mzJ751pxZM23koI+5hAe+dFEvcXbbH4Pi6zdOm/JStnZNrap8xF/BriMLEclqJCMlbQ5Y4ydOGL80l/JS6EgvjKDiDzmeLyr9fEaRSbYhWsQiavMjRwyzEaiveR6vqSM9IaKUTTpBRGwdoq8PHjjAfVZ0Hij4pk0qk6umvMc6l+zD5Qlh7n0nuaStqnzVwvk3ZR0eLxvmzL3Jgg3dm2d7Lb/rpldPCx1FykRt3WIL6XBBaDU89fyZmzXWf3BhxcQJP++uTSuamq3j8pGoZgnCmi3JNr4K8WZBPxay3etsHVM0Ov5CrFrdHm/ahOR/yuhRIyNXEFy7vuNMAE94/XOZmynZpp+xRciHDB7Yqx2siRwQNZJEltTX/WNxfe1ECxqk0Nv9L15gM8YhbUO7uzw39jyLCGK1k/ssCLBCf521veHNLqs+F0+vntbHRUQQ+wJfbUskqOrewKZi6vmjayzeF9NFRBCLTfuo5+Cm+uvIZkKQ70bXV/7Pvkv68SHbvb8SRQSpc23CamgZuGHEcJsmcZ5Cn04rzwzNppBmzQ4oLikkEcGBWCNJZXLlFAt8O1RE+vkjCAcHfZlEJPnI9C+rzcB80BuGBR6oWbTgp/vb9tlz5lnHmo3omIfrGVl3eMb++ZVAbBJj88wZ1ZFDs7lSU1dvo1lVtkiT3/GXbU3kbW+UTVBXWTHpO/m0qaGx6SiBWDmVdsYyyVA+ln7Li8ImmFpaMvZ3La1t1im5M+TL/+eSMcVJ/h0rV62+zlunOTz/M4pG35DVmsbt69ZbB/BAAP0hOM8fPczUAdz5h51jlUA2Dhs6+IWcCq6HOOCFJJHJlVNOhXiLMNk8HPNFOA3ACSJiN+0w37fiDV80bLjw1xA8LRAbrvthbc3CXmtvzp4zz4Z3vwDgYt+f5cP+qIgFR/qb5+cA/MZ8ZCDYLZBHZ82cnrcFxIKoqa033xebLPcl3zfCRnnMSe0I/yX9iz/sav4mJhy7qyorcl4sPBcaGpsOBvA1gZgofBqCk717DLGoZ6/6L90T/mp3D5aVlsQd8ppbVl4FgRfuIeCl/XXJ2OJTE01Z2bbams6H+cOyqftLcdGooMWtMtK+bv3R1uQTyEXeaoXAyQI5xv8IWiyYvwvEQjk8AfHi3HxvxLChBT0v5x0lJGFUVk0VL/aKYO/iutp9hWllOrPnzrMhX5k7e1bBPEQ1dfU2LGmOY29PnVJZEGW5orHZu7/l40sjy6mppXWUjeqGfPmfGlcyJn+hHXJk7boOE62Dbxgx/ICcyPeuEBJCEPNPaRRImZdIbz7sKC0ZexULqnsURIQ0QsJYuqzBHBJHWsukYuIEtxCQivO9DtKgdaY1OUAzyQ0KCSlIlixbfpS/DnClt0K/4HlbP6q7tq5oarYFuT7r1UA0IBi34Fk+Cd2HQkIKisVLln0Q4sVDGW0u6Ak1hokuQqKqg0Li1HamU+OjkBxgHwkpGOoXL10AwaT45D+k9WXMn1wxMedlO5evaLRREROK94cMtT5XXlZ6Bp+E7nPAOaSRdy5eHFfFkRFu7jOWLF0+I5cCWNaw4kQo7lXV96e5vHflv56PlRuskZCCoq5+iYWG/FqGqQH3QlBRWTHpuTDbly5vsGn8VwnEptefFDQD2E+bM98pE7uc+k8AAAMsSURBVMrLImObkGgoJKSgqK1fbI55T/thCmIEi4o54z3rO+j9wBcEWxfHHBHPE8iXvTRSjk9v2kyaWD4+dIFvkh0UElJw1NYtvt53bffIwhU+OI2Mrv2PTJpYfh6fAHfYR0IKjqlTKm0JkArnsAHRYQ8svsy1vPv5gTUSUrDU1NYPgOBWZAhjELo9PL2nYtKEb/LO5w/WSEjBMm1q1WYLBAXFn6ICKwWGOQgPu/CQqg7lXc8vrJGQgmdRTd0JENQIZGhYmIgswhz8SSALKidPauAdzz8UEnLAsKim7nQILIp+Pz+CfYxwEXnTovHbqg4C2VxVWVEQYQnfiVBIyAHHRRdfbNJhnqgf83xEbM0gWNwWr6FjUe5/A4jFbvnZnvt3v8w7vP+hkBBCnGFnKyHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxBkKCSHEGQoJIcQZCgkhxA0A/w/J/Qp52UXA0gAAAABJRU5ErkJggg==", qc = n.p + "static/media/filecoin.74acdc2d634198d1924c.png"; function Zc() { return (0, Me.jsx)("div", { children: (0, Me.jsxs)("div", { className: "sm:flex   mt-[2%] justify-center items-center flex-col pt-[3%] px-[5%]", children: [(0, Me.jsx)("h5", { className: "text-white/50 text-center sm:text-base text-sm", children: "Powering the next generation of builders" }), (0, Me.jsx)("div", { className: "flex sm:flex-row flex-col gap-3 items-center sm:mt-[-10px] sm:mb-[40px]", children: (0, Me.jsxs)(jc.A, { className: "mq", direction: "left", speed: 60, children: [(0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Xc, alt: "aws" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Yc, alt: "nvidia" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Qc, alt: "google" }), (0, Me.jsx)("img", { className: "w-[150px] mr-5 select-none", src: Hc, alt: "microsoft" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Uc, alt: "aethir" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Wc, alt: "akash" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: qc, alt: "filecoin" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Xc, alt: "aws" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Yc, alt: "nvidia" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Qc, alt: "google" }), (0, Me.jsx)("img", { className: "w-[150px] mr-5 select-none", src: Hc, alt: "microsoft" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Uc, alt: "aethir" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Wc, alt: "akash" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: qc, alt: "filecoin" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Xc, alt: "aws" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Yc, alt: "nvidia" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Qc, alt: "google" }), (0, Me.jsx)("img", { className: "w-[150px] mr-5 select-none", src: Hc, alt: "microsoft" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Uc, alt: "aethir" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: Wc, alt: "akash" }), (0, Me.jsx)("img", { className: "w-[100px] mr-5 select-none", src: qc, alt: "filecoin" })] }) })] }) }) } const Kc = n.p + "static/media/dashboard.e3f57c44e5e1175976bb.webp"; function Gc() { return (0, Me.jsx)("div", { className: "px-[5%] sm:my-[10%] my-[5%] ", id: "pricing", children: (0, Me.jsxs)("div", { className: "w-full h-[50%] bg-[#1E1D1E] sm:py-[4%] py-[6%]  rounded-[16px]", children: [(0, Me.jsxs)("div", { className: "px-[6%] flex justify-center items-center flex-col", children: [(0, Me.jsx)("h2", { className: "sm:text-[32px]  text-[30px] font-semibold text-white sm:leading-[40px] leading-[30px] text-center mb-[1.5%] ", children: "Track Your Portfolio in Excruciating Detail." }), (0, Me.jsx)("p", { className: "sm:w-[700px] sm:text-lg text-sm text-white text-center sm:text-white/60 sm:my-0 my-[4%]", children: "Track your Magmar Wallet (realized and unrealized), historical portfolio balances, collectibles and their floor prices and your real time net-worth, all with a websockets powered chart that refreshes every 5 seconds for a truly real time portfolio management experience." })] }), (0, Me.jsx)("div", { className: "flex justify-center mt-[2%]  px-[6%]", children: (0, Me.jsx)("img", { src: Kc, className: "sm:h-[600px]   border border-red-500 rounded-[25px]", alt: "dashboard", loading: "lazy" }) })] }) }) } var Jc = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, _c = i.createContext && i.createContext(Jc), $c = ["attr", "size", "title"]; function eu(e, t) { if (null == e) return {}; var n, r, i = function (e, t) { if (null == e) return {}; var n = {}; for (var r in e) if (Object.prototype.hasOwnProperty.call(e, r)) { if (t.indexOf(r) >= 0) continue; n[r] = e[r] } return n }(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n]) } return i } function tu() { return tu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, tu.apply(this, arguments) } function nu(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, r) } return n } function ru(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? nu(Object(n), !0).forEach((function (t) { iu(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nu(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } function iu(e, t, n) { return t = function (e) { var t = function (e, t) { if ("object" != typeof e || !e) return e; var n = e[Symbol.toPrimitive]; if (void 0 !== n) { var r = n.call(e, t || "default"); if ("object" != typeof r) return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(e, "string"); return "symbol" == typeof t ? t : t + "" }(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function ou(e) { return e && e.map(((e, t) => i.createElement(e.tag, ru({ key: t }, e.attr), ou(e.child)))) } function au(e) { return t => i.createElement(su, tu({ attr: ru({}, e.attr) }, t), ou(e.child)) } function su(e) { var t = t => { var n, { attr: r, size: o, title: a } = e, s = eu(e, $c), l = o || t.size || "1em"; return t.className && (n = t.className), e.className && (n = (n ? n + " " : "") + e.className), i.createElement("svg", tu({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, t.attr, r, s, { className: n, style: ru(ru({ color: e.color || t.color }, t.style), e.style), height: l, width: l, xmlns: "http://www.w3.org/2000/svg" }), a && i.createElement("title", null, a), e.children) }; return void 0 !== _c ? i.createElement(_c.Consumer, null, (e => t(e))) : t(Jc) } function lu(e) { return au({ tag: "svg", attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z" }, child: [] }] })(e) } function cu(e) { return au({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z" }, child: [] }] })(e) } const uu = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADEAAAAxCAYAAABznEEcAAAABHNCSVQICAgIfAhkiAAAA21JREFUaEPtmr1rFEEYxm/Bws7YqQgeWqgoGP0LYlJpE+3ExrMQkaBGtPfsBQ2I2BmRFFYxlRZ+5R+I2imKmsZoZxrb8/csM8feZndn7ry9nTvuhRd2Z9/ZeZ55P2b2I6qlpNVq3aJpBp1Ed6WvV3j+i7E/oK+jKLqbxBHZE8Dv5fgteg/9pg4Yq2MQAj5NqCZ2P3oNnQbfT4GLSRgCTzm8xIWvQaAuAAHeg1x+hJ4H74Yl8YWGU8NAIBE5hzheBvPhyOTAX04ehu6BND6wz9G2XSRecLAAiZdDSOI0mOdEYoOD4yElse9kmmR/LxItCLSrlO8NQrGL8Y9JBOCOsScCcEIMIVhPAGySWqN9klOCIiHgIL6OnkEn0BsQue9iUTkJAAjsLDqPikRStACrvVAqI8HAUyC7gDYKEIbnCYDXE8B17JKTeOKdy2ggnmAQzbZCRrGelk3jDZHSc0xbfHcRpZEws64kFQHFfZYs0NhElbwKraR8hEQ6RzJv0lcSjiRNAlgXOYUKfRYzCMjWK6ll2BcSiSS1pTFn4uPmO4BvGsLLnE/lGF/ETgSd0jMJEy62NNadI9Vqq9jMawEzBPQsXxQuejQoZ7EzC9JtAGQlaRYXJW7TLlqmvzxQRHwT+7w82jJG156gwx/ussNj5mWyYmb/h4ldzbw84AK4Com8MOsLCd28YTyRRyYumwB5bkeEvDz32IOAusR54zlR/5fYBpjAidg+M2hcNgEhj8Vi1gkR8JWzyQlwdeo6nPJuaGJ9Ir3C0q69T8ci5gLF9Z3JSXDZ941E1kAFa0ARrnUI1F3Ak9dLI2HK6CKDqQx3IyuQ8K18NlzLfVHQQzh1ldQm58olYQZRaZVXjnm4xGvnOpBwSoM14ZW10esw9d25VkLCDmrKrchkrTHeO9dKSZjwUvXRQpgOryd4ouERch0mpVUnHyAMLo/omcOK9861ck+kAKic2jcaek3TXul9JmJg1ckXTK92lYZTr6AzKl/560S/wObdZ+yJsmfY9/4j5YmR+GY3El9P9S/HsH7Hvgr2bfaPgk+czLJifvZNqKrtSOgjYHgG5qOWxB4altArNIpQ0GIIPADkOfD+Tv5ls5vGN6gufkfXMAjtL5sT4DqAXkZnRECzveUjPCxv0j6NqkNo/zutgekV4DveoPwDaGY9zjRzcuAAAAAASUVORK5CYII=", du = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADEAAAAxCAYAAABznEEcAAAABHNCSVQICAgIfAhkiAAAAx9JREFUaEPtmr1rFEEYxl2wsNRORTDRQkVB4z9gPiptop3YmBQiEhRB/wDtBRVE7IyIhVXstPAjf0FiqSgmldEqsbE9f88xcwzj7t7s7tw5F3fghd3Z+Xie951n5r3bzXZ4pdPp3KZqBjuF7fWf/8P7H8z9EXuXZdk9F0dmbwB/gOsP2H3smzrQWB2TKOCTQ+XYQ9gNbBp83wWuS8IQeM7lFR58TQJ1CQjwHuHxE+wSeDcsiS9UnB0FAs7KOcr1EpiPZUYDv7l5nHoEfHxgX6Bul0i85uIhJN6MIIlzYF4QiQ0uJlIScagzjdhXRaIDgd4uFTpAKu26+FsSCYSjjUQCQehC+L8jAfubOGG2IBrzbHbroZFirN20fWpSoDn6boX2bRQJM7EyyoM6KDE7scitAWQiFAhjaZwxbJJ+uq5UGi0nOiujXMUWmXzeeMXWKQMQodLCGIs0OF+XQKNIWGRmWSl11xISIAlN4FV3gbpXRSwMgctu336k8543ioRDREDPYFN2OTCwrVM6s+5PHotAlEiYQSRMreVNQ2TL0cymr4+86NWJgOPEOGlHqD5oN8fk2onuQu5OE/DRSXhayNUHbexW+gwCIhOlRNGEi8TRQp4+RCIqgWia8EiU6UMp/3gU9zuDRI+E8UzZ+RFNCwPRhBcRe1bk6UNLbTlWRAYSCS8aSkfy9DFeNUcqIj0QEuaMUDryy+xIeeeH8qupGNGITsIQ0L+IezBpYwwryq+i6CMqCYeAdqBeRtonv2qsj2gkigg4O0hZftVIHzFJCOSkG4EK50cjfUQh4WSkpUujT35VWx+NSVRNqQehj0YkqhJw9KGD7iT2wFly9ldgZX3UJuGk1L0TOXTPN5uAJeJ3W656ftQmEQp4GO1aEsPwcsgcbSRCvDSMNm0khuHlkDlsJLbFO7tt8fZU33KM6nvs62Dfab8o+MTNLEf+55B1mEIbtHAcHC/BfMKS2E/FC+walSKUdDEEHgHyInh/ul/Z7KPyPaaHa9gKDVL7yuY0uA5jV7EZEZC3/3oJD8tb1E9j6pDa904rYHoLeL3/6JU/XRSwzkD7brkAAAAASUVORK5CYII="; function hu() { return (0, Me.jsx)("div", { className: "px-[5%] py-[5%] text-white mt-[3%]  border-t border-[#18181A]", children: (0, Me.jsxs)("div", { className: "flex flex-col items-start justify-between sm:flex-row", children: [(0, Me.jsxs)("div", { className: "flex flex-col ", children: [(0, Me.jsx)("h5", { className: "sm:w-[300px] w-full text-sm  text-white", children: "Magmar Infra is an ERC-4337 toolkit for RWA and DePIN enhancing gasless transactions, social login, multichain support and much more, making DeFi accessible and secure" }), (0, Me.jsx)("h6", { className: "sm:flex hidden text-xs mt-[2%] text-white/60", children: "Copyright \xa9 2025 Magmar Wallet" })] }), (0, Me.jsxs)("div", { className: "flex flex-col sm:items-end sm:mt-0 mt-[4%]", children: [(0, Me.jsxs)("div", { className: "flex items-center gap-3 mb-3 sm:gap-7 sm:mb-5", children: [(0, Me.jsx)("a", { href: "https://t.me/magmareth", target: "_blank", rel: "noopener noreferrer", children: (0, Me.jsx)("img", { className: "sm:w-[40px] w-[30px]", src: uu, alt: "telegram" }) }), (0, Me.jsx)("a", { href: "https://www.linkedin.com/company/magmarinfra/", target: "_blank", rel: "noopener noreferrer", className: "rounded-[6px] w-[40px] h-[40px] flex justify-center items-center border border-white ", children: (0, Me.jsx)(lu, { className: "text-[22px]" }) }), (0, Me.jsx)("a", { href: "https://x.com/Magmarerc", target: "_blank", rel: "noopener noreferrer", children: (0, Me.jsx)("img", { className: "sm:w-[40px] w-[30px]", src: du, alt: "telegram" }) })] }), (0, Me.jsx)("h6", { className: "text-sm sm:w-[300px] sm:text-right", children: "You can email legal@magmarinfra.com to provide feedback for support requests" }), (0, Me.jsx)("h6", { className: "sm:hidden  flex text-xs mt-[2%] text-white/60", children: "Copyright \xa9 2025 Magmar Wallet" }), (0, Me.jsxs)("div", { className: "flex gap-4 mt-[2%]", children: [(0, Me.jsx)("a", { href: "mailto:legal@magmarinfra.com", className: "text-xs underline text-white/60 hover:text-white", children: "Privacy Policy" }), (0, Me.jsx)("a", { href: "mailto:legal@magmarinfra.com", className: "text-xs underline text-white/60 hover:text-white", children: "Terms of Service" })] })] })] }) }) } function fu(e) { return au({ tag: "svg", attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M100.28 448H7.4V148.9h92.88zM53.79 108.1C24.09 108.1 0 83.5 0 53.8a53.79 53.79 0 0 1 107.58 0c0 29.7-24.1 54.3-53.79 54.3zM447.9 448h-92.68V302.4c0-34.7-.7-79.2-48.29-79.2-48.29 0-55.69 37.7-55.69 76.7V448h-92.78V148.9h89.08v40.8h1.3c12.4-23.5 42.69-48.3 87.88-48.3 94 0 111.28 61.9 111.28 142.3V448z" }, child: [] }] })(e) } function pu(e) { return au({ tag: "svg", attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M446.7 98.6l-67.6 318.8c-5.1 22.5-18.4 28.1-37.3 17.5l-103-75.9-49.7 47.8c-5.5 5.5-10.1 10.1-20.7 10.1l7.4-104.9 190.9-172.5c8.3-7.4-1.8-11.5-12.9-4.1L117.8 284 16.2 252.2c-22.1-6.9-22.5-22.1 4.6-32.7L418.2 66.4c18.4-6.9 34.5 4.1 28.5 32.2z" }, child: [] }] })(e) } function mu(e) { return au({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "path", attr: { d: "M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" }, child: [] }] })(e) } function gu(e) { return au({ tag: "svg", attr: { viewBox: "0 0 20 20", fill: "currentColor", "aria-hidden": "true" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M3 7a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 13a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z", clipRule: "evenodd" }, child: [] }] })(e) } function vu(e) { return au({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M256 294.1L383 167c9.4-9.4 24.6-9.4 33.9 0s9.3 24.6 0 34L273 345c-9.1 9.1-23.7 9.3-33.1.7L95 201.1c-4.7-4.7-7-10.9-7-17s2.3-12.3 7-17c9.4-9.4 24.6-9.4 33.9 0l127.1 127z" }, child: [] }] })(e) } function yu(e) { return au({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "m289.94 256 95-95A24 24 0 0 0 351 127l-95 95-95-95a24 24 0 0 0-34 34l95 95-95 95a24 24 0 1 0 34 34l95-95 95 95a24 24 0 0 0 34-34z" }, child: [] }] })(e) } const bu = Array(12).fill(0), xu = e => { let { visible: t, className: n } = e; return i.createElement("div", { className: ["sonner-loading-wrapper", n].filter(Boolean).join(" "), "data-visible": t }, i.createElement("div", { className: "sonner-spinner" }, bu.map(((e, t) => i.createElement("div", { className: "sonner-loading-bar", key: "spinner-bar-".concat(t) }))))) }, wu = i.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, i.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), ku = i.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, i.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), Su = i.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, i.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), Au = i.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, i.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" })), Eu = i.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, i.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), i.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" })); let Cu = 1; const Pu = new class { constructor() { this.subscribe = e => (this.subscribers.push(e), () => { const t = this.subscribers.indexOf(e); this.subscribers.splice(t, 1) }), this.publish = e => { this.subscribers.forEach((t => t(e))) }, this.addToast = e => { this.publish(e), this.toasts = [...this.toasts, e] }, this.create = e => { var t; const { message: n, ...r } = e, i = "number" === typeof (null == e ? void 0 : e.id) || (null == (t = e.id) ? void 0 : t.length) > 0 ? e.id : Cu++, o = this.toasts.find((e => e.id === i)), a = void 0 === e.dismissible || e.dismissible; return this.dismissedToasts.has(i) && this.dismissedToasts.delete(i), o ? this.toasts = this.toasts.map((t => t.id === i ? (this.publish({ ...t, ...e, id: i, title: n }), { ...t, ...e, id: i, dismissible: a, title: n }) : t)) : this.addToast({ title: n, ...r, dismissible: a, id: i }), i }, this.dismiss = e => (e ? (this.dismissedToasts.add(e), requestAnimationFrame((() => this.subscribers.forEach((t => t({ id: e, dismiss: !0 })))))) : this.toasts.forEach((e => { this.subscribers.forEach((t => t({ id: e.id, dismiss: !0 }))) })), e), this.message = (e, t) => this.create({ ...t, message: e }), this.error = (e, t) => this.create({ ...t, message: e, type: "error" }), this.success = (e, t) => this.create({ ...t, type: "success", message: e }), this.info = (e, t) => this.create({ ...t, type: "info", message: e }), this.warning = (e, t) => this.create({ ...t, type: "warning", message: e }), this.loading = (e, t) => this.create({ ...t, type: "loading", message: e }), this.promise = (e, t) => { if (!t) return; let n; void 0 !== t.loading && (n = this.create({ ...t, promise: e, type: "loading", message: t.loading, description: "function" !== typeof t.description ? t.description : void 0 })); const r = Promise.resolve(e instanceof Function ? e() : e); let o, a = void 0 !== n; const s = r.then((async e => { o = ["resolve", e]; if (i.isValidElement(e)) a = !1, this.create({ id: n, type: "default", message: e }); else if (ju(e) && !e.ok) { a = !1; const r = "function" === typeof t.error ? await t.error("HTTP error! status: ".concat(e.status)) : t.error, o = "function" === typeof t.description ? await t.description("HTTP error! status: ".concat(e.status)) : t.description, s = "object" === typeof r && !i.isValidElement(r) ? r : { message: r }; this.create({ id: n, type: "error", description: o, ...s }) } else if (e instanceof Error) { a = !1; const r = "function" === typeof t.error ? await t.error(e) : t.error, o = "function" === typeof t.description ? await t.description(e) : t.description, s = "object" === typeof r && !i.isValidElement(r) ? r : { message: r }; this.create({ id: n, type: "error", description: o, ...s }) } else if (void 0 !== t.success) { a = !1; const r = "function" === typeof t.success ? await t.success(e) : t.success, o = "function" === typeof t.description ? await t.description(e) : t.description, s = "object" === typeof r && !i.isValidElement(r) ? r : { message: r }; this.create({ id: n, type: "success", description: o, ...s }) } })).catch((async e => { if (o = ["reject", e], void 0 !== t.error) { a = !1; const r = "function" === typeof t.error ? await t.error(e) : t.error, o = "function" === typeof t.description ? await t.description(e) : t.description, s = "object" === typeof r && !i.isValidElement(r) ? r : { message: r }; this.create({ id: n, type: "error", description: o, ...s }) } })).finally((() => { a && (this.dismiss(n), n = void 0), null == t.finally || t.finally.call(t) })), l = () => new Promise(((e, t) => s.then((() => "reject" === o[0] ? t(o[1]) : e(o[1]))).catch(t))); return "string" !== typeof n && "number" !== typeof n ? { unwrap: l } : Object.assign(n, { unwrap: l }) }, this.custom = (e, t) => { const n = (null == t ? void 0 : t.id) || Cu++; return this.create({ jsx: e(n), id: n, ...t }), n }, this.getActiveToasts = () => this.toasts.filter((e => !this.dismissedToasts.has(e.id))), this.subscribers = [], this.toasts = [], this.dismissedToasts = new Set } }, ju = e => e && "object" === typeof e && "ok" in e && "boolean" === typeof e.ok && "status" in e && "number" === typeof e.status, Nu = (e, t) => { const n = (null == t ? void 0 : t.id) || Cu++; return Pu.addToast({ title: e, ...t, id: n }), n }, Mu = Object.assign(Nu, { success: Pu.success, info: Pu.info, warning: Pu.warning, error: Pu.error, custom: Pu.custom, message: Pu.message, promise: Pu.promise, dismiss: Pu.dismiss, loading: Pu.loading }, { getHistory: () => Pu.toasts, getToasts: () => Pu.getActiveToasts() }); function Tu(e) { return void 0 !== e.label } !function (e) { if (!e || "undefined" == typeof document) return; let t = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style"); n.type = "text/css", t.appendChild(n), n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e)) }("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}[data-sonner-toaster][data-lifted=true]{transform:translateY(-8px)}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}"); const Iu = 3, Lu = 14; function Ru() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return t.filter(Boolean).join(" ") } const Du = e => { var t, n, r, o, a, s, l, c, u; const { invert: d, toast: h, unstyled: f, interacting: p, setHeights: m, visibleToasts: g, heights: v, index: y, toasts: b, expanded: x, removeToast: w, defaultRichColors: k, closeButton: S, style: A, cancelButtonStyle: E, actionButtonStyle: C, className: P = "", descriptionClassName: j = "", duration: N, position: M, gap: T, expandByDefault: I, classNames: L, icons: R, closeButtonAriaLabel: D = "Close toast" } = e, [z, O] = i.useState(null), [B, F] = i.useState(null), [V, U] = i.useState(!1), [W, H] = i.useState(!1), [Y, X] = i.useState(!1), [Q, q] = i.useState(!1), [Z, K] = i.useState(!1), [G, J] = i.useState(0), [_, $] = i.useState(0), ee = i.useRef(h.duration || N || 4e3), te = i.useRef(null), ne = i.useRef(null), re = 0 === y, ie = y + 1 <= g, oe = h.type, ae = !1 !== h.dismissible, se = h.className || "", le = h.descriptionClassName || "", ce = i.useMemo((() => v.findIndex((e => e.toastId === h.id)) || 0), [v, h.id]), ue = i.useMemo((() => { var e; return null != (e = h.closeButton) ? e : S }), [h.closeButton, S]), de = i.useMemo((() => h.duration || N || 4e3), [h.duration, N]), he = i.useRef(0), fe = i.useRef(0), pe = i.useRef(0), me = i.useRef(null), [ge, ve] = M.split("-"), ye = i.useMemo((() => v.reduce(((e, t, n) => n >= ce ? e : e + t.height), 0)), [v, ce]), be = (() => { const [e, t] = i.useState(document.hidden); return i.useEffect((() => { const e = () => { t(document.hidden) }; return document.addEventListener("visibilitychange", e), () => window.removeEventListener("visibilitychange", e) }), []), e })(), xe = h.invert || d, we = "loading" === oe; fe.current = i.useMemo((() => ce * T + ye), [ce, ye]), i.useEffect((() => { ee.current = de }), [de]), i.useEffect((() => { U(!0) }), []), i.useEffect((() => { const e = ne.current; if (e) { const t = e.getBoundingClientRect().height; return $(t), m((e => [{ toastId: h.id, height: t, position: h.position }, ...e])), () => m((e => e.filter((e => e.toastId !== h.id)))) } }), [m, h.id]), i.useLayoutEffect((() => { if (!V) return; const e = ne.current, t = e.style.height; e.style.height = "auto"; const n = e.getBoundingClientRect().height; e.style.height = t, $(n), m((e => e.find((e => e.toastId === h.id)) ? e.map((e => e.toastId === h.id ? { ...e, height: n } : e)) : [{ toastId: h.id, height: n, position: h.position }, ...e])) }), [V, h.title, h.description, m, h.id]); const ke = i.useCallback((() => { H(!0), J(fe.current), m((e => e.filter((e => e.toastId !== h.id)))), setTimeout((() => { w(h) }), 200) }), [h, w, m, fe]); i.useEffect((() => { if (h.promise && "loading" === oe || h.duration === 1 / 0 || "loading" === h.type) return; let e; return x || p || be ? (() => { if (pe.current < he.current) { const e = (new Date).getTime() - he.current; ee.current = ee.current - e } pe.current = (new Date).getTime() })() : ee.current !== 1 / 0 && (he.current = (new Date).getTime(), e = setTimeout((() => { null == h.onAutoClose || h.onAutoClose.call(h, h), ke() }), ee.current)), () => clearTimeout(e) }), [x, p, h, oe, be, ke]), i.useEffect((() => { h.delete && ke() }), [ke, h.delete]); const Se = h.icon || (null == R ? void 0 : R[oe]) || (e => { switch (e) { case "success": return wu; case "info": return Su; case "warning": return ku; case "error": return Au; default: return null } })(oe); var Ae, Ee; return i.createElement("li", { tabIndex: 0, ref: ne, className: Ru(P, se, null == L ? void 0 : L.toast, null == h || null == (t = h.classNames) ? void 0 : t.toast, null == L ? void 0 : L.default, null == L ? void 0 : L[oe], null == h || null == (n = h.classNames) ? void 0 : n[oe]), "data-sonner-toast": "", "data-rich-colors": null != (Ae = h.richColors) ? Ae : k, "data-styled": !Boolean(h.jsx || h.unstyled || f), "data-mounted": V, "data-promise": Boolean(h.promise), "data-swiped": Z, "data-removed": W, "data-visible": ie, "data-y-position": ge, "data-x-position": ve, "data-index": y, "data-front": re, "data-swiping": Y, "data-dismissible": ae, "data-type": oe, "data-invert": xe, "data-swipe-out": Q, "data-swipe-direction": B, "data-expanded": Boolean(x || I && V), style: { "--index": y, "--toasts-before": y, "--z-index": b.length - y, "--offset": "".concat(W ? G : fe.current, "px"), "--initial-height": I ? "auto" : "".concat(_, "px"), ...A, ...h.style }, onDragEnd: () => { X(!1), O(null), me.current = null }, onPointerDown: e => { !we && ae && (te.current = new Date, J(fe.current), e.target.setPointerCapture(e.pointerId), "BUTTON" !== e.target.tagName && (X(!0), me.current = { x: e.clientX, y: e.clientY })) }, onPointerUp: () => { var e, t, n; if (Q || !ae) return; me.current = null; const r = Number((null == (e = ne.current) ? void 0 : e.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), i = Number((null == (t = ne.current) ? void 0 : t.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), o = (new Date).getTime() - (null == (n = te.current) ? void 0 : n.getTime()), a = "x" === z ? r : i, s = Math.abs(a) / o; if (Math.abs(a) >= 45 || s > .11) return J(fe.current), null == h.onDismiss || h.onDismiss.call(h, h), F("x" === z ? r > 0 ? "right" : "left" : i > 0 ? "down" : "up"), ke(), void q(!0); var l, c; null == (l = ne.current) || l.style.setProperty("--swipe-amount-x", "0px"), null == (c = ne.current) || c.style.setProperty("--swipe-amount-y", "0px"), K(!1), X(!1), O(null) }, onPointerMove: t => { var n, r, i; if (!me.current || !ae) return; if ((null == (n = window.getSelection()) ? void 0 : n.toString().length) > 0) return; const o = t.clientY - me.current.y, a = t.clientX - me.current.x; var s; const l = null != (s = e.swipeDirections) ? s : function (e) { const [t, n] = e.split("-"), r = []; return t && r.push(t), n && r.push(n), r }(M); !z && (Math.abs(a) > 1 || Math.abs(o) > 1) && O(Math.abs(a) > Math.abs(o) ? "x" : "y"); let c = { x: 0, y: 0 }; const u = e => 1 / (1.5 + Math.abs(e) / 20); if ("y" === z) { if (l.includes("top") || l.includes("bottom")) if (l.includes("top") && o < 0 || l.includes("bottom") && o > 0) c.y = o; else { const e = o * u(o); c.y = Math.abs(e) < Math.abs(o) ? e : o } } else if ("x" === z && (l.includes("left") || l.includes("right"))) if (l.includes("left") && a < 0 || l.includes("right") && a > 0) c.x = a; else { const e = a * u(a); c.x = Math.abs(e) < Math.abs(a) ? e : a } (Math.abs(c.x) > 0 || Math.abs(c.y) > 0) && K(!0), null == (r = ne.current) || r.style.setProperty("--swipe-amount-x", "".concat(c.x, "px")), null == (i = ne.current) || i.style.setProperty("--swipe-amount-y", "".concat(c.y, "px")) } }, ue && !h.jsx && "loading" !== oe ? i.createElement("button", { "aria-label": D, "data-disabled": we, "data-close-button": !0, onClick: we || !ae ? () => { } : () => { ke(), null == h.onDismiss || h.onDismiss.call(h, h) }, className: Ru(null == L ? void 0 : L.closeButton, null == h || null == (r = h.classNames) ? void 0 : r.closeButton) }, null != (Ee = null == R ? void 0 : R.close) ? Ee : Eu) : null, (oe || h.icon || h.promise) && null !== h.icon && (null !== (null == R ? void 0 : R[oe]) || h.icon) ? i.createElement("div", { "data-icon": "", className: Ru(null == L ? void 0 : L.icon, null == h || null == (o = h.classNames) ? void 0 : o.icon) }, h.promise || "loading" === h.type && !h.icon ? h.icon || function () { var e, t; return (null == R ? void 0 : R.loading) ? i.createElement("div", { className: Ru(null == L ? void 0 : L.loader, null == h || null == (t = h.classNames) ? void 0 : t.loader, "sonner-loader"), "data-visible": "loading" === oe }, R.loading) : i.createElement(xu, { className: Ru(null == L ? void 0 : L.loader, null == h || null == (e = h.classNames) ? void 0 : e.loader), visible: "loading" === oe }) }() : null, "loading" !== h.type ? Se : null) : null, i.createElement("div", { "data-content": "", className: Ru(null == L ? void 0 : L.content, null == h || null == (a = h.classNames) ? void 0 : a.content) }, i.createElement("div", { "data-title": "", className: Ru(null == L ? void 0 : L.title, null == h || null == (s = h.classNames) ? void 0 : s.title) }, h.jsx ? h.jsx : "function" === typeof h.title ? h.title() : h.title), h.description ? i.createElement("div", { "data-description": "", className: Ru(j, le, null == L ? void 0 : L.description, null == h || null == (l = h.classNames) ? void 0 : l.description) }, "function" === typeof h.description ? h.description() : h.description) : null), i.isValidElement(h.cancel) ? h.cancel : h.cancel && Tu(h.cancel) ? i.createElement("button", { "data-button": !0, "data-cancel": !0, style: h.cancelButtonStyle || E, onClick: e => { Tu(h.cancel) && ae && (null == h.cancel.onClick || h.cancel.onClick.call(h.cancel, e), ke()) }, className: Ru(null == L ? void 0 : L.cancelButton, null == h || null == (c = h.classNames) ? void 0 : c.cancelButton) }, h.cancel.label) : null, i.isValidElement(h.action) ? h.action : h.action && Tu(h.action) ? i.createElement("button", { "data-button": !0, "data-action": !0, style: h.actionButtonStyle || C, onClick: e => { Tu(h.action) && (null == h.action.onClick || h.action.onClick.call(h.action, e), e.defaultPrevented || ke()) }, className: Ru(null == L ? void 0 : L.actionButton, null == h || null == (u = h.classNames) ? void 0 : u.actionButton) }, h.action.label) : null) }; function zu() { if ("undefined" === typeof window) return "ltr"; if ("undefined" === typeof document) return "ltr"; const e = document.documentElement.getAttribute("dir"); return "auto" !== e && e ? e : window.getComputedStyle(document.documentElement).direction } function Ou(e, t) { const n = {}; return [e, t].forEach(((e, t) => { const r = 1 === t, i = r ? "--mobile-offset" : "--offset", o = r ? "16px" : "24px"; function a(e) { ["top", "right", "bottom", "left"].forEach((t => { n["".concat(i, "-").concat(t)] = "number" === typeof e ? "".concat(e, "px") : e })) } "number" === typeof e || "string" === typeof e ? a(e) : "object" === typeof e ? ["top", "right", "bottom", "left"].forEach((t => { void 0 === e[t] ? n["".concat(i, "-").concat(t)] = o : n["".concat(i, "-").concat(t)] = "number" === typeof e[t] ? "".concat(e[t], "px") : e[t] })) : a(o) })), n } const Bu = i.forwardRef((function (e, t) { const { invert: n, position: r = "bottom-right", hotkey: o = ["altKey", "KeyT"], expand: a, closeButton: l, className: c, offset: u, mobileOffset: d, theme: h = "light", richColors: f, duration: p, style: m, visibleToasts: g = Iu, toastOptions: v, dir: y = zu(), gap: b = Lu, icons: x, containerAriaLabel: w = "Notifications" } = e, [k, S] = i.useState([]), A = i.useMemo((() => Array.from(new Set([r].concat(k.filter((e => e.position)).map((e => e.position)))))), [k, r]), [E, C] = i.useState([]), [P, j] = i.useState(!1), [N, M] = i.useState(!1), [T, I] = i.useState("system" !== h ? h : "undefined" !== typeof window && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), L = i.useRef(null), R = o.join("+").replace(/Key/g, "").replace(/Digit/g, ""), D = i.useRef(null), z = i.useRef(!1), O = i.useCallback((e => { S((t => { var n; return (null == (n = t.find((t => t.id === e.id))) ? void 0 : n.delete) || Pu.dismiss(e.id), t.filter((t => { let { id: n } = t; return n !== e.id })) })) }), []); return i.useEffect((() => Pu.subscribe((e => { e.dismiss ? requestAnimationFrame((() => { S((t => t.map((t => t.id === e.id ? { ...t, delete: !0 } : t)))) })) : setTimeout((() => { s.flushSync((() => { S((t => { const n = t.findIndex((t => t.id === e.id)); return -1 !== n ? [...t.slice(0, n), { ...t[n], ...e }, ...t.slice(n + 1)] : [e, ...t] })) })) })) }))), [k]), i.useEffect((() => { if ("system" !== h) return void I(h); if ("system" === h && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? I("dark") : I("light")), "undefined" === typeof window) return; const e = window.matchMedia("(prefers-color-scheme: dark)"); try { e.addEventListener("change", (e => { let { matches: t } = e; I(t ? "dark" : "light") })) } catch (t) { e.addListener((e => { let { matches: t } = e; try { I(t ? "dark" : "light") } catch (tc) { console.error(tc) } })) } }), [h]), i.useEffect((() => { k.length <= 1 && j(!1) }), [k]), i.useEffect((() => { const e = e => { var t; var n; o.every((t => e[t] || e.code === t)) && (j(!0), null == (n = L.current) || n.focus()); "Escape" !== e.code || document.activeElement !== L.current && !(null == (t = L.current) ? void 0 : t.contains(document.activeElement)) || j(!1) }; return document.addEventListener("keydown", e), () => document.removeEventListener("keydown", e) }), [o]), i.useEffect((() => { if (L.current) return () => { D.current && (D.current.focus({ preventScroll: !0 }), D.current = null, z.current = !1) } }), [L.current]), i.createElement("section", { ref: t, "aria-label": "".concat(w, " ").concat(R), tabIndex: -1, "aria-live": "polite", "aria-relevant": "additions text", "aria-atomic": "false", suppressHydrationWarning: !0 }, A.map(((t, r) => { var o; const [s, h] = t.split("-"); return k.length ? i.createElement("ol", { key: t, dir: "auto" === y ? zu() : y, tabIndex: -1, ref: L, className: c, "data-sonner-toaster": !0, "data-sonner-theme": T, "data-y-position": s, "data-lifted": P && k.length > 1 && !a, "data-x-position": h, style: { "--front-toast-height": "".concat((null == (o = E[0]) ? void 0 : o.height) || 0, "px"), "--width": "".concat(356, "px"), "--gap": "".concat(b, "px"), ...m, ...Ou(u, d) }, onBlur: e => { z.current && !e.currentTarget.contains(e.relatedTarget) && (z.current = !1, D.current && (D.current.focus({ preventScroll: !0 }), D.current = null)) }, onFocus: e => { e.target instanceof HTMLElement && "false" === e.target.dataset.dismissible || z.current || (z.current = !0, D.current = e.relatedTarget) }, onMouseEnter: () => j(!0), onMouseMove: () => j(!0), onMouseLeave: () => { N || j(!1) }, onDragEnd: () => j(!1), onPointerDown: e => { e.target instanceof HTMLElement && "false" === e.target.dataset.dismissible || M(!0) }, onPointerUp: () => M(!1) }, k.filter((e => !e.position && 0 === r || e.position === t)).map(((r, o) => { var s, c; return i.createElement(Du, { key: r.id, icons: x, index: o, toast: r, defaultRichColors: f, duration: null != (s = null == v ? void 0 : v.duration) ? s : p, className: null == v ? void 0 : v.className, descriptionClassName: null == v ? void 0 : v.descriptionClassName, invert: n, visibleToasts: g, closeButton: null != (c = null == v ? void 0 : v.closeButton) ? c : l, interacting: N, position: t, style: null == v ? void 0 : v.style, unstyled: null == v ? void 0 : v.unstyled, classNames: null == v ? void 0 : v.classNames, cancelButtonStyle: null == v ? void 0 : v.cancelButtonStyle, actionButtonStyle: null == v ? void 0 : v.actionButtonStyle, closeButtonAriaLabel: null == v ? void 0 : v.closeButtonAriaLabel, removeToast: O, toasts: k.filter((e => e.position == r.position)), heights: E.filter((e => e.position == r.position)), setHeights: C, expandByDefault: a, gap: b, expanded: P, swipeDirections: e.swipeDirections }) }))) : null }))) })), Fu = n.p + "static/media/logo.17c595847422deb7abc3.png", Vu = [{ name: "Integration Docs", href: "https://magmar-toolkit.gitbook.io/sdk-integration" }, { name: "Whitepaper", href: "https://magmar-1.gitbook.io/magmar" }, { name: "Company Formation Docs", href: "https://drive.google.com/file/d/11V-FcuZPSA3XjGPL93U0t_qiu7F-9VT4/view?usp=sharing" }, { name: "Pitchdeck", href: "https://drive.google.com/file/d/1D4UgW9lHsVq1xDdWyU28RrSJwqhJpFhd/view?usp=sharing" }, { name: "Terms of service", href: "/terms-of-service" }, { name: "Privacy Policy", href: "/privacy-policy" }], Uu = [{ name: "Blog", href: "/blog" }, { name: "FAQs", href: "/faqs" }, { name: "Glossary", href: "/glossary" }, { name: "Media Kit", href: "/media-kit" }], Wu = () => { const [e, t] = (0, i.useState)(!1), n = (0, i.useRef)(null); return (0, Me.jsxs)("div", { className: "relative group", onMouseEnter: () => { n.current && clearTimeout(n.current), t(!0) }, onMouseLeave: () => { n.current = setTimeout((() => { t(!1) }), 200) }, children: [(0, Me.jsxs)("button", { className: "relative hover:text-white transition-colors duration-300 flex items-center gap-1 z-[]", children: ["Docs", (0, Me.jsx)(vu, { className: "text-lg transition-transform duration-300 group-hover:rotate-180" }), (0, Me.jsx)("span", { className: "absolute bottom-0 left-0 w-0 h-0.5 bg-white transition-all duration-300 group-hover:w-full" })] }), e && (0, Me.jsx)("div", { className: "absolute top-full left-0 mt-2 w-[250px] bg-black/90 backdrop-blur-md rounded-lg py-2 shadow-lg border border-white/10", children: Vu.map(((e, t) => (0, Me.jsx)("a", { href: e.href, target: "_blank", rel: "noopener noreferrer", className: "block px-4 py-2 text-sm transition-colors text-white/80 hover:text-white hover:bg-white/10", children: e.name }, t))) })] }) }, Hu = () => { const [e, t] = (0, i.useState)(!1), n = (0, i.useRef)(null); return (0, Me.jsxs)("div", { className: "relative group", onMouseEnter: () => { n.current && clearTimeout(n.current), t(!0) }, onMouseLeave: () => { n.current = setTimeout((() => { t(!1) }), 200) }, children: [(0, Me.jsxs)("button", { className: "relative hover:text-white transition-colors duration-300 flex items-center gap-1 z-[]", children: ["Resources", (0, Me.jsx)(vu, { className: "text-lg transition-transform duration-300 group-hover:rotate-180" }), (0, Me.jsx)("span", { className: "absolute bottom-0 left-0 w-0 h-0.5 bg-white transition-all duration-300 group-hover:w-full" })] }), e && (0, Me.jsx)("div", { className: "absolute top-full left-0 mt-2 w-[250px] bg-black/90 backdrop-blur-md rounded-lg py-2 shadow-lg border border-white/10", children: Uu.map(((e, t) => (0, Me.jsx)("a", { href: e.href, target: "_blank", rel: "noopener noreferrer", className: "block px-4 py-2 text-sm transition-colors text-white/80 hover:text-white hover:bg-white/10", children: e.name }, t))) })] }) }, Yu = () => { const [e, t] = (0, i.useState)(!1), n = (0, i.useRef)(null); return (0, Me.jsxs)("div", { className: "relative group", onMouseEnter: () => { n.current && clearTimeout(n.current), t(!0) }, onMouseLeave: () => { n.current = setTimeout((() => { t(!1) }), 200) }, children: [(0, Me.jsx)("button", { className: "mt-1 text-white transition-colors duration-300 transform hover:text-white hover:scale-110", children: (0, Me.jsx)(fu, { className: "text-[22px]" }) }), e && (0, Me.jsxs)("div", { className: "absolute top-full left-0 mt-2 w-[200px] bg-black/90 backdrop-blur-md rounded-lg py-2 shadow-lg border border-white/10", children: [(0, Me.jsx)("a", { href: "https://www.linkedin.com/company/magmarinfra/", target: "_blank", rel: "noopener noreferrer", className: "block px-4 py-2 text-sm transition-colors text-white/80 hover:text-white hover:bg-white/10", children: "Company" }), (0, Me.jsx)("a", { href: "https://www.linkedin.com/in/b-venkatesh-b0b839121/", target: "_blank", rel: "noopener noreferrer", className: "block px-4 py-2 text-sm transition-colors text-white/80 hover:text-white hover:bg-white/10", children: "Founder" })] })] }) }; function Xu() { const [e, t] = (0, i.useState)(!1), [n, r] = (0, i.useState)(!1), [o, a] = (0, i.useState)(!1), [s, l] = (0, i.useState)(!1); (0, i.useEffect)((() => { const e = () => { window.innerWidth >= 768 && window.scrollY > 50 ? r(!0) : r(!1) }; return window.addEventListener("scroll", e), window.addEventListener("resize", e), () => { window.removeEventListener("scroll", e), window.removeEventListener("resize", e) } }), []); const c = () => { Mu.success("COMING SOON !!!") }; return (0, Me.jsxs)("div", { className: "relative", children: [(0, Me.jsx)("div", { className: "fixed w-full z-[100000] transition-all duration-500 ".concat(n ? "" : "bg-transparent"), children: (0, Me.jsx)("div", { className: "transition-all duration-500 ".concat(n ? "max-w-[1100px] md:mx-auto mx-5 rounded-full mt-4 bg-black/90 backdrop-blur-md border border-white/10" : "md:max-w-[1440px] md:mx-auto border border-transparent md:bg-transparent bg-black mx-5 md:mt-0 mt-5 md:rounded-none rounded-full "), children: (0, Me.jsxs)("div", { className: "flex justify-between items-center transition-all duration-500 ".concat(n ? "py-3 px-8" : "md:py-6 py-2 px-[5%]"), children: [(0, Me.jsxs)(Pe, { to: "/", className: "flex items-center", children: [(0, Me.jsx)("img", { className: "transition-all duration-500 ".concat(n ? "w-fit h-10" : "w-fit h-12", " object-contain"), src: Fu, alt: "Magmar logo" }), (0, Me.jsx)("h4", { className: "font-bold text-[#fd1d1d] transition-all duration-500 ".concat(n ? "text-xl" : "text-2xl"), children: "Magmar" })] }), (0, Me.jsx)("nav", { className: "hidden md:block", children: (0, Me.jsxs)("ul", { className: "flex items-center gap-8 text-sm text-white/80", children: [(0, Me.jsx)("li", { className: "group", children: (0, Me.jsxs)("a", { href: "/", className: "relative transition-colors duration-300 hover:text-white", children: ["Home", (0, Me.jsx)("span", { className: "absolute bottom-0 left-0 w-0 h-0.5 bg-white transition-all duration-300 group-hover:w-full" })] }) }), (0, Me.jsx)("li", { className: "group", children: (0, Me.jsxs)("a", { href: "#demo", className: "relative transition-colors duration-300 hover:text-white", children: ["Demo", (0, Me.jsx)("span", { className: "absolute bottom-0 left-0 w-0 h-0.5 bg-white transition-all duration-300 group-hover:w-full" })] }) }), (0, Me.jsx)("li", { className: "group", children: (0, Me.jsxs)("a", { href: "#features", className: "relative transition-colors duration-300 hover:text-white", children: ["Features", (0, Me.jsx)("span", { className: "absolute bottom-0 left-0 w-0 h-0.5 bg-white transition-all duration-300 group-hover:w-full" })] }) }), (0, Me.jsx)("li", { className: "group", children: (0, Me.jsx)(Wu, {}) }), (0, Me.jsx)("li", { className: "group", children: (0, Me.jsx)(Hu, {}) }), (0, Me.jsx)("li", { className: "cursor-pointer group", onClick: c, children: (0, Me.jsxs)("span", { className: "relative transition-colors duration-300 hover:text-white", children: ["Chart", (0, Me.jsx)("span", { className: "absolute bottom-0 left-0 w-0 h-0.5 bg-white transition-all duration-300 group-hover:w-full" })] }) }), (0, Me.jsx)("li", { className: "cursor-pointer group", onClick: c, children: (0, Me.jsxs)("a", { href: "https://contractwolf.io/projects/magmar", target: "_blank", rel: "noopener noreferrer", className: "relative transition-colors duration-300 hover:text-white", children: ["KYC", (0, Me.jsx)("span", { className: "absolute bottom-0 left-0 w-0 h-0.5 bg-white transition-all duration-300 group-hover:w-full" })] }) })] }) }), (0, Me.jsxs)("div", { className: "items-center hidden gap-6 md:flex", children: [(0, Me.jsxs)("div", { className: "flex items-center gap-4", children: [(0, Me.jsx)(Yu, {}), (0, Me.jsx)("a", { href: "https://github.com/Magmar-toolkit/magmar-examples", target: "_blank", rel: "noopener noreferrer", className: "text-white transition-colors duration-300 transform hover:text-white hover:scale-110", children: (0, Me.jsx)(mu, { className: "text-xl" }) }), (0, Me.jsx)("a", { href: "https://x.com/Magmarerc", target: "_blank", rel: "noopener noreferrer", className: "text-white transition-colors duration-300 transform hover:text-white hover:scale-110", children: (0, Me.jsx)(cu, { className: "text-xl" }) }), (0, Me.jsx)("a", { href: "https://t.me/magmareth", target: "_blank", rel: "noopener noreferrer", className: "text-white transition-colors duration-300 transform hover:text-white hover:scale-110", children: (0, Me.jsx)(pu, { className: "text-xl" }) })] }), (0, Me.jsx)("a", { href: "https://app.magmarinfra.com/login", target: "_blank", rel: "noopener noreferrer", children: (0, Me.jsx)(fl, { text: "Build with us", className: "transition-transform duration-300 transform rounded-full hover:scale-105", variant: "secondary" }) })] }), (0, Me.jsx)("button", { onClick: () => t(!e), className: "md:hidden text-[30px] text-white hover:text-gray-300 transition-colors", children: e ? (0, Me.jsx)(yu, {}) : (0, Me.jsx)(gu, {}) })] }) }) }), (0, Me.jsx)("div", { className: "".concat(e ? "flex flex-col" : "hidden", " py-6 bg-black/90 backdrop-blur-md fixed top-24 right-0 mx-4 my-2 min-w-[250px] rounded-[20px] sidebar z-[100]"), children: (0, Me.jsxs)("ul", { className: "flex flex-col items-start justify-end flex-1 gap-6 px-6 text-white list-none", children: [(0, Me.jsx)("li", { className: "w-full transition-colors hover:text-white", children: (0, Me.jsx)("a", { href: "/", className: "block w-full", children: "Home" }) }), (0, Me.jsx)("li", { className: "w-full transition-colors hover:text-white", children: (0, Me.jsx)("a", { href: "#demo", className: "block w-full", children: "Demo" }) }), (0, Me.jsx)("li", { className: "w-full transition-colors hover:text-white", children: (0, Me.jsx)("a", { href: "#features", className: "block w-full", children: "Features" }) }), (0, Me.jsxs)("li", { className: "w-full", children: [(0, Me.jsx)("button", { onClick: () => a(!o), className: "flex items-center justify-between w-full transition-colors hover:text-white", children: (0, Me.jsxs)("span", { className: "flex items-center gap-2", children: ["Docs ", (0, Me.jsx)(vu, { className: "text-lg" })] }) }), o && (0, Me.jsx)("div", { className: "flex flex-col w-full gap-3 pl-4 mt-3 border-l border-white/20", children: Vu.map(((e, t) => (0, Me.jsx)("a", { href: e.href, target: "_blank", rel: "noopener noreferrer", className: "block w-full", children: e.name }, t))) })] }), (0, Me.jsxs)("li", { className: "w-full", children: [(0, Me.jsx)("button", { onClick: () => l(!s), className: "flex items-center justify-between w-full transition-colors hover:text-white", children: (0, Me.jsxs)("span", { className: "flex items-center gap-2", children: ["Resources ", (0, Me.jsx)(vu, { className: "text-lg" })] }) }), s && (0, Me.jsx)("div", { className: "flex flex-col w-full gap-3 pl-4 mt-3 border-l border-white/20", children: Uu.map(((e, t) => (0, Me.jsx)("a", { href: e.href, target: "_blank", rel: "noopener noreferrer", className: "block w-full", children: e.name }, t))) })] }), (0, Me.jsx)("li", { className: "w-full transition-colors cursor-pointer hover:text-white", onClick: c, children: "Chart" }), (0, Me.jsx)("li", { className: "w-full", children: (0, Me.jsx)("a", { href: "https://contractwolf.io/projects/magmar", target: "_blank", rel: "noopener noreferrer", className: "relative block w-full transition-colors duration-300 hover:text-white", children: "KYC" }) }), (0, Me.jsxs)("div", { className: "flex gap-6 mt-2", children: [(0, Me.jsx)("a", { href: "https://github.com/Magmar-toolkit/magmar-examples", target: "_blank", rel: "noopener noreferrer", className: "text-white transition-colors duration-300 transform hover:text-white hover:scale-110", children: (0, Me.jsx)(mu, { className: "text-2xl" }) }), (0, Me.jsx)("a", { href: "https://x.com/Magmarerc", target: "_blank", rel: "noopener noreferrer", className: "transition-colors hover:text-white", children: (0, Me.jsx)(cu, { className: "text-2xl" }) }), (0, Me.jsx)("a", { href: "https://t.me/magmareth", target: "_blank", rel: "noopener noreferrer", className: "transition-colors hover:text-white", children: (0, Me.jsx)(pu, { className: "text-2xl" }) })] }), (0, Me.jsx)("div", { className: "w-full mt-4", children: (0, Me.jsx)("a", { href: "https://app.magmarinfra.com/login", target: "_blank", rel: "noopener noreferrer", className: "block w-full", children: (0, Me.jsx)(fl, { text: "Build with us", className: "w-full transition-transform duration-300 transform rounded-full hover:scale-105", variant: "secondary" }) }) })] }) })] }) } function Qu() { const [e, t] = (0, i.useState)(0), [n, r] = (0, i.useState)({}), [o, a] = (0, i.useState)(null), s = ["https://www.youtube.com/embed/eLUpsXXc8jI?si=sFdOT0MckcDccqkv", "https://www.youtube.com/embed/4GGQQjomAnM?si=JZJLC8q5xD138jqH", "https://www.youtube.com/embed/yuSz5hBSIDs?si=DIsbQiE2Ge39hV-I", "https://www.youtube.com/embed/LqvhCwDlnlk?si=4kampBRaFGh8qz0W"], l = (0, i.useRef)(null); return (0, Me.jsxs)("div", { id: "demo", className: "flex flex-col items-center gap-4 mb-[50px] md:mb-[100px] px-5 h-full", children: [Object.values(n).some(Boolean) && (0, Me.jsx)("div", { className: "fixed inset-0 bg-black/30 z-[150]", onClick: () => { var e; const t = null === (e = Object.entries(n).find((e => { let [t, n] = e; return n }))) || void 0 === e ? void 0 : e[0]; void 0 !== t && r((e => ({ ...e, [t]: !1 }))) } }), (0, Me.jsx)("h1", { className: "bg-clip-text md:text-[30px] text-[24px] font-black text-transparent font-[family-name:var(--font-belgro)] uppercase text-white text-center leading-[115%] md:w-[800px] mb-10", children: ["Inside Magmar: B Venkatesh Answers the Big Questions", "How to Integrate MagMar SDK in Minutes | Gasless Transactions Made Easy (ERC-4337)", "Magmar SDK | Build Web3 Experiences with AI + Account Abstraction (ERC-4337)", "MagMar Wallet Built on ERC-4337 | Gasless, Secure & Developer-Ready"][e] }), (0, Me.jsx)("div", { className: "w-full overflow-x-auto scrollbar-hide", ref: l, style: { scrollbarWidth: "none", msOverflowStyle: "none" }, children: (0, Me.jsx)("div", { className: "flex gap-20 min-w-max p-4 md:ml-[calc(50%-375px)]", children: s.map(((i, o) => (0, Me.jsx)("div", { className: "\n                w-full md:w-[750px] p-4 transition-all duration-300\n                ".concat(e === o ? "z-10" : "md:blur-sm", "\n              "), children: (0, Me.jsxs)("div", { className: "border border-[#ffffff2e] rounded-[20px] transition-all duration-300 relative md:h-[370px] ".concat(e === o ? "md:scale-110" : "md:scale-90"), children: [i.includes("youtube.com") || i.includes(".mp4") ? (0, Me.jsx)("iframe", { src: i, className: "w-full h-full rounded-[20px]", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", allowFullScreen: !0 }) : (0, Me.jsx)("img", { src: i, alt: "Coming Soon", className: "w-full h-full rounded-[20px] object-cover" }), !n[o] && (0, Me.jsx)("div", { className: "absolute inset-0 flex items-center justify-center rounded-[20px] cursor-pointer", onClick: () => (e => { t(e); const n = s[e] + "&autoplay=1"; a(n), r((t => ({ ...t, [e]: !0 }))); const i = l.current; if (i) { const t = i.children[0].children[e], n = i.offsetWidth, r = t.offsetWidth, o = t.offsetLeft - (n - r) / 2; i.scrollTo({ left: o, behavior: "smooth" }) } })(o) })] }) }, o))) }) }), Object.entries(n).map((e => { let [t, n] = e; return n ? (0, Me.jsxs)("div", { className: " fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[96vw] max-w-[1200px] h-auto aspect-video z-[200] flex items-center justify-center p-2 ", style: { maxHeight: "90vh" }, children: [(0, Me.jsx)("iframe", { src: s[t] + "&autoplay=1", className: "w-full h-full rounded-[20px] bg-black", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", allowFullScreen: !0, style: { maxHeight: "90vh" } }), (0, Me.jsx)("button", { className: "absolute p-2 text-white rounded-full top-2 right-2 md:top-4 md:right-4 bg-black/50 hover:bg-black/70", onClick: () => r((e => ({ ...e, [t]: !1 }))), children: (0, Me.jsx)("svg", { xmlns: "http://www.w3.org/2000/svg", className: "w-6 h-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: (0, Me.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) })] }, t) : null })), (0, Me.jsx)("div", { className: "flex gap-2 ", children: s.map(((n, r) => (0, Me.jsx)("button", { onClick: () => (e => { t(e); const n = l.current, r = n.children[0].children[e], i = n.offsetWidth, o = r.offsetWidth, a = r.offsetLeft - (i - o) / 2; n.scrollTo({ left: a, behavior: "smooth" }) })(r), className: "\n              w-[35px] h-[35px] flex items-center justify-center text-white border\n              ".concat(e === r ? "border-[#FD1D1D]" : "border-[#ffffff2e]", "\n              hover:border hover:border-[#FD1D1D] transition-colors rounded-full\n            "), children: r + 1 }, r))) })] }) } const qu = n.p + "static/media/mask.8a049bf7ab76b24c521f1ed140168723.svg", Zu = n.p + "static/media/Venkatesh.e8cadd9804b1987b1df4.png", Ku = n.p + "static/media/mansory.09062f6623ccdeacb99b.png", Gu = [{ name: "B Venkatesh", role: "CEO MAGMAR", bio: "Founder at Magmar | Ex- Mira Network | Ex-Integrations Engineer at Biconomy | Ex-Technical Lead at 5irechain | Ex-Blockchain Developer at Router Protocol | Polygon Fellow 2022", image: Zu, linkedin: !0, linkedinUrl: "https://www.linkedin.com/in/b-venkatesh-b0b839121/", twitter: !0, telegram: !0, telegramUrl: "https://t.me/venky_joster", twitterUrl: "https://x.com/_venmus_" }, { name: "Steve", role: "Operations at Magmar Infra LLC", bio: "Steve, ex-Ecosystem Dev at Rainbow, now leads Ops at Magmar Infra LLC, aligning systems and scaling infra while bridging tech and strategy in Web3 projects.", image: Fu, linkedin: !1, twitter: !1, telegram: !0, telegramUrl: "https://t.me/stevemagmar" }, { name: "Arthur", role: "Backend", bio: "Arthur, leads the development and implementation of cutting-edge infrastructure and smart wallet technologies powered by ERC-4337", image: "/team/arthur.jpeg", linkedin: !0, twitter: !1, telegram: !1, linkedinUrl: "https://www.linkedin.com/in/arthur-leguen-7b995b345/" }, { name: "Alejandro Malcom", role: "Junior Business Development.", bio: "Leads business development and Integrations at Magmar", image: "/team/alejandro.jpeg", linkedin: !0, twitter: !1, telegram: !1, linkedinUrl: "https://www.linkedin.com/in/alejandro-morera-malcolm-49816916a/" }, { name: "Zain", role: "CBO (Business & Ecosystem)", bio: "4+ years in Web3 BD. Leads dApp onboarding, partnerships, and GTM strategy across DeFi, DePIN, and RWA.", image: "/logo.png", linkedin: !1, twitter: !1, telegram: !1 }, { name: "Mansory", role: "Advisor at Magmar", bio: "Mansory, in crypto since 2017, helps high-potential teams grow. At Magmar, he advises on KOLs and long-term marketing strategies.", image: Ku, linkedin: !1, twitter: !0, telegram: !0, telegramUrl: "https://t.me/Mansorycrypto_Official", twitterUrl: "https://x.com/Mansorycrypto__" }, { name: "Blade", role: "Director of Partnerships", bio: "Focused on strategic alliances and protocol collaborations. Experienced in driving growth across ecosystems.", image: "/team/blade.jpg", linkedin: !1, twitter: !0, telegram: !0, telegramUrl: "https://t.me/thetronerr", twitterUrl: "https://x.com/ShukriyahLee" }, { name: "El Davan", role: "Head of Growth & Community", bio: "Leads user acquisition, mod teams, and social engagement. Focused on scaling with authenticity and influence.", image: "/team/el-davan.jpg", linkedin: !1, twitter: !1, telegram: !0, telegramUrl: "https://t.me/yaegerweb3" }], Ju = e => { let { member: t } = e; return (0, Me.jsxs)("div", { className: "team-bg rounded-[27px] h-[500px] w-full relative group overflow-hidden cursor-pointer flex-shrink-0", children: [(0, Me.jsx)("div", { className: "w-[401px] h-[72px] bg-[#331400] rounded-b-[27px] blur-[40px] absolute -bottom-5" }), (0, Me.jsx)("img", { className: "object-cover w-full h-full", src: t.image, alt: t.name }), (0, Me.jsxs)("div", { className: "absolute bottom-0 left-0 right-0 p-6 rounded-[20px] transition-transform duration-700 ease-in-out transform translate-y-0 group-hover:translate-y-[-400px] z-10 font-[family-name:var(--font-sofia-sans)]", children: [(0, Me.jsx)("h3", { className: "text-[22px] text-[#F7F7F7]", children: t.name }), (0, Me.jsx)("p", { className: "font-medium text-white uppercase", children: t.role })] }), (0, Me.jsx)("div", { className: "absolute inset-0 bg-[#AD2A01] rounded-[20px] transform translate-y-full transition-transform duration-700 ease-in-out group-hover:translate-y-0", children: (0, Me.jsxs)("div", { className: "relative w-full h-full p-6", children: [(0, Me.jsx)("img", { src: qu, alt: "pattern", className: "absolute object-cover w-full h-full" }), (0, Me.jsxs)("div", { className: "relative flex flex-col justify-end h-full", children: [(0, Me.jsxs)("div", { className: "flex gap-3 mt-2", children: [t.linkedin && (0, Me.jsx)("a", { href: t.linkedinUrl, target: "_blank", rel: "noopener noreferrer", className: "text-white hover:text-[#000000] transition-colors", children: (0, Me.jsx)(lu, { size: 24 }) }), t.twitter && (0, Me.jsx)("a", { href: t.twitterUrl, target: "_blank", rel: "noopener noreferrer", className: "text-white hover:text-[#000000] transition-colors", children: (0, Me.jsx)(cu, { size: 24 }) }), t.telegramUrl && (0, Me.jsx)("a", { href: t.telegramUrl, target: "_blank", rel: "noopener noreferrer", className: "text-white hover:text-[#000000] transition-colors", children: (0, Me.jsx)(pu, { size: 24 }) })] }), (0, Me.jsx)("p", { className: "text-white font-[family-name:var(--font-sofia-sans)] mt-4 text-sm leading-relaxed", children: t.bio })] })] }) })] }) }, _u = () => { const [e, t] = (0, i.useState)(0), n = (0, i.useRef)(null), r = "undefined" !== typeof window ? window.innerWidth >= 1024 ? 350 : window.innerWidth >= 768 ? 300 : 280 : 350, o = (() => { if ("undefined" !== typeof window) { const e = Math.min(window.innerWidth - 32, 1280); return Math.floor(e / (r + 24)) } return 1 })(), a = Math.max(0, Gu.length - o); return (0, i.useEffect)((() => { const e = () => { const e = Math.max(0, Gu.length - (() => { if ("undefined" !== typeof window) { const e = Math.min(window.innerWidth - 32, 1280), t = window.innerWidth >= 1024 ? 350 : window.innerWidth >= 768 ? 300 : 280; return Math.floor(e / (t + 24)) } return 1 })()); t((t => Math.min(t, e))) }; return window.addEventListener("resize", e), () => window.removeEventListener("resize", e) }), []), (0, Me.jsxs)("div", { className: "flex flex-col items-center justify-center w-full px-4 py-12", children: [(0, Me.jsxs)("div", { className: "mb-12 text-center", children: [(0, Me.jsx)("h2", { className: "mb-4 text-4xl font-bold text-white", children: "Our Team" }), (0, Me.jsx)("p", { className: "max-w-2xl mx-auto text-gray-300", children: "Meet the talented individuals behind MAGMAR" })] }), (0, Me.jsxs)("div", { className: "relative w-full max-w-7xl", children: [(0, Me.jsx)("div", { className: "overflow-hidden", children: (0, Me.jsx)(hl.div, { ref: n, className: "flex gap-6", animate: { x: -(r + 24) * e }, transition: { type: "spring", stiffness: 300, damping: 30 }, style: { width: "".concat(Gu.length * (r + 24), "px") }, children: Gu.map(((e, t) => (0, Me.jsx)("div", { style: { minWidth: "".concat(r, "px") }, children: (0, Me.jsx)(Ju, { member: e }) }, t))) }) }), (0, Me.jsx)("div", { className: "flex justify-center mt-8 space-x-2", children: Array.from({ length: Math.max(1, a + 1) }).map(((n, r) => (0, Me.jsx)("button", { onClick: () => t(Math.min(r, a)), className: "w-3 h-3 rounded-full transition-all duration-300 ".concat(r === e ? "bg-[#AD2A01] scale-125" : "bg-gray-600 hover:bg-gray-400"), "aria-label": "Go to slide ".concat(r + 1) }, r))) }), (0, Me.jsx)("button", { onClick: () => t((e => Math.max(0, e - 1))), disabled: 0 === e, className: "absolute left-4 top-1/2 transform -translate-y-1/2 p-3 rounded-full transition-all duration-300 backdrop-blur-sm ".concat(0 === e ? "bg-gray-600/30 text-gray-500 cursor-not-allowed" : "bg-black/50 hover:bg-black/70 text-white"), "aria-label": "Previous slide", children: (0, Me.jsx)("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: (0, Me.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15 19l-7-7 7-7" }) }) }), (0, Me.jsx)("button", { onClick: () => t((e => Math.min(a, e + 1))), disabled: e >= a, className: "absolute right-4 top-1/2 transform -translate-y-1/2 p-3 rounded-full transition-all duration-300 backdrop-blur-sm ".concat(e >= a ? "bg-gray-600/30 text-gray-500 cursor-not-allowed" : "bg-black/50 hover:bg-black/70 text-white"), "aria-label": "Next slide", children: (0, Me.jsx)("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: (0, Me.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 5l7 7-7 7" }) }) })] })] }) }; function $u() { return (0, Me.jsxs)("div", { className: "relative min-h-screen", children: [(0, Me.jsx)(Bu, { position: "top-right" }), (0, Me.jsx)(Xu, {}), (0, Me.jsx)(pl, {}), (0, Me.jsxs)("div", { className: "relative max-w-[1440px] mx-auto", children: [(0, Me.jsx)(Zc, {}), (0, Me.jsx)(ic, {})] }), (0, Me.jsx)(Qu, {}), (0, Me.jsxs)("div", { className: "relative max-w-[1440px] mx-auto", children: [(0, Me.jsx)(Pc, {}), (0, Me.jsx)(sc, {}), (0, Me.jsx)(_u, {}), (0, Me.jsx)(Vc, {}), (0, Me.jsx)(Gc, {}), (0, Me.jsx)(hu, {})] })] }) } const ed = [{ id: "general", title: "General Overview", questions: [{ id: "what-is-magmar", question: "What is Magmar?", answer: "Magmar is a smart account abstraction infrastructure that enhances blockchain usability by merging smart contracts with externally owned accounts. It enables features like gasless transactions, social recovery, and multi-signature wallets." }, { id: "improve-ux", question: "How does Magmar improve blockchain user experience?", answer: "Magmar abstracts away complex wallet management, allowing users to perform transactions without needing to manage private keys directly or pay gas fees upfront, making blockchain more accessible." }, { id: "supported-blockchains", question: "What blockchains does Magmar support?", answer: "Magmar currently supports Ethereum and EVM-compatible chains, with plans to expand to multiple Layer 2 and sidechains through its Magmar Router." }, { id: "magmar-token", question: "What is the Magmar Token (MAG) used for?", answer: "MAG is the native utility token for governance, paying transaction fees in the ecosystem, staking, and accessing premium features within Magmar smart wallets." }, { id: "security", question: "How secure is Magmar?", answer: "Magmar incorporates multi-signature wallets, social recovery, and role-based access controls to ensure enhanced security for users' assets and transactions." }] }, { id: "account-abstraction", title: "Account Abstraction & Smart Wallets", questions: [{ id: "smart-contract-accounts", question: "What are smart contract accounts in Magmar?", answer: "They are programmable wallets controlled by smart contract logic rather than private keys, enabling features like transaction batching, recovery, and gas sponsorship." }, { id: "social-recovery", question: "How does social recovery work in Magmar wallets?", answer: "Users designate trusted contacts or contracts to assist in recovering access to their wallets if keys are lost or compromised, without relying on seed phrases." }, { id: "gasless-transactions", question: "Can I use gasless transactions with Magmar?", answer: "Yes, the Paymaster system sponsors transaction fees, enabling users to send transactions without holding native blockchain tokens." }, { id: "session-keys", question: "What are session keys?", answer: "Session keys are temporary keys with limited permissions issued by smart wallets, allowing safer interactions with dApps or limited-time access." }, { id: "upgradeable-wallets", question: "Are Magmar wallets upgradeable?", answer: "Yes, smart wallets support zero migration upgrades allowing new features or fixes to be applied without moving assets or recreating wallets." }, { id: "role-based-permissions", question: "What role-based permissions does Magmar support?", answer: "Magmar wallets allow assignment of specific roles such as Admin, Executor, or Recovery Agent, giving granular control over wallet operations." }] }, { id: "paymaster", title: "Paymaster & Gas Fee Abstraction", questions: [{ id: "what-is-paymaster", question: "What is a Paymaster in Magmar?", answer: "A Paymaster is an entity that sponsors transaction fees for users, allowing them to pay gas fees in ERC-20 tokens or have fees subsidized based on their behavior or dApp partnerships." }, { id: "paymaster-selection", question: "How does Magmar's Paymaster system choose which transactions to sponsor?", answer: "The system uses AI-driven behavioral analysis and wallet scores to intelligently subsidize gas fees for eligible users." }, { id: "dapp-integration", question: "Can dApps integrate with the Paymaster system?", answer: "Yes, dApps can integrate to sponsor fees for their users, improving onboarding and reducing friction." }, { id: "payment-tokens", question: "What tokens can be used to pay fees via Magmar Paymasters?", answer: "Primarily ERC-20 tokens supported on the underlying blockchain, with support expanding over time." }, { id: "cross-chain-fees", question: "Does the Paymaster system support cross-chain fee payments?", answer: "Through the Magmar Router, gas abstraction can be handled across supported chains, enabling multi-chain fee sponsorship." }, { id: "run-paymaster", question: "Can I run my Paymaster?", answer: "Yes, Magmar supports third parties running Paymasters to offer fee sponsorship services to specific user groups or dApps." }] }, { id: "security", title: "Security & Recovery", questions: [{ id: "wallet-security", question: "How does Magmar enhance wallet security?", answer: "By combining multi-signature approvals, role-based access, session keys, and behavioral analytics for risk scoring." }, { id: "lost-private-key", question: "What happens if I lose my private key?", answer: "Social recovery mechanisms allow you to regain control by involving trusted guardians or through time-delayed recovery processes." }, { id: "emergency-controls", question: "Are there emergency controls in Magmar wallets?", answer: "Yes, Guardian Contracts act as failsafes to pause or restrict wallet actions in case of suspected compromise." }, { id: "role-access-control", question: "How does role-based access control work?", answer: "Wallet owners can assign roles with different permissions to addresses, enabling delegation while limiting risk." }, { id: "revoke-session-keys", question: "Can I revoke session keys?", answer: "Yes, session keys can be revoked at any time, limiting their lifespan and permissions." }, { id: "fraud-protection", question: "How does Magmar protect against transaction replay or fraud?", answer: "Built-in failproof UX layers and AI-driven transaction analysis detect anomalies and prevent malicious activity." }, { id: "contract-bugs", question: "Are smart wallets protected from contract bugs?", answer: "Upgradeable wallets allow patching logic without asset migration, reducing risk from contract vulnerabilities." }] }]; function td() { const [e, t] = (0, i.useState)(""), [n, r] = (0, i.useState)(null), o = ed.flatMap((e => e.questions.map((t => ({ ...t, categoryTitle: e.title, categoryId: e.id }))))); (0, i.useEffect)((() => { const e = () => { const e = o.map((e => e.id)), n = window.scrollY + 100; for (let r = e.length - 1; r >= 0; r--) { const i = document.getElementById(e[r]); if (i && i.offsetTop <= n) { t(e[r]); break } } }; return window.addEventListener("scroll", e), e(), () => window.removeEventListener("scroll", e) }), [o]); return (0, Me.jsxs)("div", { className: "min-h-screen text-white", children: [(0, Me.jsx)(Xu, {}), (0, Me.jsx)("div", { className: "min-h-screen pt-[200px]", style: { backgroundImage: "url(".concat(oc, ")"), backgroundSize: "cover", backgroundPosition: "center", backgroundRepeat: "no-repeat", backgroundAttachment: "fixed" }, children: (0, Me.jsxs)("div", { className: "max-w-[1280px] mx-auto flex relative", children: [(0, Me.jsx)("aside", { className: "hidden lg:block w-80 sticky top-0 h-screen overflow-y-auto py-[100px] px-8 border-r border-white/10 scrollbar-hide", children: (0, Me.jsxs)("div", { className: "space-y-1", children: [(0, Me.jsx)("h3", { className: "mb-6 text-lg font-semibold text-white/90", children: "ON THIS PAGE" }), (0, Me.jsx)("nav", { className: "space-y-1", children: ed.map((t => (0, Me.jsxs)("div", { className: "space-y-1", children: [(0, Me.jsx)("div", { className: "px-3 py-2 text-sm font-medium text-white/90", children: t.title }), t.questions.map((t => (0, Me.jsx)("button", { onClick: () => (e => { const t = document.getElementById(e); t && t.scrollIntoView({ behavior: "smooth", block: "start" }) })(t.id), className: "block w-full text-left px-3 py-2 text-sm rounded transition-all duration-200 hover:bg-white/5 hover:text-white ml-2 ".concat(e === t.id ? "text-orange-500 bg-orange-500/10 border-l-2 border-orange-500" : "text-white/70"), children: t.question }, t.id)))] }, t.id))) })] }) }), (0, Me.jsx)("main", { className: "flex-1 px-5 pb-24 lg:px-12", children: (0, Me.jsxs)("div", { className: "max-w-4xl", children: [(0, Me.jsxs)("div", { className: "mb-16", children: [(0, Me.jsx)("h1", { className: "text-5xl lg:text-[82px] leading-[90%] font-medium mb-6", children: "Frequently Asked Questions" }), (0, Me.jsx)("p", { className: "max-w-2xl text-lg leading-relaxed text-white/70", children: "Find answers to common questions about Magmar, our smart account abstraction infrastructure, and how to build powerful, user-friendly blockchain applications using our developer tools." })] }), (0, Me.jsx)("div", { className: "space-y-16", children: ed.map((e => (0, Me.jsxs)("section", { className: "space-y-8", children: [(0, Me.jsx)("h2", { className: "text-3xl font-medium text-white lg:text-4xl", children: e.title }), (0, Me.jsx)("div", { className: "space-y-6", children: e.questions.map((e => (0, Me.jsxs)("div", { id: e.id, className: "overflow-hidden border rounded-lg scroll-mt-24 border-white/10 bg-white/5 backdrop-blur-sm", children: [(0, Me.jsxs)("button", { onClick: () => { return t = e.id, void r(n === t ? null : t); var t }, className: "flex items-center justify-between w-full px-6 py-4 text-left transition-colors duration-200 hover:bg-white/5", children: [(0, Me.jsx)("h3", { className: "pr-4 text-lg font-medium text-white", children: e.question }), (0, Me.jsx)("svg", { className: "w-5 h-5 text-white/70 transition-transform duration-200 ".concat(n === e.id ? "rotate-180" : ""), fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: (0, Me.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" }) })] }), (0, Me.jsx)("div", { className: "overflow-hidden transition-all duration-300 ease-in-out ".concat(n === e.id ? "max-h-96 opacity-100" : "max-h-0 opacity-0"), children: (0, Me.jsx)("div", { className: "px-6 pb-4", children: (0, Me.jsx)("p", { className: "leading-relaxed text-white/80", children: e.answer }) }) })] }, e.id))) })] }, e.id))) }), (0, Me.jsx)("div", { className: "h-32" })] }) })] }) })] }) } const nd = [{ id: "account-abstraction", title: "Account Abstraction", content: "A transformative protocol design that merges the functionalities of Externally Owned Accounts (EOAs) and smart contract accounts into unified, programmable entities. Enables features such as gasless transactions, social recovery, transaction batching, and multi-signature security." }, { id: "smart-contract-accounts", title: "Smart Contract Accounts", content: "Programmable accounts governed by smart contract logic instead of private keys. Enable enhanced user features such as upgradeable logic, embedded security controls, and recovery mechanisms. Serve as the foundation for Magmar's smart wallets." }, { id: "paymaster", title: "Paymaster", content: "An entity within the Magmar protocol that sponsors transaction fees, allowing users to perform operations without needing ETH. Supports payments in ERC-20 tokens and enables gas abstraction, especially valuable for onboarding new users." }, { id: "paymaster-system", title: "Paymaster System", content: "Magmar's implementation of fee abstraction. It intelligently sponsors or subsidizes gas fees based on user behavior, wallet score, or dApp integrations, streamlining the user experience and reducing friction." }, { id: "user-operations", title: "UserOperations", content: "A standardized transaction format used in account abstraction under EIP-4337. Users submit actions off-chain, which are then bundled, validated, and executed on-chain by third-party actors." }, { id: "bundlers", title: "Bundlers", content: "Actors in the Magmar ecosystem that collect multiple UserOperations, validate them, and submit them as batch transactions to the blockchain. Help reduce gas overhead and improve scalability." }, { id: "magmar-wallet-sdk", title: "Magmar Wallet SDK", content: "Developer toolkit to build, deploy, and interact with smart accounts on the Magmar infrastructure. Includes prebuilt modules for social recovery, gasless execution, and plugin extensibility." }, { id: "magmar-token", title: "Magmar Token (MAG)", content: "The native utility token of the Magmar ecosystem, used for governance, transaction fee subsidies, and accessing premium account features." }, { id: "social-recovery", title: "Social Recovery", content: "A mechanism that allows users to recover access to their smart accounts by involving trusted parties or time-delayed methods, reducing reliance on seed phrases or private keys." }, { id: "meta-transactions", title: "Meta-Transactions", content: "Transactions submitted and sponsored by third parties on behalf of a user. Magmar supports meta-transactions via its Paymaster system to improve accessibility and lower entry barriers." }, { id: "session-keys", title: "Session Keys", content: "Temporary, permissioned cryptographic keys issued by a smart contract account to allow limited actions (e.g., within a dApp session) without exposing full control. Enhance both security and UX." }, { id: "action-templates", title: "Action Templates", content: "Reusable logic bundles that allow users or developers to define common workflows (e.g., Swap + Stake + Notify) that can be triggered by a single operation or scheduled event." }, { id: "dynamic-gas-pricing", title: "Dynamic Gas Pricing", content: "An algorithm within Magmar's Paymaster system that adjusts the fee subsidy model based on network load, user trust score, and token availability, optimizing cost-efficiency and accessibility." }, { id: "chain-aware-scheduling", title: "Chain-Aware Scheduling", content: "A multi-chain coordination module that delays or routes transactions depending on current gas conditions or performance metrics of target networks." }, { id: "magmar-router", title: "Magmar Router", content: "The component responsible for handling cross-chain account interactions and gas abstraction. Allows seamless smart account operations across supported EVM-compatible chains." }, { id: "revenue-engine", title: "Revenue Engine", content: "Mechanism for tracking, collecting, and redistributing protocol revenue. Includes modules for staking, developer incentives, and token buyback and burn." }, { id: "smart-wallet-score", title: "Smart Wallet Score", content: "A dynamic metric based on on-chain activity and behavioral analysis. Determines eligibility for gas sponsorship, increased limits, or other incentives within the Magmar ecosystem." }, { id: "guardian-contracts", title: "Guardian Contracts", content: "Secondary contracts tied to a smart account that act as emergency guardians, providing a secure failsafe for initiating account recovery or halting malicious actions." }, { id: "upgradeable-smart-wallets", title: "Upgradeable Smart Wallets", content: "Smart accounts that allow for secure, non-destructive upgrades to their logic without asset migration. Ensures forward compatibility and access to new features." }, { id: "role-based-access-control", title: "Role-Based Access Control (RBAC)", content: "A permission model integrated into Magmar smart wallets allowing assignment of specific roles (e.g., Admin, Executor, Recovery Agent) to different addresses or devices." }, { id: "failproof-ux-layer", title: "Failproof UX Layer", content: "The design layer of Magmar that handles transaction fallbacks, replay protection, and interface-level alerts to ensure smooth wallet interactions even in edge cases." }, { id: "developer-plugin-registry", title: "Developer Plugin Registry", content: "A modular system within the Magmar SDK allowing developers to build and integrate custom functionality into smart accounts, such as custom recovery modules, analytics, or dApp connectors." }, { id: "hot-swappable-modules", title: "Hot-Swappable Modules", content: "Components of a smart account that can be swapped or updated live without interrupting service or compromising user assets, used in both plugins and security features." }, { id: "defi-strategy-engine", title: "DeFi Strategy Engine", content: "An AI-enabled module that proposes or executes optimized yield, staking, or liquidity actions based on the user's risk profile and current market conditions." }, { id: "magmar-revenue-visualizer", title: "Magmar Revenue Visualizer", content: "A front-end dashboard showing real-time protocol earnings, fee usage, user growth, and token circulation. Offers transparency to developers, users, and investors." }, { id: "cross-chain-gas-abstraction", title: "Cross-Chain Gas Abstraction", content: "A feature that allows users to fund and execute transactions across one or more supported chains using a single token balance, managed by the Magmar Router." }, { id: "governance-hooks", title: "Governance Hooks", content: "Trigger-based smart contract functions that automatically perform governance-related actions like voting, delegation, or proposal creation based on user preferences or schedules." }, { id: "safe-extensions", title: "Safe Extensions", content: "Enhanced multi-signature wallet compatibility layers within Magmar that integrate AI-based transaction analysis, risk scoring, and automatic alerting before signature aggregation." }, { id: "smart-wallet-dao-integration", title: "Smart Wallet DAO Integration", content: "Direct interfaces and logic allowing users to participate in decentralized governance directly through their smart wallets, with support for multi-chain proposal management." }, { id: "intelligent-resource-allocation", title: "Intelligent Resource Allocation", content: "AI-driven allocation of gas sponsorships, computation time, and bandwidth across users and smart contracts based on their reputation, usage patterns, and strategic value." }, { id: "magmar-testnet", title: "Magmar Testnet", content: "An experimental environment mirroring the mainnet where developers can deploy and test smart wallets, recovery flows, plugins, and fee abstractions with no financial risk." }, { id: "zero-migration-upgrades", title: "Zero Migration Upgrades", content: "The ability to add new features or patch bugs in smart wallet accounts without requiring users to transfer assets or reinitialize their wallets." }, { id: "magmar-chain-compatibility-layer", title: "Magmar Chain Compatibility Layer", content: "A middleware component that allows smart wallet deployments on different chains while maintaining a uniform interface and functionality." }, { id: "gas-estimation-engine", title: "Gas Estimation Engine", content: "A predictive module that estimates future gas fees for planned operations, enabling users and dApps to time transactions for cost efficiency. Integrated with Magmar's dynamic pricing model." }, { id: "reputation-oracle", title: "Reputation Oracle", content: "A protocol-native service that tracks wallet behavior and aggregates trust signals to feed into the Smart Wallet Score, fee sponsorship eligibility, and DAO privileges." }, { id: "wallet-recovery-graph", title: "Wallet Recovery Graph", content: "A visualization and smart logic engine that maps out recovery flows, trusted guardians, and time-based conditions across the user's smart accounts." }, { id: "mgr-locking-mechanism", title: "MGR Locking Mechanism", content: "Allows users to lock Magmar tokens (MGR) in smart wallets to unlock advanced features, gain voting power, or earn passive rewards through platform engagement." }, { id: "modular-execution-layer", title: "Modular Execution Layer", content: "An architecture layer in Magmar that allows developers to plug in and execute custom logic paths in user transactions without modifying base contracts." }, { id: "signature-throttling", title: "Signature Throttling", content: "A security system that limits signing frequency or enforces timeouts after high-risk actions (e.g., transfers or upgrades) to prevent wallet compromise." }, { id: "time-locked-permissions", title: "Time-Locked Permissions", content: "An extension of role-based access where certain roles are granted temporary privileges that expire automatically, useful for time-sensitive actions." }, { id: "programmable-spending-limits", title: "Programmable Spending Limits", content: "A user-configurable restriction that sets daily/weekly/monthly spending thresholds per smart wallet, address, or token." }, { id: "session-guard", title: "Session Guard", content: "A feature that monitors active wallet sessions and can suspend activity when anomalies or risk behaviors are detected." }, { id: "plugin-verification-protocol", title: "Plugin Verification Protocol", content: "A review and audit system within the Developer Plugin Registry that evaluates plugin safety, resource usage, and compatibility before approval." }, { id: "magmar-signature-aggregator", title: "Magmar Signature Aggregator", content: "A system that aggregates multiple user signatures across wallets and chains, used for collective actions like DAO proposals or batch delegation." }, { id: "action-flow-composer", title: "Action Flow Composer", content: "A visual or code-based editor enabling users and developers to construct custom transaction flows that integrate with DeFi, NFTs, and dApps in one interface." }, { id: "custom-token-gas-sponsor", title: "Custom Token Gas Sponsor", content: "Enables project teams or token issuers to sponsor user gas fees in their own tokens, using Magmar's paymaster framework." }, { id: "magmar-usage-index", title: "Magmar Usage Index (MUI)", content: "A composite metric that tracks smart wallet activity, gas sponsorship efficiency, developer plugin adoption, and cross-chain interactions." }, { id: "chain-snapshot-system", title: "Chain Snapshot System", content: "Captures real-time and historical account states for debugging, analytics, and recovery auditing across different Magmar-compatible chains." }, { id: "failover-bundling", title: "Failover Bundling", content: "A resilience mechanism where Bundlers re-route UserOperations to fallback executors in the event of network congestion or partial failure." }, { id: "magmar-insight-engine", title: "Magmar Insight Engine", content: "An internal analytics system used to surface trends, vulnerabilities, and feature adoption across the Magmar ecosystem." }]; function rd() { const [e, t] = (0, i.useState)(""); (0, i.useEffect)((() => { const e = () => { const e = nd.map((e => e.id)), n = window.scrollY + 100; for (let r = e.length - 1; r >= 0; r--) { const i = document.getElementById(e[r]); if (i && i.offsetTop <= n) { t(e[r]); break } } }; return window.addEventListener("scroll", e), e(), () => window.removeEventListener("scroll", e) }), []); return (0, Me.jsxs)("div", { className: "min-h-screen text-white", children: [(0, Me.jsx)(Xu, {}), (0, Me.jsx)("div", { className: "min-h-screen pt-[200px]", style: { backgroundImage: "url(".concat(oc, ")"), backgroundSize: "cover", backgroundPosition: "center", backgroundRepeat: "no-repeat", backgroundAttachment: "fixed" }, children: (0, Me.jsxs)("div", { className: "max-w-[1280px] mx-auto flex relative", children: [(0, Me.jsx)("aside", { className: "hidden lg:block w-80 sticky top-0 h-screen overflow-y-auto py-[100px] px-8 border-r border-white/10 scrollbar-hide", children: (0, Me.jsxs)("div", { className: "space-y-1", children: [(0, Me.jsx)("h3", { className: "mb-6 text-lg font-semibold text-white/90", children: "ON THIS PAGE" }), (0, Me.jsx)("nav", { className: "space-y-1", children: nd.map((t => (0, Me.jsx)("button", { onClick: () => (e => { const t = document.getElementById(e); t && t.scrollIntoView({ behavior: "smooth", block: "start" }) })(t.id), className: "block w-full text-left px-3 py-2 text-sm rounded transition-all duration-200 hover:bg-white/5 hover:text-white ".concat(e === t.id ? "text-orange-500 bg-orange-500/10 border-l-2 border-orange-500" : "text-white/70"), children: t.title }, t.id))) })] }) }), (0, Me.jsx)("main", { className: "flex-1 px-5 pb-24 lg:px-12", children: (0, Me.jsxs)("div", { className: "max-w-4xl", children: [(0, Me.jsxs)("div", { className: "mb-16", children: [(0, Me.jsx)("h1", { className: "text-5xl lg:text-[82px] leading-[90%] font-medium mb-6", children: "Glossary" }), (0, Me.jsx)("p", { className: "max-w-2xl text-lg leading-relaxed text-white/70", children: "This document provides definitions for the main Magmar concepts and terms, along with their relationships to one another. Familiarity with blockchain infrastructure and smart account abstraction is assumed." })] }), (0, Me.jsx)("div", { className: "space-y-16", children: nd.map((e => (0, Me.jsxs)("section", { id: e.id, className: "scroll-mt-24", children: [(0, Me.jsx)("h2", { className: "text-3xl lg:text-4xl font-medium mb-6 text-white", children: e.title }), (0, Me.jsx)("div", { className: "prose prose-lg max-w-none", children: (0, Me.jsx)("p", { className: "text-white/80 leading-relaxed text-lg", children: e.content }) })] }, e.id))) }), (0, Me.jsx)("div", { className: "h-32" })] }) })] }) })] }) } function id() { return (0, Me.jsxs)("div", { className: "text-white min-h-screen", children: [(0, Me.jsx)(Xu, {}), (0, Me.jsx)("div", { className: "min-h-screen pt-[200px]", style: { backgroundImage: "url(".concat(oc, ")"), backgroundSize: "cover", backgroundPosition: "center", backgroundRepeat: "no-repeat", backgroundAttachment: "fixed" }, children: (0, Me.jsxs)("div", { className: "max-w-[1440px] mx-auto px-4 py-8", children: [(0, Me.jsx)("h1", { className: "text-3xl font-bold mb-8", children: "Privacy Policy" }), (0, Me.jsx)("p", { className: "text-sm text-gray-400 mb-8", children: "Effective Date: May 22, 2025" }), (0, Me.jsxs)("p", { className: "mb-4", children: [(0, Me.jsx)("strong", { children: "Company:" }), " Magmar Infra LLC", (0, Me.jsx)("br", {}), (0, Me.jsx)("strong", { children: "Website:" }), " https://www.magmarinfra.com"] }), (0, Me.jsx)("p", { className: "mb-8", children: 'Magmar Infra LLC ("Magmar," "we," "us," or "our") respects your privacy. This Privacy Policy outlines how we collect, use, and protect your information when you interact with our website, infrastructure tools, APIs, smart wallet SDKs, and related services (collectively, the "Services").' }), (0, Me.jsx)("p", { className: "mb-8", children: "By accessing or using our Services, you agree to the collection and use of information in accordance with this Privacy Policy." }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "1. Information We Collect" }), (0, Me.jsx)("p", { className: "mb-4", children: "We collect minimal information, strictly necessary to operate and improve the Magmar Infra platform. We do not collect private wallet keys, seed phrases, or personal blockchain account data." }), (0, Me.jsx)("p", { className: "mb-4", children: "Information we may collect:" }), (0, Me.jsxs)("ul", { className: "list-disc pl-6 mb-4", children: [(0, Me.jsx)("li", { children: "Technical Information: Browser type, operating system, device type, and IP address." }), (0, Me.jsx)("li", { children: "Usage Data: API requests, error logs, request timestamps, and interactions with our services." }), (0, Me.jsx)("li", { children: "Communication Data: Emails or messages you send to our support or contact forms." }), (0, Me.jsx)("li", { children: "Optional Account Data: If you register a developer account, we may collect your name, email address, and project metadata." })] })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "2. How We Use Information" }), (0, Me.jsx)("p", { className: "mb-4", children: "We use collected information for the following purposes:" }), (0, Me.jsxs)("ul", { className: "list-disc pl-6 mb-4", children: [(0, Me.jsx)("li", { children: "To provide and maintain the Services." }), (0, Me.jsx)("li", { children: "To troubleshoot, monitor, and improve performance." }), (0, Me.jsx)("li", { children: "To respond to inquiries and offer customer support." }), (0, Me.jsx)("li", { children: "To ensure security and prevent abuse or fraud." }), (0, Me.jsx)("li", { children: "To communicate updates, features, or service changes." })] }), (0, Me.jsx)("p", { children: "We do not use your data for advertising, profiling, or resale." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "3. Cookies and Tracking" }), (0, Me.jsx)("p", { className: "mb-4", children: "We may use cookies or similar tracking tools to analyze site traffic and usage. These are strictly for performance, functionality, and analytics." }), (0, Me.jsx)("p", { children: "You can manage cookie preferences through your browser settings. Disabling cookies may affect certain parts of the site." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "4. Third-Party Services" }), (0, Me.jsx)("p", { children: "Magmar Infra may integrate with or link to third-party platforms (e.g., blockchain nodes, authentication services). These services have their own privacy policies, and we are not responsible for their practices." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "5. Data Storage and Security" }), (0, Me.jsx)("p", { className: "mb-4", children: "We use industry-standard security protocols to protect your data. All collected data is stored in secure environments and is accessible only to authorized personnel." }), (0, Me.jsx)("p", { children: "Despite our efforts, no digital platform is completely secure. You use the Services at your own risk." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "6. Data Retention" }), (0, Me.jsx)("p", { className: "mb-4", children: "We retain technical and usage data only as long as necessary to:" }), (0, Me.jsxs)("ul", { className: "list-disc pl-6 mb-4", children: [(0, Me.jsx)("li", { children: "Operate the Services." }), (0, Me.jsx)("li", { children: "Fulfill our legal or contractual obligations." }), (0, Me.jsx)("li", { children: "Improve and debug our infrastructure." })] }), (0, Me.jsx)("p", { children: "You may request data deletion at any time by contacting us." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "7. Your Rights" }), (0, Me.jsx)("p", { className: "mb-4", children: "Depending on your location, you may have rights under privacy laws such as the GDPR or CCPA, including:" }), (0, Me.jsxs)("ul", { className: "list-disc pl-6 mb-4", children: [(0, Me.jsx)("li", { children: "The right to access your personal data." }), (0, Me.jsx)("li", { children: "The right to correct or delete information." }), (0, Me.jsx)("li", { children: "The right to withdraw consent where applicable." }), (0, Me.jsx)("li", { children: "The right to lodge a complaint with a supervisory authority." })] }), (0, Me.jsx)("p", { children: "To exercise these rights, please contact us directly at privacy@magmarinfra.com." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "8. Children's Privacy" }), (0, Me.jsx)("p", { children: "Magmar Infra does not knowingly collect or solicit data from individuals under the age of 13. If you are a parent or guardian and believe your child has provided us information, contact us for immediate deletion." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "9. International Users" }), (0, Me.jsx)("p", { children: "If you are accessing the Services from outside the United States, be aware that your information may be transferred to and stored in servers located in the U.S. and subject to U.S. law." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "10. Policy Changes" }), (0, Me.jsx)("p", { children: "We reserve the right to update this Privacy Policy at any time. Updates will be posted on this page with a revised effective date. We encourage you to review this page regularly." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "11. Contact Us" }), (0, Me.jsx)("p", { className: "mb-2", children: "For any privacy-related inquiries, reach out to:" }), (0, Me.jsx)("p", { className: "mb-2", children: "Magmar Infra LLC" }), (0, Me.jsx)("p", { className: "mb-2", children: "Registered in Delaware, United States" }), (0, Me.jsx)("p", { className: "mb-2", children: "\ud83d\udce7 privacy@magmarinfra.com" }), (0, Me.jsx)("p", { children: "\ud83c\udf10 https://www.magmarinfra.com" })] })] }) })] }) } function od() { return (0, Me.jsxs)("div", { className: "text-white min-h-screen", children: [(0, Me.jsx)(Xu, {}), (0, Me.jsx)("div", { className: "min-h-screen pt-[200px]", style: { backgroundImage: "url(".concat(oc, ")"), backgroundSize: "cover", backgroundPosition: "center", backgroundRepeat: "no-repeat", backgroundAttachment: "fixed" }, children: (0, Me.jsxs)("div", { className: "max-w-[1440px] mx-auto px-4 py-8", children: [(0, Me.jsx)("h1", { className: "text-3xl font-bold mb-8", children: "Terms of Service" }), (0, Me.jsx)("p", { className: "text-sm text-gray-400 mb-8", children: "Effective Date: May 22, 2025" }), (0, Me.jsxs)("p", { className: "mb-4", children: [(0, Me.jsx)("strong", { children: "Company:" }), " Magmar Infra LLC", (0, Me.jsx)("br", {}), (0, Me.jsx)("strong", { children: "Website:" }), " https://www.magmarinfra.com"] }), (0, Me.jsx)("p", { className: "mb-8", children: "These Terms of Service govern your access to and use of Magmar Infra's website, products, and services. By using our infrastructure, software development kits, and smart wallet tooling, you acknowledge that you have read, understood, and agree to be legally bound by these terms." }), (0, Me.jsx)("p", { className: "mb-8", children: "If you do not accept these terms, you may not access or use any part of our offerings." }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "1. Overview" }), (0, Me.jsx)("p", { className: "mb-4", children: "Magmar Infra LLC provides a set of infrastructure services designed to accelerate decentralized application development using account abstraction. This includes a smart wallet system, developer SDKs, APIs, paymaster tools, and related utilities." }), (0, Me.jsx)("p", { children: "We reserve the right to update or change any portion of these terms at our discretion. It is your responsibility to periodically review the terms. Continued use of our services following any updates constitutes acceptance of the revised terms." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "2. Eligibility" }), (0, Me.jsx)("p", { children: "To access or use Magmar Infra's services, you must be at least 18 years of age and possess the legal capacity to enter into binding agreements. If you are accessing the services on behalf of an organization, you affirm that you are authorized to act on its behalf." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "3. Nature of Services" }), (0, Me.jsx)("p", { className: "mb-4", children: "Magmar Infra is a non-custodial infrastructure provider. We offer development tools and smart contract systems compatible with ERC-4337, including:" }), (0, Me.jsxs)("ul", { className: "list-disc pl-6 mb-4", children: [(0, Me.jsx)("li", { children: "Gasless transaction handling" }), (0, Me.jsx)("li", { children: "Account abstraction wallet deployment" }), (0, Me.jsx)("li", { children: "Paymaster and bundler services" }), (0, Me.jsx)("li", { children: "Social login integration" }), (0, Me.jsx)("li", { children: "Developer APIs and SDKs" })] }), (0, Me.jsx)("p", { children: "We do not control, store, or recover user wallet keys or funds. Your smart contract accounts remain fully under your control." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "4. Acceptable Use" }), (0, Me.jsx)("p", { className: "mb-4", children: "You agree not to misuse Magmar Infra's services. Misuse includes but is not limited to:" }), (0, Me.jsxs)("ul", { className: "list-disc pl-6 mb-4", children: [(0, Me.jsx)("li", { children: "Deploying malicious or illegal smart contracts" }), (0, Me.jsx)("li", { children: "Attempting to exploit or interfere with the platform's security" }), (0, Me.jsx)("li", { children: "Using the infrastructure for unlawful, deceptive, or harmful purposes" }), (0, Me.jsx)("li", { children: "Circumventing rate limits, API restrictions, or authentication mechanisms" })] }), (0, Me.jsx)("p", { children: "Violations may result in immediate suspension or permanent termination of access." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "5. Fees and Payments" }), (0, Me.jsx)("p", { className: "mb-4", children: "Some services may be subject to fees, including paymaster support, API access, or custom deployments. We will notify users of pricing structures where applicable. All fees are non-refundable unless otherwise specified." }), (0, Me.jsx)("p", { children: "You are responsible for any gas fees or on-chain transaction costs associated with using Magmar's tools or deploying smart contracts." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "6. No Custody or Guarantees" }), (0, Me.jsx)("p", { className: "mb-4", children: "Magmar Infra does not provide custody over any digital assets. We do not store, recover, or manage your keys. If you lose access to your wallet, we cannot assist in recovery." }), (0, Me.jsx)("p", { children: "Additionally, Magmar Infra does not guarantee uptime, specific functionality, or compatibility with third-party services or chains. Use the services at your own risk." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "7. Intellectual Property" }), (0, Me.jsx)("p", { className: "mb-4", children: "All content, technology, software, branding, and documentation associated with Magmar Infra is the exclusive property of Magmar Infra LLC. You may not copy, reverse engineer, or distribute our intellectual property without prior written consent." }), (0, Me.jsx)("p", { children: "Using our SDKs or APIs does not grant you ownership or license to any part of our proprietary technology beyond what is explicitly stated." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "8. Third Party Tools" }), (0, Me.jsx)("p", { children: "Some services may integrate with third-party tools, blockchain networks, or APIs. We do not control these providers and are not liable for changes in their performance, security, or availability." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "9. Termination" }), (0, Me.jsx)("p", { className: "mb-4", children: "Magmar Infra reserves the right to restrict or terminate access to any user who violates these terms, poses a security risk, or abuses the services. Termination may occur without prior notice." }), (0, Me.jsx)("p", { children: "You may stop using the services at any time. Upon termination, your rights under these terms will cease immediately." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "10. Limitation of Liability" }), (0, Me.jsx)("p", { className: "mb-4", children: "To the maximum extent permitted by law, Magmar Infra shall not be held liable for:" }), (0, Me.jsxs)("ul", { className: "list-disc pl-6 mb-4", children: [(0, Me.jsx)("li", { children: "Loss of assets, data, or contracts" }), (0, Me.jsx)("li", { children: "Security breaches or smart contract vulnerabilities" }), (0, Me.jsx)("li", { children: "Service interruptions, errors, or bugs" }), (0, Me.jsx)("li", { children: "Indirect, incidental, or consequential damages" })] }), (0, Me.jsx)("p", { children: "The total liability of Magmar Infra shall not exceed the total amount paid by you to us in the previous twelve months." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "11. Indemnity" }), (0, Me.jsx)("p", { children: "You agree to indemnify, defend, and hold harmless Magmar Infra LLC, its officers, employees, and affiliates from any claims, liabilities, losses, or expenses arising out of your use of the services, violation of these terms, or infringement of any rights of a third party." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "12. Governing Law" }), (0, Me.jsx)("p", { children: "These Terms shall be governed by and construed under the laws of the State of Delaware, without regard to conflict of laws principles. All disputes shall be subject to the exclusive jurisdiction of the state or federal courts located in Delaware." })] }), (0, Me.jsxs)("section", { className: "mb-8", children: [(0, Me.jsx)("h2", { className: "text-2xl font-semibold mb-4", children: "13. Contact Information" }), (0, Me.jsx)("p", { className: "mb-2", children: "For questions or legal inquiries, please contact us at:" }), (0, Me.jsx)("p", { className: "mb-2", children: "Magmar Infra LLC" }), (0, Me.jsx)("p", { className: "mb-2", children: "Registered in Delaware, United States" }), (0, Me.jsx)("p", { className: "mb-2", children: "\ud83d\udce7 legal@magmarinfra.com" }), (0, Me.jsx)("p", { children: "\ud83c\udf10 https://www.magmarinfra.com" })] })] }) })] }) } const ad = [{ id: "magmar-brand-assets", title: "Magmar Brand Assets", description: "Complete collection of Magmar brand assets including logos, icons, and brand guidelines for official use.", items: [{ id: "logo", title: "Logo (Transparent)", description: "High quality logo with transparent background for scalable use.", downloadUrl: "/media-kit/logo.png", icon: "\ud83c\udfa8" }, { id: "logo-with-bg", title: "Logo with Background", description: "Logo with white background for use on dark surfaces.", downloadUrl: "/media-kit/Logo W bg.png", icon: "\ud83c\udfa8" }, { id: "logo-without-bg", title: "Logo without Background", description: "Clean logo without background for flexible branding.", downloadUrl: "/media-kit/Logo W_o Background.png", icon: "\ud83c\udfa8" }, { id: "twitter-banner", title: "Twitter Banner", description: "Official Twitter/X banner with Magmar branding.", downloadUrl: "/media-kit/Twitter Banner.png", icon: "\ufffd" }] }, { id: "magmar-product-assets", title: "Product Screenshots", description: "High-quality screenshots and images of Magmar products for marketing and documentation purposes.", items: [{ id: "dashboard", title: "Dashboard Screenshot", description: "Image of the Magmar dashboard interface.", downloadUrl: "/media-kit/dashboard.webp", icon: "\ud83d\uddbc\ufe0f" }, { id: "liquidity", title: "Liquidity Interface", description: "Screenshot of the liquidity management interface.", downloadUrl: "/media-kit/Liquidity.png", icon: "\ud83d\udca7" }, { id: "live", title: "Live Trading Interface", description: "Image of the live trading platform interface.", downloadUrl: "/media-kit/Live.png", icon: "\ud83d\udcc8" }] }, { id: "magmar-roadmap-docs", title: "Documentation & Roadmap", description: "Official documentation, roadmaps, and presentation materials for partners and media.", items: [{ id: "roadmap", title: "Product Roadmap", description: "Visual roadmap showing Magmar's development timeline.", downloadUrl: "/media-kit/Roadmap (1).png", icon: "\ud83d\uddfa\ufe0f" }, { id: "pitch-deck", title: "Magmar Pitch Deck", description: "Official pitch deck presentation (PDF format).", downloadUrl: "/media-kit/Magmar Pitch.pdf", icon: "\ud83d\udcc4" }] }, { id: "magmar-video-assets", title: "Video Assets", description: "Promotional and educational video content showcasing Magmar's features and onboarding flow.", items: [{ id: "welcome-video", title: "Welcome Video", description: "Introductory welcome video for new users.", downloadUrl: "/media-kit/Welcome.mp4", icon: "\ud83c\udfac" }, { id: "new-buy-demo", title: "New Buy Demo", description: "Video demonstration of the new buying process.", downloadUrl: "/media-kit/New Buy.mp4", icon: "\ud83c\udfa5" }] }]; function sd() { const [e, t] = (0, i.useState)(""); (0, i.useEffect)((() => { const e = () => { const e = ad.map((e => e.id)), n = window.scrollY + 100; for (let r = e.length - 1; r >= 0; r--) { const i = document.getElementById(e[r]); if (i && i.offsetTop <= n) { t(e[r]); break } } }; return window.addEventListener("scroll", e), e(), () => window.removeEventListener("scroll", e) }), []); return (0, Me.jsxs)("div", { className: "min-h-screen text-white", children: [(0, Me.jsx)(Xu, {}), (0, Me.jsx)("div", { className: "min-h-screen pt-[200px]", style: { backgroundImage: "url(".concat(oc, ")"), backgroundSize: "cover", backgroundPosition: "center", backgroundRepeat: "no-repeat", backgroundAttachment: "fixed" }, children: (0, Me.jsxs)("div", { className: "max-w-[1280px] mx-auto flex relative", children: [(0, Me.jsx)("aside", { className: "hidden lg:block w-64 pr-8 sticky top-24 h-fit", children: (0, Me.jsxs)("nav", { className: "space-y-2", children: [(0, Me.jsx)("h3", { className: "text-sm font-medium text-white/50 uppercase tracking-wider mb-4", children: "Quick Navigation" }), ad.map((t => (0, Me.jsx)("button", { onClick: () => (e => { const t = document.getElementById(e); t && t.scrollIntoView({ behavior: "smooth", block: "start" }) })(t.id), className: "block w-full text-left px-3 py-2 rounded-lg text-sm transition-colors ".concat(e === t.id ? "bg-orange-500/20 text-orange-500 border border-orange-500/30" : "text-white/70 hover:text-white hover:bg-white/5"), children: t.title }, t.id)))] }) }), (0, Me.jsxs)("main", { className: "flex-1 px-5 pb-24 lg:px-0", children: [(0, Me.jsxs)("div", { className: "mb-16", children: [(0, Me.jsx)("h1", { className: "text-5xl lg:text-[82px] leading-[90%] font-medium mb-6", children: "Media Kit" }), (0, Me.jsx)("p", { className: "max-w-2xl text-lg leading-relaxed text-white/70", children: "Download official Magmar brand assets, logos, and marketing materials. All assets are provided for media, partner, and developer use in accordance with our brand guidelines." })] }), (0, Me.jsx)("div", { className: "space-y-20", children: ad.map((e => (0, Me.jsxs)("section", { id: e.id, className: "scroll-mt-24", children: [(0, Me.jsxs)("div", { className: "mb-12", children: [(0, Me.jsx)("h2", { className: "mb-4 text-3xl font-medium text-white lg:text-4xl", children: e.title }), (0, Me.jsx)("p", { className: "leading-relaxed text-white/70", children: e.description })] }), "magmar-brand-assets" === e.id && (0, Me.jsx)("div", { className: "p-4 mb-12 border sm:p-6 bg-white/5 rounded-xl border-white/10 backdrop-blur-sm", children: (0, Me.jsx)("div", { className: "flex items-center justify-center w-full h-48 bg-gradient-to-r from-orange-500/20 to-orange-600/20 rounded-xl", children: (0, Me.jsxs)("div", { className: "text-center", children: [(0, Me.jsx)("img", { src: "/logo.png", alt: "Magmar Logo", className: "mx-auto size-14 lg:size-20" }), (0, Me.jsx)("h3", { className: "mb-2 text-xl font-medium text-white", children: "Magmar Brand Assets" }), (0, Me.jsx)("p", { className: "text-sm text-white/70", children: "High-quality brand assets and logos" })] }) }) }), "magmar-product-assets" === e.id && (0, Me.jsx)("div", { className: "p-4 mb-12 border sm:p-6 bg-white/5 rounded-xl border-white/10 backdrop-blur-sm", children: (0, Me.jsx)("div", { className: "flex items-center justify-center w-full h-48 bg-gradient-to-r from-blue-500/20 to-purple-600/20 rounded-xl", children: (0, Me.jsxs)("div", { className: "text-center", children: [(0, Me.jsx)("div", { className: "text-4xl mb-2", children: "\ud83d\udcf1" }), (0, Me.jsx)("h3", { className: "mb-2 text-xl font-medium text-white", children: "Product Screenshots" }), (0, Me.jsx)("p", { className: "text-sm text-white/70", children: "Interface screenshots and product images" })] }) }) }), "magmar-roadmap-docs" === e.id && (0, Me.jsx)("div", { className: "p-4 mb-12 border sm:p-6 bg-white/5 rounded-xl border-white/10 backdrop-blur-sm", children: (0, Me.jsx)("div", { className: "flex items-center justify-center w-full h-48 bg-gradient-to-r from-green-500/20 to-teal-600/20 rounded-xl", children: (0, Me.jsxs)("div", { className: "text-center", children: [(0, Me.jsx)("div", { className: "text-4xl mb-2", children: "\ud83d\udccb" }), (0, Me.jsx)("h3", { className: "mb-2 text-xl font-medium text-white", children: "Documentation & Roadmap" }), (0, Me.jsx)("p", { className: "text-sm text-white/70", children: "Official docs and development timeline" })] }) }) }), "magmar-video-assets" === e.id && (0, Me.jsx)("div", { className: "p-4 mb-12 border sm:p-6 bg-white/5 rounded-xl border-white/10 backdrop-blur-sm", children: (0, Me.jsx)("div", { className: "flex items-center justify-center w-full h-48 bg-gradient-to-r from-red-500/20 to-pink-600/20 rounded-xl", children: (0, Me.jsxs)("div", { className: "text-center", children: [(0, Me.jsx)("div", { className: "text-4xl mb-2", children: "\ud83c\udfac" }), (0, Me.jsx)("h3", { className: "mb-2 text-xl font-medium text-white", children: "Video Assets" }), (0, Me.jsx)("p", { className: "text-sm text-white/70", children: "Promotional and educational videos" })] }) }) }), (0, Me.jsx)("div", { className: "grid grid-cols-1 gap-6 md:grid-cols-2", children: e.items.map((e => (0, Me.jsx)("div", { className: "overflow-hidden transition-all duration-300 border rounded-lg group border-white/10 bg-white/5 backdrop-blur-sm hover:border-orange-500/30", children: (0, Me.jsx)("div", { className: "p-6", children: (0, Me.jsxs)("div", { className: "flex items-start gap-4", children: [(0, Me.jsx)("div", { className: "text-2xl", children: e.icon }), (0, Me.jsxs)("div", { className: "flex-1", children: [(0, Me.jsx)("h3", { className: "mb-2 text-xl font-medium text-white transition-colors group-hover:text-orange-500", children: e.title }), (0, Me.jsx)("p", { className: "mb-4 text-sm leading-relaxed text-white/70", children: e.description }), (0, Me.jsxs)("button", { onClick: () => ((e, t) => { const n = document.createElement("a"); n.href = e, n.download = t, document.body.appendChild(n), n.click(), document.body.removeChild(n) })(e.downloadUrl, e.title), className: "inline-flex items-center gap-2 text-sm font-medium text-orange-500 transition-colors hover:text-orange-400", children: [(0, Me.jsx)("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: (0, Me.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" }) }), "Download"] })] })] }) }) }, e.id))) })] }, e.id))) })] })] }) })] }) } const ld = [{ id: "1", title: "The Death of Seed Phrases? Exploring Social Recovery in Magmar", excerpt: "The seed phrase, long considered the cornerstone of crypto self-custody, is increasingly becoming a liability in modern blockchain architectures. ", content: "# The Death of Seed Phrases? Exploring Social Recovery in Magmar\n\nThe seed phrase, long considered the cornerstone of crypto self-custody, is increasingly becoming a liability in modern blockchain architectures. With the rise of smart contract accounts and programmable wallets, projects like Magmar are reimagining account recovery by implementing a technically robust framework for social recovery. This article explores the architecture, mechanics, and implications of Magmar's social recovery system\u2014and how it signals the end of traditional seed phrase reliance.\n\n## The Problem with Seed Phrases\n\nSeed phrases serve as the root of a hierarchical deterministic (HD) wallet. While cryptographically secure, they introduce a range of issues that make them unsuitable for mainstream or enterprise-grade blockchain applications:\n\n* Non-recoverability: Loss of a seed phrase results in permanent loss of funds.\n* Susceptibility to theft: If compromised, ownership cannot be revoked or reassigned.\n* Poor usability: Memorizing or safely storing a 12- or 24-word phrase is error-prone.\n* Single point of failure: Recovery options are limited to backup copies or password managers, both of which reintroduce central points of compromise.\n\nSeed phrases are designed for technical users, not scalable for the next billion participants in Web3.\n\n## Smart Contract Accounts: Redefining Ownership\n\nMagmar utilizes smart contract accounts compliant with ERC-4337, separating wallet logic from key management. These accounts are programmable and modular, supporting complex logic such as recovery, authentication, and signature policy enforcement.\n\nInstead of relying on a single cryptographic key, ownership of the account is determined by smart contract conditions, which may include multi-signature rules, external verifiers, or off-chain signals. This opens the door to recovery mechanisms that do not depend on static secrets like seed phrases.\n\n---\n\n## Social Recovery in Magmar: Architectural Overview\n\nMagmar implements social recovery as a native extension of its smart contract account framework. The system is designed around the delegation of recovery authority to a set of trusted entities referred to as guardians. Guardians are pre-authorized at wallet initialization and can collectively reassign wallet ownership in the event of loss or compromise.\n\n### Key Components\n\n1. **Smart Contract Account**  \n   The user's wallet, deployed as a modular, upgradeable contract, encodes custom recovery logic.\n\n2. **Guardian Set**  \n   A list of on-chain or off-chain actors assigned authority to authorize recovery. Each guardian is typically an EOA or another contract. The system supports guardian rotation and threshold updates.\n\n3. **Recovery Module**  \n   A dedicated contract that manages initiation, approval, time-locking, and execution of recovery flows. Magmar includes both native and pluggable modules for developer-defined logic.\n\n4. **Recovery Threshold**  \n   The number of guardian approvals required to finalize a recovery process. This value is configurable and can be weighted based on trust levels.\n\n5. **Time Delay Mechanism**  \n   Introduces a delay between the recovery proposal and its execution to allow for cancellation or dispute resolution.\n\n6. **Authorization Quorum**  \n   Ensures that recovery cannot be executed unilaterally by a single guardian or malicious actor.\n\n---\n\n## Recovery Process Lifecycle\n\nThe lifecycle of a typical social recovery process in Magmar consists of the following phases:\n\n1. **Trigger**  \n   A recovery is initiated either by the wallet owner (via alternate credentials) or by an external observer.\n\n2. **Guardian Approval**  \n   Guardians receive the request off-chain or on-chain and submit cryptographic signatures or transactions indicating their consent.\n\n3. **Quorum Verification**  \n   Once the threshold is reached, the Recovery Module verifies approvals using the defined consensus model.\n\n4. **Time-Lock Delay**  \n   A waiting period is enforced to allow the original owner to contest the recovery if it is unauthorized.\n\n5. **Finalization**  \n   Ownership is transferred to the new designated key or contract upon expiration of the delay window.\n\n### Security Considerations\n\nMagmar's design emphasizes defense-in-depth. Key security features include:\n\n* **Replay Protection**  \n  Prevents re-submission of old recovery transactions through nonce and session binding.\n\n* **Guardian Rotation**  \n  Periodic updates to guardian sets reduce the risk of long-term compromise.\n\n* **Event Monitoring**  \n  Wallet owners or monitoring services can subscribe to recovery events and halt suspicious processes in real time.\n\n* **Multi-Factor Recovery Logic**  \n  Combines multiple identity or behavioral signals in addition to guardian approval, such as biometric checks, CAPTCHA challenges, or rate-limited approvals.\n\n* **ZK-Based Guardian Signatures**  \n  Experimental integration with zero-knowledge proof systems allows guardian approval to remain pseudonymous while provable on-chain.\n\n---\n\n## Comparative Models\n\nTo contextualize the benefits of social recovery, it is useful to compare it with existing models:\n\n| Feature | Seed Phrase | Traditional Custody | Magmar Social Recovery |\n|---------|-------------|---------------------|------------------------|\n| Non-custodial | Yes | No | Yes |\n| Recoverability | No | Yes | Yes |\n| Programmable Security | No | Limited | Yes |\n| Guardian Redundancy | No | No | Yes |\n| User-Friendly | No | Yes | Yes |\n| Time-Delayed Execution | No | No | Yes |\n| Tamper Resistance | Low | Medium | High |\n\nMagmar delivers a recovery system that retains decentralization while improving resilience, usability, and security.\n\n## Implications for Developers and dApps\n\nSocial recovery in Magmar is not only a user-facing benefit but also a powerful primitive for application developers. dApps can:\n\n* Embed recovery preferences during onboarding\n* Provide user interfaces for guardian management\n* Integrate recovery initiation triggers into login flows\n* Subscribe to wallet events for automated risk analysis\n* Extend recovery logic with custom modules (e.g., DAO-based approval or biometric integrations)\n\n## Conclusion\n\nMagmar's social recovery model represents a critical step toward eliminating one of the biggest UX and security challenges in crypto: the fragility of seed phrases. By embedding programmable, guardian-based recovery directly into the account architecture, Magmar introduces a new trust model for decentralized identity and wallet management.\n\nThis model offers the flexibility of traditional authentication systems without compromising decentralization, custody, or privacy\u2014making it a viable alternative for individuals, institutions, and protocol-level wallet design going forward.", author: "Magmar Team", date: "Mar 20, 2025", readTime: "8 min", category: "Technical", image: "/blog/The Death of Seed Phrases.png", slug: "the-death-of-seed-phrases-exploring-social-recovery-in-magmar", featured: !0 }, { id: "2", title: "Top 10 Use Cases That Magmar Unlocks for Developers", excerpt: "The Ethereum ecosystem is evolving rapidly, and developers are increasingly limited by legacy wallet constraints, especially when building sophisticated, user-friendly dApps.", content: "# Top 10 Use Cases That Magmar Unlocks for Developers\n\nThe Ethereum ecosystem is evolving rapidly, and developers are increasingly limited by legacy wallet constraints, especially when building sophisticated, user-friendly dApps. Magmar, is an advanced smart account platform built on ERC-4337, offering a comprehensive SDK and execution framework that unlocks powerful capabilities for developers.\n\nThis article explores ten technical use cases that Magmar enables, transforming what developers can build in Web3, and how they can build it.\n\n## 1. Abstracted User Onboarding with Social Login and Zero ETH\n\n**Problem Developers Face:**\nTraditional Ethereum onboarding requires users to manage seed phrases and acquire ETH before they can transact. This introduces high friction and onboarding drop-off.\n\n**Magmar's Solution:**\nMagmar enables developers to onboard users via social logins (Google, Apple, etc.) while generating smart accounts on the fly. Combined with Paymaster infrastructure, dApps can fully sponsor transaction fees during onboarding, removing the need for users to hold ETH.\n\n**Developer Impact:**\n* Integrate seamless, Web2-style onboarding in minutes\n* Avoid managing key custody or recovery logic\n* Abstract all gas logic from frontend workflows\n\n---\n\n## 2. Embedded Smart Wallets with Custom Transaction Logic\n\n**Problem Developers Face:**\nWallet behavior is usually static and externally managed. Developers must rely on user-controlled EOAs, limiting dApp composability.\n\n**Magmar's Solution:**\nMagmar SDK allows developers to embed fully programmable smart wallets directly into dApps. These accounts are smart contracts with customizable modules\u2014like token allowlists, throttling, or compliance guards\u2014implemented at the account layer.\n\n**Developer Impact:**\n* Programmatically control wallet logic from dApp backends\n* Define fine-grained access control and policy modules\n* Upgrade wallet functionality post-deployment via proxy patterns\n\n---\n\n## 3. Workflow Compression via Transaction Batching\n\n**Problem Developers Face:**\nDeFi transactions typically span multiple steps\u2014approve, swap, stake, claim. Each step requires a separate transaction, increasing gas costs and UX friction.\n\n**Magmar's Solution:**\nUsing MagmarOperation, developers can define a sequence of contract calls that execute atomically in a single batch transaction. This drastically simplifies multi-step workflows on-chain.\n\n**Developer Impact:**\n* Design multi-contract, multi-step flows with atomic guarantees\n* Reduce required signatures and error points\n* Compress UX and minimize failure propagation\n\n---\n\n## 4. Dynamic Fee Sponsorship Using Paymasters\n\n**Problem Developers Face:**\nBuilding dApps that work without native token balances often involves complex relayer systems or custodial workarounds.\n\n**Magmar's Solution:**\nMagmar exposes a Paymaster abstraction that lets developers sponsor gas on a per-operation, conditional, or percentage-based basis. This is fully compliant with ERC-4337's UserOperation flow.\n\n**Developer Impact:**\n* Programmatically define gas policies (e.g. only for new users)\n* Support non-ETH fee payment (e.g. USDC, protocol tokens)\n* Enable free trials or freemium usage models natively\n\n---\n\n## 5. Session Keys and dApp-Scoped Authorization\n\n**Problem Developers Face:**\nSession management on-chain is either non-existent or requires compromising private key security for persistent access.\n\n**Magmar's Solution:**\nDevelopers can generate session keys\u2014short-lived keys scoped to a specific dApp, contract, or action set. These are approved by the smart account once and reused with bounded permissions.\n\n**Developer Impact:**\n* Allow temporary or rate-limited access without re-authorization\n* Scope operations by dApp or feature\n* Reduce signing fatigue and improve UX for power users\n\n---\n\n## 6. Automated Smart Account Recovery and Delegation\n\n**Problem Developers Face:**\nSelf-custodial applications face a sharp trade-off between usability and irreversible account loss. Recovery is either manual or insecure.\n\n**Magmar's Solution:**\nMagmar accounts support social recovery and programmable recovery workflows. Developers can define a recovery policy involving guardians, time delays, or behavioral rules (e.g. inactivity-based recovery).\n\n**Developer Impact:**\n* Integrate human-centric recovery without off-chain custodians\n* Reduce loss risk in user onboarding flows\n* Enable recovery delegation workflows for institutions or teams\n\n---\n\n## 7. Multi-Signature and Role-Based Access Control at the Account Layer\n\n**Problem Developers Face:**\nSmart contract multi-sig wallets (e.g. Gnosis Safe) are external systems, not deeply integrated into dApp workflows. Managing access control across users and teams is inflexible and high-overhead.\n\n**Magmar's Solution:**\nMagmar Smart Accounts natively support multi-signature logic and modular RBAC policies, allowing developers to assign granular permissions (e.g., spender, approver, admin) per user or key.\n\n**Developer Impact:**\n* Build team or DAO wallets directly into the dApp\n* Assign fine-grained permissions for sensitive operations\n* Support transaction co-signing, approval workflows, and auditability\n\n---\n\n## 8. Composable dApp Logic via Modular Account Extensions\n\n**Problem Developers Face:**\nWallets and accounts are typically non-composable. Integrating new behavior (e.g. compliance rules or monitoring) requires external logic and monitoring.\n\n**Magmar's Solution:**\nMagmar Smart Accounts are module-based, where developers can register custom modules that define additional logic executed at the account level. Modules can be swapped, upgraded, or revoked at runtime.\n\n**Developer Impact:**\n* Add compliance, analytics, or conditional logic as installable modules\n* Support evolving requirements without re-deploying the wallet\n* Share or sell modules across ecosystem participants\n\n---\n\n## 9. AI-Augmented Transactions and Autonomous Agent Logic\n\n**Problem Developers Face:**\nIntegrating intelligent automation or AI agents with wallets requires building custom infrastructure for transaction generation, risk management, and error handling.\n\n**Magmar's Solution:**\nMagmar supports AI-driven smart accounts, allowing developers to build agents that analyze portfolio state, forecast risks, or optimize yield strategies\u2014and then execute decisions using MagmarOperation.\n\n**Developer Impact:**\n* Build agent-like behavior directly into wallets\n* Automate common DeFi workflows (e.g., rebalance, claim, reinvest)\n* Integrate ML pipelines to guide or auto-initiate on-chain activity\n\n---\n\n## 10. Unified Multi-Chain Smart Wallet Infrastructure\n\n**Problem Developers Face:**\nSupporting multiple chains requires deploying separate wallets, managing RPCs, and coordinating state across networks.\n\n**Magmar's Solution:**\nMagmar offers chain-agnostic smart accounts with a unified interface and chain-aware execution logic. Developers can use the same SDK and account contract across supported EVM networks with automatic network detection and routing.\n\n**Developer Impact:**\n* Build one wallet interface that works across multiple chains\n* Implement cross-chain workflows without duplicating logic\n* Provide users with a seamless multi-chain UX without RPC management\n\n---\n\n## Final Thoughts\n\nMagmar is not just a wallet SDK; it's an execution environment and account framework that redefines how developers build with Web3 primitives. With modularity, abstraction, and on-chain programmability at its core, Magmar unlocks use cases that were previously impractical or impossible.\n\nBy adopting Magmar's architecture, developers gain direct access to the next evolution of decentralized app design, where wallets are programmable agents, gas is abstracted, and UX is indistinguishable from Web2.\n\nFor developers serious about building for the next billion users, Magmar is not a feature\u2014it's foundational infrastructure.", author: "Magmar Team", date: "Apr 15, 2025", readTime: "6 min", category: "Technical", image: "/blog/Top 10 Use Cases.png", slug: "top-10-use-cases-that-magmar-unlocks-for-developers" }, { id: "3", title: "How AI-Powered Smart Accounts Will Change the Way You Interact with Blockchain", excerpt: "The rise of account abstraction and AI agents in Web3 is converging into a new category of infrastructure: AI-powered smart accounts. As dApps become more complex and decentralized ecosystems demand real-time decision-making, developers need programmable wallets that can act autonomously, reason over data, and respond intelligently to on-chain events.", content: "# How AI-Powered Smart Accounts Will Change the Way You Interact with Blockchain\n\nThe rise of account abstraction and AI agents in Web3 is converging into a new category of infrastructure: AI-powered smart accounts. As dApps become more complex and decentralized ecosystems demand real-time decision-making, developers need programmable wallets that can act autonomously, reason over data, and respond intelligently to on-chain events.\n\nThis is where Magmar's smart account platform comes in. Built on ERC-4337, Magmar not only abstracts away traditional wallet constraints \u2014 it introduces an execution layer for autonomous, AI-augmented account logic.\n\nIn this post, we'll explore what AI-powered smart accounts are, how they're implemented in Magmar, and why they represent a paradigm shift in how users and developers interact with the blockchain.\n\n---\n\n## What Are AI-Powered Smart Accounts?\n\nAn AI-powered smart account is a programmable smart contract wallet that integrates intelligent behavior into its operational flow. Unlike EOAs or even standard contract wallets, AI smart accounts combine:\n\n* Autonomous decision-making (based on predefined policies or ML models)\n* Data-driven execution logic (reactive or predictive)\n* Modular control surfaces (transaction filtering, scheduling, anomaly detection)\n\nIn Magmar, this is achieved through the Magmar Smart Account SDK, which exposes hooks to plug in AI logic \u2014 either off-chain (via controller agents) or directly into the account modules.\n\n## Why Now? The Case for Intelligence at the Wallet Layer\n\nDeFi, NFTs, on-chain gaming, and DAO tooling increasingly involve high-frequency, stateful interaction with on-chain assets. Users often need to:\n\n* Monitor portfolio states\n* Evaluate and execute trades\n* Claim rewards or rebalance assets\n* Detect malicious approvals or security threats\n\nToday, this must be done manually \u2014 or requires the user to trust external bots, which often have privileged access to keys or are poorly integrated with wallet logic.\n\nMagmar flips this model: instead of building bots that control wallets, you build wallets that are bots.\n\n## Key Capabilities of AI Smart Accounts in Magmar\n\n### 1. Autonomous Transaction Generation\n\nDevelopers can integrate agents that monitor wallet state and produce valid UserOperations. These operations are not arbitrary calls \u2014 they conform to ERC-4337 and Magmar's extended MagmarOperation format, enabling multi-call workflows with validation and execution guards.\n\nExample:\n* If stablecoin balance > X, then swap to ETH and stake on protocol Y\n* Triggered autonomously and executed via the smart account\n\n### 2. Real-Time Transaction Filtering\n\nMagmar allows account-level modules to intercept transactions before execution. Developers can embed ML models or heuristics that reject suspicious, non-compliant, or mispriced transactions.\n\nUse cases:\n* Phishing protection: Prevent transactions to blacklisted addresses\n* Price validation: Block swaps with slippage > threshold\n* Behavioral modeling: Flag unusual user behavior based on past activity\n\n### 3. Intelligent Scheduling and Rate Limiting\n\nAI agents can prioritize and delay execution based on predicted network conditions, e.g., wait for gas to drop, or time transactions based on market events.\n\nThis includes:\n* Temporal batching: Execute batched operations at optimal times\n* Predictive limits: Throttle transaction rate based on anomalous access patterns\n* DeFi automation: Reinvest, claim, or swap based on optimal price action or APY thresholds\n\n### 4. Portfolio Optimization and Strategy Execution\n\nDevelopers can build smart accounts that embed portfolio-level rules. For example, if a user has idle assets or is overexposed to a token, an AI agent can generate and submit rebalancing operations.\n\nMagmar's architecture supports:\n* Plug-and-play strategy modules\n* On-chain simulation and dry-run of UserOperations\n* Safe delegation of strategies without compromising custody\n\n## Architecture: How Magmar Enables AI at the Account Level\n\n### Smart Account Core (Modular Logic)\n\nEach Magmar Smart Account is an upgradable smart contract that uses a modular architecture:\n* Execution modules\n* Validation modules\n* Role-based permission modules\n\nAI modules can be registered to:\n* Intercept operations (pre-execution filtering)\n* Generate transactions (off-chain agent \u2192 UserOperation)\n* Interact with external APIs for decision-making\n\n### MagmarOperation (Extended ERC-4337)\n\nMagmar enhances the standard UserOperation type with:\n* Multi-call support\n* Conditional execution logic\n* Security hooks (MFA, guardian approval, compliance checks)\n\nAI agents build and sign MagmarOperations, which are submitted via Magmar's bundler infrastructure.\n\n### Off-Chain AI Agent\n\nThis is a local or hosted controller that:\n* Monitors wallet and market state (via RPC or indexer)\n* Feeds data into AI/ML models (e.g. sentiment, price prediction)\n* Constructs and simulates UserOperations\n* Signs and submits to the Magmar Mempool\n\nNo private key exposure is needed, and all interactions flow through programmable, upgradeable accounts.\n\n## Developer Workflows with AI Smart Accounts\n\n1. **Deploy Magmar Smart Account**\n   * Via SDK or Magmar Factory API\n\n2. **Attach Modules**\n   * AI module (for simulation, scheduling, etc.)\n   * Compliance module (if needed)\n   * Paymaster module (for sponsored execution)\n\n3. **Run Agent Service**\n   * Monitor wallet state, user behavior, market data\n   * Generate MagmarOperations based on AI strategy\n   * Submit via bundler\n\n4. **User Interface (optional)**\n   * Display strategy decisions\n   * Provide override and manual control options\n\n## Real-World Use Cases\n\n### Auto-Trading Wallets\nDeploy smart accounts that monitor prices and execute trades based on AI price models or indicators.\n\n### AI-Rebalancing for DAOs\nTreasury wallets can dynamically rebalance exposure or allocate funds based on agent-driven insights.\n\n### Passive Income Optimization\nSmart accounts auto-claim rewards, stake in yield protocols, and reallocate assets for best APY.\n\n### AI-Driven On-Chain Identity\nUse behavioral models to flag wallet anomalies, enforce session-based permissions, or adjust access levels dynamically.\n\n## Challenges and Considerations\n\n* On-chain AI is still limited by cost and performance. Most AI logic should remain off-chain and interact via the SDK.\n* Security and transparency are critical. Developers must ensure that agents don't overstep permissions or introduce automation risk.\n* Simulation is vital. Magmar supports full off-chain simulation of UserOperations before execution, reducing failure risk.\n\n## Conclusion\n\nAI-powered smart accounts aren't just a novel concept \u2014 they're the logical next step in wallet evolution. By embedding autonomous behavior, Magmar allows developers to build wallets that act more like agents: programmable, secure, and intelligent.\n\nAs the complexity of on-chain systems grows, the need for automation at the account level will become mandatory. Magmar provides the infrastructure to build this today.\n\nIf you're building autonomous finance, intelligent agents, or advanced DeFi UX \u2014 Magmar's AI smart accounts are your execution layer.", author: "Magmar Team", date: "Nov 28, 2024", readTime: "8 min", category: "Innovation", image: "/blog/How AI-Powered Smart Accounts.png", slug: "how-ai-powered-smart-accounts-will-change-blockchain-interaction" }, { id: "4", title: "Why Gasless Transactions Are the Key to Mainstream Web3 Adoption", excerpt: "Gas fees remain one of the biggest barriers to Web3 adoption. Every transaction requiring users to calculate costs, manage ETH balances, and understand network congestion creates friction that drives away mainstream users.", content: "# Why Gasless Transactions Are the Key to Mainstream Web3 Adoption\n\nGas fees remain one of the biggest barriers to Web3 adoption. Every transaction requiring users to calculate costs, manage ETH balances, and understand network congestion creates friction that drives away mainstream users.\n\nImagine explaining to your grandmother that she needs to buy ETH, estimate gas prices, and potentially pay $50 to send a $10 transaction. The complexity and unpredictability of gas fees make Web3 feel broken compared to the seamless experience of traditional apps.\n\nThis is where gasless transactions come in\u2014a paradigm shift that abstracts away the complexity of blockchain fees and creates the smooth, predictable user experience that mainstream adoption requires.\n\n---\n\n## The Gas Fee Problem\n\n### User Experience Nightmare\n\nGas fees create several major UX problems:\n\n**Unpredictable Costs**: Users never know exactly what a transaction will cost until they're ready to confirm it.\n\n**Failed Transactions**: Setting gas too low results in failed transactions that still consume fees.\n\n**Required Technical Knowledge**: Users must understand concepts like gas limits, gas prices, and network congestion.\n\n**Two-Token Economics**: Users need both the token they want to use AND the native token for gas.\n\n### Adoption Barriers\n\nThese gas-related friction points create real barriers to adoption:\n\n- **Onboarding Complexity**: New users must acquire multiple tokens before they can do anything useful\n- **Transaction Anxiety**: Fear of paying too much or having transactions fail\n- **Small Transaction Prevention**: Micro-transactions become economically impossible when gas exceeds the transaction value\n- **User Dropoff**: Studies show that gas fee complexity causes up to 70% of new users to abandon Web3 apps during their first session\n\n---\n\n## What Are Gasless Transactions?\n\nGasless transactions allow users to interact with blockchain applications without directly paying for gas fees. Instead, the gas costs are handled through alternative mechanisms that are invisible to the end user.\n\n### Key Mechanisms\n\n**Sponsored Transactions**: A third party (app developer, protocol, or sponsor) pays the gas fees on behalf of users.\n\n**Meta-Transactions**: Users sign transaction data off-chain, which is then submitted by a relayer who pays the actual gas fees.\n\n**Paymaster Patterns**: Smart contract accounts that can pay gas fees using any token, or have fees paid by approved sponsors.\n\n**Account Abstraction**: User accounts become smart contracts that can implement custom fee logic and payment methods.\n\n---\n\n## The Technical Foundation\n\n### ERC-4337: Account Abstraction\n\nThe ERC-4337 standard enables gasless transactions through several key components:\n\n**UserOperations**: Pseudo-transaction objects that users sign, containing their intended actions plus gas payment instructions.\n\n**Bundlers**: Services that collect UserOperations and submit them to the blockchain in bundles.\n\n**Paymasters**: Smart contracts that can sponsor gas fees under specific conditions.\n\n**EntryPoint**: A singleton contract that handles UserOperation execution and fee payment.\n\n### Smart Account Architecture\n\nGasless transactions are enabled by smart contract accounts that can:\n- Accept sponsored transactions from approved paymasters\n- Pay gas fees using any ERC-20 token\n- Implement complex fee logic and payment rules\n- Batch multiple operations into single transactions\n\n---\n\n## Gasless Transaction Models\n\n### 1. Developer-Sponsored Transactions\n\nApps pay for all user transactions, similar to how traditional apps absorb infrastructure costs.\n\n**Benefits**:\n- Completely transparent to users\n- Eliminates all gas-related friction\n- Enables micro-transactions and freemium models\n\n**Use Cases**:\n- Gaming transactions (item purchases, character actions)\n- Social media interactions (posts, likes, comments)\n- Loyalty programs and rewards distribution\n\n### 2. Token-Based Fee Payment\n\nUsers pay gas fees using tokens they already hold, without needing native network tokens.\n\n**Benefits**:\n- Simplifies the user experience to single-token interactions\n- Allows payment in stablecoins or project tokens\n- Maintains user accountability for transaction costs\n\n**Use Cases**:\n- DeFi protocols accepting fees in their native tokens\n- Stablecoin-based applications\n- Corporate treasury management\n\n### 3. Conditional Sponsorship\n\nGas fees are sponsored based on specific conditions or user behaviors.\n\n**Benefits**:\n- Incentivizes desired user actions\n- Allows for sophisticated business models\n- Balances user experience with cost control\n\n**Use Cases**:\n- First-time user onboarding (free first 10 transactions)\n- High-value customer benefits (VIP users get gasless transactions)\n- Achievement-based rewards (gasless transactions for completing tasks)\n\n### 4. Subscription Models\n\nUsers pay a flat fee for unlimited transactions within a period.\n\n**Benefits**:\n- Predictable costs for both users and developers\n- Encourages higher engagement and usage\n- Familiar business model from traditional apps\n\n**Use Cases**:\n- Professional trading platforms\n- Enterprise blockchain solutions\n- High-frequency DeFi users\n\n---\n\n## Real-World Impact Examples\n\n### Gaming: Immutable X\n\nImmutable X provides gasless NFT trading and minting, enabling:\n- Free NFT transfers and trades\n- Zero-cost in-game item transactions\n- Mainstream gaming experiences without crypto complexity\n\n**Result**: Games like Gods Unchained and Guild of Guardians have onboarded millions of users who never think about gas fees.\n\n### Social: Lens Protocol\n\nLens Protocol uses gasless transactions for social interactions:\n- Free posting, commenting, and following\n- Sponsored content creation for new users\n- Token-gated premium features\n\n**Result**: Reduced friction enables natural social media behavior without payment anxiety.\n\n### DeFi: Biconomy\n\nBiconomy's relayer network enables:\n- Gasless token swaps paid for in source tokens\n- Sponsored onboarding transactions\n- Subscription-based DeFi access\n\n**Result**: DeFi protocols see significantly higher user retention and engagement.\n\n---\n\n## Business Model Implications\n\n### For Developers\n\nGasless transactions enable new business models:\n\n**Freemium Models**: Offer basic functionality for free, charge for premium features.\n\n**User Acquisition**: Absorb gas costs to reduce onboarding friction and increase conversion rates.\n\n**Revenue Optimization**: Focus on core product value rather than explaining blockchain complexity.\n\n**Viral Growth**: Remove barriers to sharing and social features.\n\n### For Users\n\nBenefits extend beyond just cost savings:\n\n**Predictable Pricing**: Know exactly what actions cost, or know they're free.\n\n**Simplified UX**: Interact with apps using familiar Web2 patterns.\n\n**Reduced Cognitive Load**: Focus on the application's core value rather than blockchain mechanics.\n\n**Lower Risk**: Experiment with new apps without worrying about unexpected costs.\n\n---\n\n## Implementation Strategies\n\n### 1. Start with High-Value Actions\n\nIdentify the most important user actions and make those gasless first:\n- Account creation and onboarding\n- First-time interactions with core features\n- Social sharing and viral mechanics\n\n### 2. Progressive Cost Introduction\n\nGradually introduce costs as users become more engaged:\n- Free trial periods for new users\n- Gasless transactions for basic features\n- Optional premium features with transparent pricing\n\n### 3. Smart Sponsorship Rules\n\nImplement intelligent conditions for when to sponsor transactions:\n- User value thresholds (sponsor for users with >$X in assets)\n- Time-based limits (first Y transactions per day are free)\n- Action-specific rules (social interactions are free, trading incurs fees)\n\n### 4. Token Integration\n\nUse gasless transactions to drive adoption of your token:\n- Accept fees in your native token\n- Offer discounts for token holders\n- Implement staking rewards that include gasless transaction benefits\n\n---\n\n## Challenges and Solutions\n\n### Economic Sustainability\n\n**Challenge**: Developers absorbing gas costs can be expensive at scale.\n\n**Solutions**:\n- Implement usage limits and fair use policies\n- Use cross-subsidization where profitable users support free users\n- Partner with blockchain foundations or protocols for sponsorship programs\n- Implement efficient batching to reduce per-transaction costs\n\n### MEV and Front-Running\n\n**Challenge**: Gasless transactions can be vulnerable to MEV attacks.\n\n**Solutions**:\n- Use private mempools for sensitive transactions\n- Implement commit-reveal schemes for price-sensitive operations\n- Partner with MEV-protected relayer services\n- Add randomized delays for non-urgent transactions\n\n### Centralization Concerns\n\n**Challenge**: Relying on centralized relayers can create single points of failure.\n\n**Solutions**:\n- Use decentralized relayer networks\n- Implement fallback mechanisms for direct gas payment\n- Support multiple relayer services for redundancy\n- Contribute to open-source relayer infrastructure\n\n---\n\n## The Future of Gasless Transactions\n\n### Chain-Abstracted Experiences\n\nFuture gasless transaction systems will enable:\n- Seamless cross-chain interactions without managing multiple gas tokens\n- Automatic chain selection based on cost and speed preferences\n- Unified account balances that work across all chains\n\n### AI-Powered Fee Optimization\n\nSmart fee management systems will:\n- Predict optimal transaction timing for cost minimization\n- Automatically batch related transactions for efficiency\n- Learn user preferences for speed vs. cost tradeoffs\n\n### Native Protocol Integration\n\nBlockchain protocols are beginning to integrate gasless transaction support natively:\n- Protocol-level fee abstraction\n- Built-in paymaster functionality\n- Cross-chain fee payment mechanisms\n\n---\n\n## Getting Started with Gasless Transactions\n\n### For Developers\n\n1. **Choose Your Stack**: Evaluate solutions like Biconomy, Gelato, or OpenZeppelin's account abstraction tools\n2. **Start Small**: Implement gasless transactions for one key user flow\n3. **Monitor Costs**: Track gas spending and user behavior to optimize sponsorship rules\n4. **Plan Sustainability**: Design business models that can support long-term gas sponsorship\n\n### For Projects\n\n1. **Identify Pain Points**: Map where gas fees create the most user friction\n2. **Calculate ROI**: Estimate the user acquisition and retention benefits\n3. **Design Rules**: Create fair use policies that balance UX and costs\n4. **Measure Impact**: Track metrics like user onboarding completion and engagement rates\n\n---\n\n## Conclusion\n\nGasless transactions represent a fundamental shift in how users interact with blockchain applications. By removing the complexity and unpredictability of gas fees, they enable the kind of smooth, intuitive experiences that mainstream users expect.\n\nThe technology is mature enough for production use today, with multiple proven solutions and growing ecosystem support. Early adopters are already seeing significant improvements in user acquisition, engagement, and retention.\n\nAs we look toward mainstream Web3 adoption, gasless transactions aren't just a nice-to-have feature\u2014they're essential infrastructure. They bridge the gap between blockchain's powerful capabilities and the user experience standards set by traditional applications.\n\nThe projects that embrace gasless transactions today will be best positioned to onboard the next billion users to Web3. In a world where user experience increasingly determines success, eliminating gas fee friction isn't just an optimization\u2014it's a competitive necessity.\n\nThe question isn't whether gasless transactions will become standard\u2014it's how quickly your application will adopt them.", author: "Magmar Team", date: "Dec 3, 2024", readTime: "7 min", category: "Adoption", image: "/blog/Why Gasless Transactions Are the Key.png", slug: "why-gasless-transactions-are-key-to-mainstream-web3-adoption" }]; function cd() { return (0, Me.jsxs)("div", { className: "min-h-screen text-white", children: [(0, Me.jsx)(Xu, {}), (0, Me.jsx)("div", { className: "min-h-screen pt-[200px]", style: { backgroundImage: "url(".concat(oc, ")"), backgroundSize: "cover", backgroundPosition: "center", backgroundRepeat: "no-repeat", backgroundAttachment: "fixed" }, children: (0, Me.jsxs)("div", { className: "max-w-[1280px] mx-auto px-5", children: [(0, Me.jsxs)("section", { className: "pb-16 text-center", children: [(0, Me.jsxs)(hl.h1, { className: "text-5xl lg:text-[82px] leading-[90%] font-medium mb-6", initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6 }, children: ["Magmar ", (0, Me.jsx)("span", { className: "text-orange-500", children: "Blog" })] }), (0, Me.jsx)(hl.p, { className: "max-w-2xl mx-auto text-lg leading-relaxed text-white/70", initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6, delay: .1 }, children: "Discover the latest insights, updates, and technical deep-dives from the Magmar smart account abstraction team" })] }), (0, Me.jsxs)("main", { className: "w-full pb-24 space-y-16", children: [(0, Me.jsx)(hl.section, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6, delay: .2 }, children: (0, Me.jsx)(ud, { post: ld[0] }) }), (0, Me.jsx)(hl.section, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6, delay: .4 }, children: (0, Me.jsx)("div", { className: "grid grid-cols-1 gap-8 md:grid-cols-2 xl:grid-cols-3", children: ld.slice(1).map(((e, t) => (0, Me.jsx)(hl.div, { initial: { opacity: 0, y: 20 }, animate: { opacity: 1, y: 0 }, transition: { duration: .6, delay: .1 * t }, children: (0, Me.jsx)(dd, { post: e }) }, e.id))) }) }), (0, Me.jsx)("section", { className: "py-16", children: (0, Me.jsx)("div", { className: "max-w-4xl mx-auto text-center", children: (0, Me.jsxs)(hl.div, { initial: { opacity: 0, y: 20 }, whileInView: { opacity: 1, y: 0 }, transition: { duration: .6 }, viewport: { once: !0 }, children: [(0, Me.jsx)("h2", { className: "mb-8 text-3xl font-medium md:text-4xl", children: "Follow Us" }), (0, Me.jsx)("p", { className: "mb-12 text-lg text-white/70", children: "Stay connected with the Magmar community" }), (0, Me.jsx)("div", { className: "flex flex-wrap justify-center gap-6", children: hd.map((e => (0, Me.jsxs)(Pe, { to: e.url, target: "_blank", className: "flex items-center gap-3 px-6 py-4 transition-all duration-300 border rounded-lg border-white/10 bg-white/5 backdrop-blur-sm hover:bg-orange-500/10 hover:border-orange-500/20 group", children: [(0, Me.jsx)(e.icon, { className: "text-[#fd1d1d] transition-transform size-5 group-hover:scale-110" }), (0, Me.jsx)("span", { className: "text-white/70 group-hover:text-white", children: e.name })] }, e.name))) })] }) }) })] })] }) })] }) } function ud(e) { let { post: t } = e; return (0, Me.jsx)(Pe, { to: "/blog/".concat(t.slug), className: "block group", children: (0, Me.jsx)("div", { className: "overflow-hidden transition-all duration-500 border border-white/10 rounded-2xl bg-white/5 backdrop-blur-sm hover:bg-orange-500/5 hover:border-orange-500/20", children: (0, Me.jsxs)("div", { className: "flex flex-col lg:flex-row", children: [(0, Me.jsxs)("div", { className: "lg:w-1/2 aspect-[16/10] lg:aspect-[4/3] relative overflow-hidden", children: [(0, Me.jsx)("img", { src: t.image, alt: t.title, className: "object-cover w-full h-full transition-transform duration-500 group-hover:scale-105" }), (0, Me.jsx)("div", { className: "absolute inset-0 bg-gradient-to-t from-black/40 via-transparent to-transparent lg:bg-gradient-to-r lg:from-transparent lg:to-black/20" }), (0, Me.jsx)("div", { className: "absolute bottom-4 left-4", children: (0, Me.jsx)("span", { className: "px-4 py-2 text-sm text-white bg-[#fd1d1d] rounded-full", children: t.category }) })] }), (0, Me.jsxs)("div", { className: "flex flex-col justify-between p-8 lg:w-1/2 lg:p-12", children: [(0, Me.jsxs)("div", { children: [(0, Me.jsx)("h2", { className: "mb-6 text-2xl font-medium leading-tight transition-colors lg:text-4xl xl:text-5xl group-hover:text-orange-500", children: t.title }), (0, Me.jsx)("p", { className: "mb-8 text-lg leading-relaxed text-white/70", children: t.excerpt })] }), (0, Me.jsxs)("div", { className: "flex items-center gap-4", children: [(0, Me.jsxs)("div", { className: "flex items-center gap-3", children: [(0, Me.jsx)("div", { className: "relative overflow-hidden rounded-full size-10", children: (0, Me.jsx)("img", { src: "/logo.png", alt: t.author, className: "object-cover w-full h-full" }) }), (0, Me.jsxs)("div", { children: [(0, Me.jsx)("div", { className: "text-sm font-medium text-white", children: t.author }), (0, Me.jsx)("div", { className: "text-xs text-white/50", children: t.date })] })] }), (0, Me.jsxs)("div", { className: "ml-auto text-sm text-white/50", children: [t.readTime, " read"] })] })] })] }) }) }) } function dd(e) { let { post: t } = e; return (0, Me.jsx)(Pe, { to: "/blog/".concat(t.slug), className: "block h-full group", children: (0, Me.jsxs)("div", { className: "flex flex-col h-full overflow-hidden transition-all duration-300 border rounded-lg border-white/10 bg-white/5 backdrop-blur-sm hover:bg-orange-500/5 hover:border-orange-500/20", children: [(0, Me.jsxs)("div", { className: "aspect-[16/10] relative overflow-hidden", children: [(0, Me.jsx)("img", { src: t.image, alt: t.title, className: "object-cover w-full h-full transition-transform duration-300 group-hover:scale-105" }), (0, Me.jsx)("div", { className: "absolute top-3 left-3", children: (0, Me.jsx)("span", { className: "px-2 py-1 text-xs text-white bg-[#fd1d1d] rounded-full", children: t.category }) })] }), (0, Me.jsxs)("div", { className: "flex flex-col flex-1 p-6", children: [(0, Me.jsxs)("div", { className: "flex items-center gap-3 mb-3 text-xs text-white/50", children: [(0, Me.jsx)("span", { children: t.date }), (0, Me.jsx)("span", { children: "\u2022" }), (0, Me.jsxs)("span", { children: [t.readTime, " read"] })] }), (0, Me.jsx)("h3", { className: "mb-3 text-lg font-medium transition-colors group-hover:text-orange-500 line-clamp-2", children: t.title }), (0, Me.jsx)("p", { className: "flex-1 text-sm leading-relaxed text-white/70 line-clamp-3", children: t.excerpt }), (0, Me.jsxs)("div", { className: "flex items-center gap-2 pt-4 mt-4 border-t border-white/10", children: [(0, Me.jsx)("div", { className: "relative overflow-hidden rounded-full size-5", children: (0, Me.jsx)("img", { src: "/logo.png", alt: t.author, className: "object-cover w-full h-full" }) }), (0, Me.jsxs)("span", { className: "text-sm text-white/50", children: ["By ", t.author] })] })] })] }) }) } const hd = [{ name: "Twitter", url: "https://x.com/Magmarerc", icon: cu }, { name: "Telegram", url: "https://t.me/magmareth", icon: pu }]; const fd = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, pd = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, md = {}; function gd(e, t) { return ((t || md).jsx ? pd : fd).test(e) } const vd = /[ \t\n\f\r]/g; function yd(e) { return "" === e.replace(vd, "") } class bd { constructor(e, t, n) { this.normal = t, this.property = e, n && (this.space = n) } } function xd(e, t) { const n = {}, r = {}; for (const i of e) Object.assign(n, i.property), Object.assign(r, i.normal); return new bd(n, r, t) } function wd(e) { return e.toLowerCase() } bd.prototype.normal = {}, bd.prototype.property = {}, bd.prototype.space = void 0; class kd { constructor(e, t) { this.attribute = t, this.property = e } } kd.prototype.attribute = "", kd.prototype.booleanish = !1, kd.prototype.boolean = !1, kd.prototype.commaOrSpaceSeparated = !1, kd.prototype.commaSeparated = !1, kd.prototype.defined = !1, kd.prototype.mustUseProperty = !1, kd.prototype.number = !1, kd.prototype.overloadedBoolean = !1, kd.prototype.property = "", kd.prototype.spaceSeparated = !1, kd.prototype.space = void 0; let Sd = 0; const Ad = Td(), Ed = Td(), Cd = Td(), Pd = Td(), jd = Td(), Nd = Td(), Md = Td(); function Td() { return 2 ** ++Sd } const Id = Object.keys(e); class Ld extends kd { constructor(t, n, r, i) { let o = -1; if (super(t, n), Rd(this, "space", i), "number" === typeof r) for (; ++o < Id.length;) { const t = Id[o]; Rd(this, Id[o], (r & e[t]) === e[t]) } } } function Rd(e, t, n) { n && (e[t] = n) } function Dd(e) { const t = {}, n = {}; for (const [r, i] of Object.entries(e.properties)) { const o = new Ld(r, e.transform(e.attributes || {}, r), i, e.space); e.mustUseProperty && e.mustUseProperty.includes(r) && (o.mustUseProperty = !0), t[r] = o, n[wd(r)] = r, n[wd(o.attribute)] = r } return new bd(t, n, e.space) } Ld.prototype.defined = !0; const zd = Dd({ properties: { ariaActiveDescendant: null, ariaAtomic: Ed, ariaAutoComplete: null, ariaBusy: Ed, ariaChecked: Ed, ariaColCount: Pd, ariaColIndex: Pd, ariaColSpan: Pd, ariaControls: jd, ariaCurrent: null, ariaDescribedBy: jd, ariaDetails: null, ariaDisabled: Ed, ariaDropEffect: jd, ariaErrorMessage: null, ariaExpanded: Ed, ariaFlowTo: jd, ariaGrabbed: Ed, ariaHasPopup: null, ariaHidden: Ed, ariaInvalid: null, ariaKeyShortcuts: null, ariaLabel: null, ariaLabelledBy: jd, ariaLevel: Pd, ariaLive: null, ariaModal: Ed, ariaMultiLine: Ed, ariaMultiSelectable: Ed, ariaOrientation: null, ariaOwns: jd, ariaPlaceholder: null, ariaPosInSet: Pd, ariaPressed: Ed, ariaReadOnly: Ed, ariaRelevant: null, ariaRequired: Ed, ariaRoleDescription: jd, ariaRowCount: Pd, ariaRowIndex: Pd, ariaRowSpan: Pd, ariaSelected: Ed, ariaSetSize: Pd, ariaSort: null, ariaValueMax: Pd, ariaValueMin: Pd, ariaValueNow: Pd, ariaValueText: null, role: null }, transform: (e, t) => "role" === t ? t : "aria-" + t.slice(4).toLowerCase() }); function Od(e, t) { return t in e ? e[t] : t } function Bd(e, t) { return Od(e, t.toLowerCase()) } const Fd = Dd({ attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" }, mustUseProperty: ["checked", "multiple", "muted", "selected"], properties: { abbr: null, accept: Nd, acceptCharset: jd, accessKey: jd, action: null, allow: null, allowFullScreen: Ad, allowPaymentRequest: Ad, allowUserMedia: Ad, alt: null, as: null, async: Ad, autoCapitalize: null, autoComplete: jd, autoFocus: Ad, autoPlay: Ad, blocking: jd, capture: null, charSet: null, checked: Ad, cite: null, className: jd, cols: Pd, colSpan: null, content: null, contentEditable: Ed, controls: Ad, controlsList: jd, coords: Pd | Nd, crossOrigin: null, data: null, dateTime: null, decoding: null, default: Ad, defer: Ad, dir: null, dirName: null, disabled: Ad, download: Cd, draggable: Ed, encType: null, enterKeyHint: null, fetchPriority: null, form: null, formAction: null, formEncType: null, formMethod: null, formNoValidate: Ad, formTarget: null, headers: jd, height: Pd, hidden: Cd, high: Pd, href: null, hrefLang: null, htmlFor: jd, httpEquiv: jd, id: null, imageSizes: null, imageSrcSet: null, inert: Ad, inputMode: null, integrity: null, is: null, isMap: Ad, itemId: null, itemProp: jd, itemRef: jd, itemScope: Ad, itemType: jd, kind: null, label: null, lang: null, language: null, list: null, loading: null, loop: Ad, low: Pd, manifest: null, max: null, maxLength: Pd, media: null, method: null, min: null, minLength: Pd, multiple: Ad, muted: Ad, name: null, nonce: null, noModule: Ad, noValidate: Ad, onAbort: null, onAfterPrint: null, onAuxClick: null, onBeforeMatch: null, onBeforePrint: null, onBeforeToggle: null, onBeforeUnload: null, onBlur: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onContextLost: null, onContextMenu: null, onContextRestored: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnded: null, onError: null, onFocus: null, onFormData: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLanguageChange: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadEnd: null, onLoadStart: null, onMessage: null, onMessageError: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRejectionHandled: null, onReset: null, onResize: null, onScroll: null, onScrollEnd: null, onSecurityPolicyViolation: null, onSeeked: null, onSeeking: null, onSelect: null, onSlotChange: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnhandledRejection: null, onUnload: null, onVolumeChange: null, onWaiting: null, onWheel: null, open: Ad, optimum: Pd, pattern: null, ping: jd, placeholder: null, playsInline: Ad, popover: null, popoverTarget: null, popoverTargetAction: null, poster: null, preload: null, readOnly: Ad, referrerPolicy: null, rel: jd, required: Ad, reversed: Ad, rows: Pd, rowSpan: Pd, sandbox: jd, scope: null, scoped: Ad, seamless: Ad, selected: Ad, shadowRootClonable: Ad, shadowRootDelegatesFocus: Ad, shadowRootMode: null, shape: null, size: Pd, sizes: null, slot: null, span: Pd, spellCheck: Ed, src: null, srcDoc: null, srcLang: null, srcSet: null, start: Pd, step: null, style: null, tabIndex: Pd, target: null, title: null, translate: null, type: null, typeMustMatch: Ad, useMap: null, value: Ed, width: Pd, wrap: null, writingSuggestions: null, align: null, aLink: null, archive: jd, axis: null, background: null, bgColor: null, border: Pd, borderColor: null, bottomMargin: Pd, cellPadding: null, cellSpacing: null, char: null, charOff: null, classId: null, clear: null, code: null, codeBase: null, codeType: null, color: null, compact: Ad, declare: Ad, event: null, face: null, frame: null, frameBorder: null, hSpace: Pd, leftMargin: Pd, link: null, longDesc: null, lowSrc: null, marginHeight: Pd, marginWidth: Pd, noResize: Ad, noHref: Ad, noShade: Ad, noWrap: Ad, object: null, profile: null, prompt: null, rev: null, rightMargin: Pd, rules: null, scheme: null, scrolling: Ed, standby: null, summary: null, text: null, topMargin: Pd, valueType: null, version: null, vAlign: null, vLink: null, vSpace: Pd, allowTransparency: null, autoCorrect: null, autoSave: null, disablePictureInPicture: Ad, disableRemotePlayback: Ad, prefix: null, property: null, results: Pd, security: null, unselectable: null }, space: "html", transform: Bd }), Vd = Dd({ attributes: { accentHeight: "accent-height", alignmentBaseline: "alignment-baseline", arabicForm: "arabic-form", baselineShift: "baseline-shift", capHeight: "cap-height", className: "class", clipPath: "clip-path", clipRule: "clip-rule", colorInterpolation: "color-interpolation", colorInterpolationFilters: "color-interpolation-filters", colorProfile: "color-profile", colorRendering: "color-rendering", crossOrigin: "crossorigin", dataType: "datatype", dominantBaseline: "dominant-baseline", enableBackground: "enable-background", fillOpacity: "fill-opacity", fillRule: "fill-rule", floodColor: "flood-color", floodOpacity: "flood-opacity", fontFamily: "font-family", fontSize: "font-size", fontSizeAdjust: "font-size-adjust", fontStretch: "font-stretch", fontStyle: "font-style", fontVariant: "font-variant", fontWeight: "font-weight", glyphName: "glyph-name", glyphOrientationHorizontal: "glyph-orientation-horizontal", glyphOrientationVertical: "glyph-orientation-vertical", hrefLang: "hreflang", horizAdvX: "horiz-adv-x", horizOriginX: "horiz-origin-x", horizOriginY: "horiz-origin-y", imageRendering: "image-rendering", letterSpacing: "letter-spacing", lightingColor: "lighting-color", markerEnd: "marker-end", markerMid: "marker-mid", markerStart: "marker-start", navDown: "nav-down", navDownLeft: "nav-down-left", navDownRight: "nav-down-right", navLeft: "nav-left", navNext: "nav-next", navPrev: "nav-prev", navRight: "nav-right", navUp: "nav-up", navUpLeft: "nav-up-left", navUpRight: "nav-up-right", onAbort: "onabort", onActivate: "onactivate", onAfterPrint: "onafterprint", onBeforePrint: "onbeforeprint", onBegin: "onbegin", onCancel: "oncancel", onCanPlay: "oncanplay", onCanPlayThrough: "oncanplaythrough", onChange: "onchange", onClick: "onclick", onClose: "onclose", onCopy: "oncopy", onCueChange: "oncuechange", onCut: "oncut", onDblClick: "ondblclick", onDrag: "ondrag", onDragEnd: "ondragend", onDragEnter: "ondragenter", onDragExit: "ondragexit", onDragLeave: "ondragleave", onDragOver: "ondragover", onDragStart: "ondragstart", onDrop: "ondrop", onDurationChange: "ondurationchange", onEmptied: "onemptied", onEnd: "onend", onEnded: "onended", onError: "onerror", onFocus: "onfocus", onFocusIn: "onfocusin", onFocusOut: "onfocusout", onHashChange: "onhashchange", onInput: "oninput", onInvalid: "oninvalid", onKeyDown: "onkeydown", onKeyPress: "onkeypress", onKeyUp: "onkeyup", onLoad: "onload", onLoadedData: "onloadeddata", onLoadedMetadata: "onloadedmetadata", onLoadStart: "onloadstart", onMessage: "onmessage", onMouseDown: "onmousedown", onMouseEnter: "onmouseenter", onMouseLeave: "onmouseleave", onMouseMove: "onmousemove", onMouseOut: "onmouseout", onMouseOver: "onmouseover", onMouseUp: "onmouseup", onMouseWheel: "onmousewheel", onOffline: "onoffline", onOnline: "ononline", onPageHide: "onpagehide", onPageShow: "onpageshow", onPaste: "onpaste", onPause: "onpause", onPlay: "onplay", onPlaying: "onplaying", onPopState: "onpopstate", onProgress: "onprogress", onRateChange: "onratechange", onRepeat: "onrepeat", onReset: "onreset", onResize: "onresize", onScroll: "onscroll", onSeeked: "onseeked", onSeeking: "onseeking", onSelect: "onselect", onShow: "onshow", onStalled: "onstalled", onStorage: "onstorage", onSubmit: "onsubmit", onSuspend: "onsuspend", onTimeUpdate: "ontimeupdate", onToggle: "ontoggle", onUnload: "onunload", onVolumeChange: "onvolumechange", onWaiting: "onwaiting", onZoom: "onzoom", overlinePosition: "overline-position", overlineThickness: "overline-thickness", paintOrder: "paint-order", panose1: "panose-1", pointerEvents: "pointer-events", referrerPolicy: "referrerpolicy", renderingIntent: "rendering-intent", shapeRendering: "shape-rendering", stopColor: "stop-color", stopOpacity: "stop-opacity", strikethroughPosition: "strikethrough-position", strikethroughThickness: "strikethrough-thickness", strokeDashArray: "stroke-dasharray", strokeDashOffset: "stroke-dashoffset", strokeLineCap: "stroke-linecap", strokeLineJoin: "stroke-linejoin", strokeMiterLimit: "stroke-miterlimit", strokeOpacity: "stroke-opacity", strokeWidth: "stroke-width", tabIndex: "tabindex", textAnchor: "text-anchor", textDecoration: "text-decoration", textRendering: "text-rendering", transformOrigin: "transform-origin", typeOf: "typeof", underlinePosition: "underline-position", underlineThickness: "underline-thickness", unicodeBidi: "unicode-bidi", unicodeRange: "unicode-range", unitsPerEm: "units-per-em", vAlphabetic: "v-alphabetic", vHanging: "v-hanging", vIdeographic: "v-ideographic", vMathematical: "v-mathematical", vectorEffect: "vector-effect", vertAdvY: "vert-adv-y", vertOriginX: "vert-origin-x", vertOriginY: "vert-origin-y", wordSpacing: "word-spacing", writingMode: "writing-mode", xHeight: "x-height", playbackOrder: "playbackorder", timelineBegin: "timelinebegin" }, properties: { about: Md, accentHeight: Pd, accumulate: null, additive: null, alignmentBaseline: null, alphabetic: Pd, amplitude: Pd, arabicForm: null, ascent: Pd, attributeName: null, attributeType: null, azimuth: Pd, bandwidth: null, baselineShift: null, baseFrequency: null, baseProfile: null, bbox: null, begin: null, bias: Pd, by: null, calcMode: null, capHeight: Pd, className: jd, clip: null, clipPath: null, clipPathUnits: null, clipRule: null, color: null, colorInterpolation: null, colorInterpolationFilters: null, colorProfile: null, colorRendering: null, content: null, contentScriptType: null, contentStyleType: null, crossOrigin: null, cursor: null, cx: null, cy: null, d: null, dataType: null, defaultAction: null, descent: Pd, diffuseConstant: Pd, direction: null, display: null, dur: null, divisor: Pd, dominantBaseline: null, download: Ad, dx: null, dy: null, edgeMode: null, editable: null, elevation: Pd, enableBackground: null, end: null, event: null, exponent: Pd, externalResourcesRequired: null, fill: null, fillOpacity: Pd, fillRule: null, filter: null, filterRes: null, filterUnits: null, floodColor: null, floodOpacity: null, focusable: null, focusHighlight: null, fontFamily: null, fontSize: null, fontSizeAdjust: null, fontStretch: null, fontStyle: null, fontVariant: null, fontWeight: null, format: null, fr: null, from: null, fx: null, fy: null, g1: Nd, g2: Nd, glyphName: Nd, glyphOrientationHorizontal: null, glyphOrientationVertical: null, glyphRef: null, gradientTransform: null, gradientUnits: null, handler: null, hanging: Pd, hatchContentUnits: null, hatchUnits: null, height: null, href: null, hrefLang: null, horizAdvX: Pd, horizOriginX: Pd, horizOriginY: Pd, id: null, ideographic: Pd, imageRendering: null, initialVisibility: null, in: null, in2: null, intercept: Pd, k: Pd, k1: Pd, k2: Pd, k3: Pd, k4: Pd, kernelMatrix: Md, kernelUnitLength: null, keyPoints: null, keySplines: null, keyTimes: null, kerning: null, lang: null, lengthAdjust: null, letterSpacing: null, lightingColor: null, limitingConeAngle: Pd, local: null, markerEnd: null, markerMid: null, markerStart: null, markerHeight: null, markerUnits: null, markerWidth: null, mask: null, maskContentUnits: null, maskUnits: null, mathematical: null, max: null, media: null, mediaCharacterEncoding: null, mediaContentEncodings: null, mediaSize: Pd, mediaTime: null, method: null, min: null, mode: null, name: null, navDown: null, navDownLeft: null, navDownRight: null, navLeft: null, navNext: null, navPrev: null, navRight: null, navUp: null, navUpLeft: null, navUpRight: null, numOctaves: null, observer: null, offset: null, onAbort: null, onActivate: null, onAfterPrint: null, onBeforePrint: null, onBegin: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnd: null, onEnded: null, onError: null, onFocus: null, onFocusIn: null, onFocusOut: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadStart: null, onMessage: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onMouseWheel: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRepeat: null, onReset: null, onResize: null, onScroll: null, onSeeked: null, onSeeking: null, onSelect: null, onShow: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnload: null, onVolumeChange: null, onWaiting: null, onZoom: null, opacity: null, operator: null, order: null, orient: null, orientation: null, origin: null, overflow: null, overlay: null, overlinePosition: Pd, overlineThickness: Pd, paintOrder: null, panose1: null, path: null, pathLength: Pd, patternContentUnits: null, patternTransform: null, patternUnits: null, phase: null, ping: jd, pitch: null, playbackOrder: null, pointerEvents: null, points: null, pointsAtX: Pd, pointsAtY: Pd, pointsAtZ: Pd, preserveAlpha: null, preserveAspectRatio: null, primitiveUnits: null, propagate: null, property: Md, r: null, radius: null, referrerPolicy: null, refX: null, refY: null, rel: Md, rev: Md, renderingIntent: null, repeatCount: null, repeatDur: null, requiredExtensions: Md, requiredFeatures: Md, requiredFonts: Md, requiredFormats: Md, resource: null, restart: null, result: null, rotate: null, rx: null, ry: null, scale: null, seed: null, shapeRendering: null, side: null, slope: null, snapshotTime: null, specularConstant: Pd, specularExponent: Pd, spreadMethod: null, spacing: null, startOffset: null, stdDeviation: null, stemh: null, stemv: null, stitchTiles: null, stopColor: null, stopOpacity: null, strikethroughPosition: Pd, strikethroughThickness: Pd, string: null, stroke: null, strokeDashArray: Md, strokeDashOffset: null, strokeLineCap: null, strokeLineJoin: null, strokeMiterLimit: Pd, strokeOpacity: Pd, strokeWidth: null, style: null, surfaceScale: Pd, syncBehavior: null, syncBehaviorDefault: null, syncMaster: null, syncTolerance: null, syncToleranceDefault: null, systemLanguage: Md, tabIndex: Pd, tableValues: null, target: null, targetX: Pd, targetY: Pd, textAnchor: null, textDecoration: null, textRendering: null, textLength: null, timelineBegin: null, title: null, transformBehavior: null, type: null, typeOf: Md, to: null, transform: null, transformOrigin: null, u1: null, u2: null, underlinePosition: Pd, underlineThickness: Pd, unicode: null, unicodeBidi: null, unicodeRange: null, unitsPerEm: Pd, values: null, vAlphabetic: Pd, vMathematical: Pd, vectorEffect: null, vHanging: Pd, vIdeographic: Pd, version: null, vertAdvY: Pd, vertOriginX: Pd, vertOriginY: Pd, viewBox: null, viewTarget: null, visibility: null, width: null, widths: null, wordSpacing: null, writingMode: null, x: null, x1: null, x2: null, xChannelSelector: null, xHeight: Pd, y: null, y1: null, y2: null, yChannelSelector: null, z: null, zoomAndPan: null }, space: "svg", transform: Od }), Ud = Dd({ properties: { xLinkActuate: null, xLinkArcRole: null, xLinkHref: null, xLinkRole: null, xLinkShow: null, xLinkTitle: null, xLinkType: null }, space: "xlink", transform: (e, t) => "xlink:" + t.slice(5).toLowerCase() }), Wd = Dd({ attributes: { xmlnsxlink: "xmlns:xlink" }, properties: { xmlnsXLink: null, xmlns: null }, space: "xmlns", transform: Bd }), Hd = Dd({ properties: { xmlBase: null, xmlLang: null, xmlSpace: null }, space: "xml", transform: (e, t) => "xml:" + t.slice(3).toLowerCase() }), Yd = xd([zd, Fd, Ud, Wd, Hd], "html"), Xd = xd([zd, Vd, Ud, Wd, Hd], "svg"), Qd = /[A-Z]/g, qd = /-[a-z]/g, Zd = /^data[-\w.:]+$/i; function Kd(e) { return "-" + e.toLowerCase() } function Gd(e) { return e.charAt(1).toUpperCase() } const Jd = { classId: "classID", dataType: "datatype", itemId: "itemID", strokeDashArray: "strokeDasharray", strokeDashOffset: "strokeDashoffset", strokeLineCap: "strokeLinecap", strokeLineJoin: "strokeLinejoin", strokeMiterLimit: "strokeMiterlimit", typeOf: "typeof", xLinkActuate: "xlinkActuate", xLinkArcRole: "xlinkArcrole", xLinkHref: "xlinkHref", xLinkRole: "xlinkRole", xLinkShow: "xlinkShow", xLinkTitle: "xlinkTitle", xLinkType: "xlinkType", xmlnsXLink: "xmlnsXlink" }; var _d = n(294); const $d = th("end"), eh = th("start"); function th(e) { return function (t) { const n = t && t.position && t.position[e] || {}; if ("number" === typeof n.line && n.line > 0 && "number" === typeof n.column && n.column > 0) return { line: n.line, column: n.column, offset: "number" === typeof n.offset && n.offset > -1 ? n.offset : void 0 } } } function nh(e) { return e && "object" === typeof e ? "position" in e || "type" in e ? ih(e.position) : "start" in e || "end" in e ? ih(e) : "line" in e || "column" in e ? rh(e) : "" : "" } function rh(e) { return oh(e && e.line) + ":" + oh(e && e.column) } function ih(e) { return rh(e && e.start) + "-" + rh(e && e.end) } function oh(e) { return e && "number" === typeof e ? e : 1 } class ah extends Error { constructor(e, t, n) { super(), "string" === typeof t && (n = t, t = void 0); let r = "", i = {}, o = !1; if (t && (i = "line" in t && "column" in t || "start" in t && "end" in t ? { place: t } : "type" in t ? { ancestors: [t], place: t.position } : { ...t }), "string" === typeof e ? r = e : !i.cause && e && (o = !0, r = e.message, i.cause = e), !i.ruleId && !i.source && "string" === typeof n) { const e = n.indexOf(":"); -1 === e ? i.ruleId = n : (i.source = n.slice(0, e), i.ruleId = n.slice(e + 1)) } if (!i.place && i.ancestors && i.ancestors) { const e = i.ancestors[i.ancestors.length - 1]; e && (i.place = e.position) } const a = i.place && "start" in i.place ? i.place.start : i.place; this.ancestors = i.ancestors || void 0, this.cause = i.cause || void 0, this.column = a ? a.column : void 0, this.fatal = void 0, this.file, this.message = r, this.line = a ? a.line : void 0, this.name = nh(i.place) || "1:1", this.place = i.place || void 0, this.reason = this.message, this.ruleId = i.ruleId || void 0, this.source = i.source || void 0, this.stack = o && i.cause && "string" === typeof i.cause.stack ? i.cause.stack : "", this.actual, this.expected, this.note, this.url } } ah.prototype.file = "", ah.prototype.name = "", ah.prototype.reason = "", ah.prototype.message = "", ah.prototype.stack = "", ah.prototype.column = void 0, ah.prototype.line = void 0, ah.prototype.ancestors = void 0, ah.prototype.cause = void 0, ah.prototype.fatal = void 0, ah.prototype.place = void 0, ah.prototype.ruleId = void 0, ah.prototype.source = void 0; const sh = {}.hasOwnProperty, lh = new Map, ch = /[A-Z]/g, uh = new Set(["table", "tbody", "thead", "tfoot", "tr"]), dh = new Set(["td", "th"]), hh = "https://github.com/syntax-tree/hast-util-to-jsx-runtime"; function fh(e, t) { if (!t || void 0 === t.Fragment) throw new TypeError("Expected `Fragment` in options"); const n = t.filePath || void 0; let r; if (t.development) { if ("function" !== typeof t.jsxDEV) throw new TypeError("Expected `jsxDEV` in options when `development: true`"); r = function (e, t) { return n; function n(n, r, i, o) { const a = Array.isArray(i.children), s = eh(n); return t(r, i, o, a, { columnNumber: s ? s.column - 1 : void 0, fileName: e, lineNumber: s ? s.line : void 0 }, void 0) } }(n, t.jsxDEV) } else { if ("function" !== typeof t.jsx) throw new TypeError("Expected `jsx` in production options"); if ("function" !== typeof t.jsxs) throw new TypeError("Expected `jsxs` in production options"); r = function (e, t, n) { return r; function r(e, r, i, o) { const a = Array.isArray(i.children) ? n : t; return o ? a(r, i, o) : a(r, i) } }(0, t.jsx, t.jsxs) } const i = { Fragment: t.Fragment, ancestors: [], components: t.components || {}, create: r, elementAttributeNameCase: t.elementAttributeNameCase || "react", evaluater: t.createEvaluater ? t.createEvaluater() : void 0, filePath: n, ignoreInvalidStyle: t.ignoreInvalidStyle || !1, passKeys: !1 !== t.passKeys, passNode: t.passNode || !1, schema: "svg" === t.space ? Xd : Yd, stylePropertyNameCase: t.stylePropertyNameCase || "dom", tableCellAlignToStyle: !1 !== t.tableCellAlignToStyle }, o = ph(i, e, void 0); return o && "string" !== typeof o ? o : i.create(e, i.Fragment, { children: o || void 0 }, void 0) } function ph(e, t, n) { return "element" === t.type ? function (e, t, n) { const r = e.schema; let i = r; "svg" === t.tagName.toLowerCase() && "html" === r.space && (i = Xd, e.schema = i); e.ancestors.push(t); const o = bh(e, t.tagName, !1), a = function (e, t) { const n = {}; let r, i; for (i in t.properties) if ("children" !== i && sh.call(t.properties, i)) { const o = yh(e, i, t.properties[i]); if (o) { const [i, a] = o; e.tableCellAlignToStyle && "align" === i && "string" === typeof a && dh.has(t.tagName) ? r = a : n[i] = a } } if (r) { (n.style || (n.style = {}))["css" === e.stylePropertyNameCase ? "text-align" : "textAlign"] = r } return n }(e, t); let s = vh(e, t); uh.has(t.tagName) && (s = s.filter((function (e) { return "string" !== typeof e || !("object" === typeof (t = e) ? "text" === t.type && yd(t.value) : yd(t)); var t }))); return mh(e, a, o, t), gh(a, s), e.ancestors.pop(), e.schema = r, e.create(t, o, a, n) }(e, t, n) : "mdxFlowExpression" === t.type || "mdxTextExpression" === t.type ? function (e, t) { if (t.data && t.data.estree && e.evaluater) { const n = t.data.estree.body[0]; return n.type, e.evaluater.evaluateExpression(n.expression) } xh(e, t.position) }(e, t) : "mdxJsxFlowElement" === t.type || "mdxJsxTextElement" === t.type ? function (e, t, n) { const r = e.schema; let i = r; "svg" === t.name && "html" === r.space && (i = Xd, e.schema = i); e.ancestors.push(t); const o = null === t.name ? e.Fragment : bh(e, t.name, !0), a = function (e, t) { const n = {}; for (const r of t.attributes) if ("mdxJsxExpressionAttribute" === r.type) if (r.data && r.data.estree && e.evaluater) { const t = r.data.estree.body[0]; t.type; const i = t.expression; i.type; const o = i.properties[0]; o.type, Object.assign(n, e.evaluater.evaluateExpression(o.argument)) } else xh(e, t.position); else { const i = r.name; let o; if (r.value && "object" === typeof r.value) if (r.value.data && r.value.data.estree && e.evaluater) { const t = r.value.data.estree.body[0]; t.type, o = e.evaluater.evaluateExpression(t.expression) } else xh(e, t.position); else o = null === r.value || r.value; n[i] = o } return n }(e, t), s = vh(e, t); return mh(e, a, o, t), gh(a, s), e.ancestors.pop(), e.schema = r, e.create(t, o, a, n) }(e, t, n) : "mdxjsEsm" === t.type ? function (e, t) { if (t.data && t.data.estree && e.evaluater) return e.evaluater.evaluateProgram(t.data.estree); xh(e, t.position) }(e, t) : "root" === t.type ? function (e, t, n) { const r = {}; return gh(r, vh(e, t)), e.create(t, e.Fragment, r, n) }(e, t, n) : "text" === t.type ? function (e, t) { return t.value }(0, t) : void 0 } function mh(e, t, n, r) { "string" !== typeof n && n !== e.Fragment && e.passNode && (t.node = r) } function gh(e, t) { if (t.length > 0) { const n = t.length > 1 ? t : t[0]; n && (e.children = n) } } function vh(e, t) { const n = []; let r = -1; const i = e.passKeys ? new Map : lh; for (; ++r < t.children.length;) { const o = t.children[r]; let a; if (e.passKeys) { const e = "element" === o.type ? o.tagName : "mdxJsxFlowElement" === o.type || "mdxJsxTextElement" === o.type ? o.name : void 0; if (e) { const t = i.get(e) || 0; a = e + "-" + t, i.set(e, t + 1) } } const s = ph(e, o, a); void 0 !== s && n.push(s) } return n } function yh(e, t, n) { const r = function (e, t) { const n = wd(t); let r = t, i = kd; if (n in e.normal) return e.property[e.normal[n]]; if (n.length > 4 && "data" === n.slice(0, 4) && Zd.test(t)) { if ("-" === t.charAt(4)) { const e = t.slice(5).replace(qd, Gd); r = "data" + e.charAt(0).toUpperCase() + e.slice(1) } else { const e = t.slice(4); if (!qd.test(e)) { let n = e.replace(Qd, Kd); "-" !== n.charAt(0) && (n = "-" + n), t = "data" + n } } i = Ld } return new i(r, t) }(e.schema, t); if (!(null === n || void 0 === n || "number" === typeof n && Number.isNaN(n))) { if (Array.isArray(n) && (n = r.commaSeparated ? function (e, t) { const n = t || {}; return ("" === e[e.length - 1] ? [...e, ""] : e).join((n.padRight ? " " : "") + "," + (!1 === n.padLeft ? "" : " ")).trim() }(n) : n.join(" ").trim()), "style" === r.property) { let t = "object" === typeof n ? n : function (e, t) { try { return _d(t, { reactCompat: !0 }) } catch (n) { if (e.ignoreInvalidStyle) return {}; const t = n, r = new ah("Cannot parse `style` attribute", { ancestors: e.ancestors, cause: t, ruleId: "style", source: "hast-util-to-jsx-runtime" }); throw r.file = e.filePath || void 0, r.url = hh + "#cannot-parse-style-attribute", r } }(e, String(n)); return "css" === e.stylePropertyNameCase && (t = function (e) { const t = {}; let n; for (n in e) sh.call(e, n) && (t[wh(n)] = e[n]); return t }(t)), ["style", t] } return ["react" === e.elementAttributeNameCase && r.space ? Jd[r.property] || r.property : r.attribute, n] } } function bh(e, t, n) { let r; if (n) if (t.includes(".")) { const e = t.split("."); let n, i = -1; for (; ++i < e.length;) { const t = gd(e[i]) ? { type: "Identifier", name: e[i] } : { type: "Literal", value: e[i] }; n = n ? { type: "MemberExpression", object: n, property: t, computed: Boolean(i && "Literal" === t.type), optional: !1 } : t } r = n } else r = gd(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t }; else r = { type: "Literal", value: t }; if ("Literal" === r.type) { const t = r.value; return sh.call(e.components, t) ? e.components[t] : t } if (e.evaluater) return e.evaluater.evaluateExpression(r); xh(e) } function xh(e, t) { const n = new ah("Cannot handle MDX estrees without `createEvaluater`", { ancestors: e.ancestors, place: t, ruleId: "mdx-estree", source: "hast-util-to-jsx-runtime" }); throw n.file = e.filePath || void 0, n.url = hh + "#cannot-handle-mdx-estrees-without-createevaluater", n } function wh(e) { let t = e.replace(ch, kh); return "ms-" === t.slice(0, 3) && (t = "-" + t), t } function kh(e) { return "-" + e.toLowerCase() } const Sh = { action: ["form"], cite: ["blockquote", "del", "ins", "q"], data: ["object"], formAction: ["button", "input"], href: ["a", "area", "base", "link"], icon: ["menuitem"], itemId: null, manifest: ["html"], ping: ["a", "area"], poster: ["video"], src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"] }, Ah = {}; function Eh(e, t) { const n = t || Ah; return Ch(e, "boolean" !== typeof n.includeImageAlt || n.includeImageAlt, "boolean" !== typeof n.includeHtml || n.includeHtml) } function Ch(e, t, n) { if (function (e) { return Boolean(e && "object" === typeof e) }(e)) { if ("value" in e) return "html" !== e.type || n ? e.value : ""; if (t && "alt" in e && e.alt) return e.alt; if ("children" in e) return Ph(e.children, t, n) } return Array.isArray(e) ? Ph(e, t, n) : "" } function Ph(e, t, n) { const r = []; let i = -1; for (; ++i < e.length;)r[i] = Ch(e[i], t, n); return r.join("") } function jh(e, t, n, r) { const i = e.length; let o, a = 0; if (t = t < 0 ? -t > i ? 0 : i + t : t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4) o = Array.from(r), o.unshift(t, n), e.splice(...o); else for (n && e.splice(t, n); a < r.length;)o = r.slice(a, a + 1e4), o.unshift(t, 0), e.splice(...o), a += 1e4, t += 1e4 } function Nh(e, t) { return e.length > 0 ? (jh(e, e.length, 0, t), e) : t } class Mh { constructor(e) { this.left = e ? [...e] : [], this.right = [] } get(e) { if (e < 0 || e >= this.left.length + this.right.length) throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"); return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1] } get length() { return this.left.length + this.right.length } shift() { return this.setCursor(0), this.right.pop() } slice(e, t) { const n = null === t || void 0 === t ? Number.POSITIVE_INFINITY : t; return n < this.left.length ? this.left.slice(e, n) : e > this.left.length ? this.right.slice(this.right.length - n + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - n + this.left.length).reverse()) } splice(e, t, n) { const r = t || 0; this.setCursor(Math.trunc(e)); const i = this.right.splice(this.right.length - r, Number.POSITIVE_INFINITY); return n && Th(this.left, n), i.reverse() } pop() { return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop() } push(e) { this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e) } pushMany(e) { this.setCursor(Number.POSITIVE_INFINITY), Th(this.left, e) } unshift(e) { this.setCursor(0), this.right.push(e) } unshiftMany(e) { this.setCursor(0), Th(this.right, e.reverse()) } setCursor(e) { if (!(e === this.left.length || e > this.left.length && 0 === this.right.length || e < 0 && 0 === this.left.length)) if (e < this.left.length) { const t = this.left.splice(e, Number.POSITIVE_INFINITY); Th(this.right, t.reverse()) } else { const t = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY); Th(this.left, t.reverse()) } } } function Th(e, t) { let n = 0; if (t.length < 1e4) e.push(...t); else for (; n < t.length;)e.push(...t.slice(n, n + 1e4)), n += 1e4 } function Ih(e) { const t = {}; let n, r, i, o, a, s, l, c = -1; const u = new Mh(e); for (; ++c < u.length;) { for (; c in t;)c = t[c]; if (n = u.get(c), c && "chunkFlow" === n[1].type && "listItemPrefix" === u.get(c - 1)[1].type && (s = n[1]._tokenizer.events, i = 0, i < s.length && "lineEndingBlank" === s[i][1].type && (i += 2), i < s.length && "content" === s[i][1].type)) for (; ++i < s.length && "content" !== s[i][1].type;)"chunkText" === s[i][1].type && (s[i][1]._isInFirstContentOfListItem = !0, i++); if ("enter" === n[0]) n[1].contentType && (Object.assign(t, Lh(u, c)), c = t[c], l = !0); else if (n[1]._container) { for (i = c, r = void 0; i--;)if (o = u.get(i), "lineEnding" === o[1].type || "lineEndingBlank" === o[1].type) "enter" === o[0] && (r && (u.get(r)[1].type = "lineEndingBlank"), o[1].type = "lineEnding", r = i); else if ("linePrefix" !== o[1].type && "listItemIndent" !== o[1].type) break; r && (n[1].end = { ...u.get(r)[1].start }, a = u.slice(r, c), a.unshift(n), u.splice(r, c - r + 1, a)) } } return jh(e, 0, Number.POSITIVE_INFINITY, u.slice(0)), !l } function Lh(e, t) { const n = e.get(t)[1], r = e.get(t)[2]; let i = t - 1; const o = []; let a = n._tokenizer; a || (a = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (a._contentTypeTextTrailing = !0)); const s = a.events, l = [], c = {}; let u, d, h = -1, f = n, p = 0, m = 0; const g = [m]; for (; f;) { for (; e.get(++i)[1] !== f;); o.push(i), f._tokenizer || (u = r.sliceStream(f), f.next || u.push(null), d && a.defineSkip(f.start), f._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(u), f._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), d = f, f = f.next } for (f = n; ++h < s.length;)"exit" === s[h][0] && "enter" === s[h - 1][0] && s[h][1].type === s[h - 1][1].type && s[h][1].start.line !== s[h][1].end.line && (m = h + 1, g.push(m), f._tokenizer = void 0, f.previous = void 0, f = f.next); for (a.events = [], f ? (f._tokenizer = void 0, f.previous = void 0) : g.pop(), h = g.length; h--;) { const t = s.slice(g[h], g[h + 1]), n = o.pop(); l.push([n, n + t.length - 1]), e.splice(n, 2, t) } for (l.reverse(), h = -1; ++h < l.length;)c[p + l[h][0]] = p + l[h][1], p += l[h][1] - l[h][0] - 1; return c } const Rh = {}.hasOwnProperty; function Dh(e) { const t = {}; let n = -1; for (; ++n < e.length;)zh(t, e[n]); return t } function zh(e, t) { let n; for (n in t) { const r = (Rh.call(e, n) ? e[n] : void 0) || (e[n] = {}), i = t[n]; let o; if (i) for (o in i) { Rh.call(r, o) || (r[o] = []); const e = i[o]; Oh(r[o], Array.isArray(e) ? e : e ? [e] : []) } } } function Oh(e, t) { let n = -1; const r = []; for (; ++n < t.length;)("after" === t[n].add ? e : r).push(t[n]); jh(e, 0, 0, r) } const Bh = Gh(/[A-Za-z]/), Fh = Gh(/[\dA-Za-z]/), Vh = Gh(/[#-'*+\--9=?A-Z^-~]/); function Uh(e) { return null !== e && (e < 32 || 127 === e) } const Wh = Gh(/\d/), Hh = Gh(/[\dA-Fa-f]/), Yh = Gh(/[!-/:-@[-`{-~]/); function Xh(e) { return null !== e && e < -2 } function Qh(e) { return null !== e && (e < 0 || 32 === e) } function qh(e) { return -2 === e || -1 === e || 32 === e } const Zh = Gh(/\p{P}|\p{S}/u), Kh = Gh(/\s/); function Gh(e) { return function (t) { return null !== t && t > -1 && e.test(String.fromCharCode(t)) } } function Jh(e, t, n, r) { const i = r ? r - 1 : Number.POSITIVE_INFINITY; let o = 0; return function (r) { if (qh(r)) return e.enter(n), a(r); return t(r) }; function a(r) { return qh(r) && o++ < i ? (e.consume(r), a) : (e.exit(n), t(r)) } } const _h = { tokenize: function (e) { const t = e.attempt(this.parser.constructs.contentInitial, (function (n) { if (null === n) return void e.consume(n); return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), Jh(e, t, "linePrefix") }), (function (t) { return e.enter("paragraph"), r(t) })); let n; return t; function r(t) { const r = e.enter("chunkText", { contentType: "text", previous: n }); return n && (n.next = r), n = r, i(t) } function i(t) { return null === t ? (e.exit("chunkText"), e.exit("paragraph"), void e.consume(t)) : Xh(t) ? (e.consume(t), e.exit("chunkText"), r) : (e.consume(t), i) } } }; const $h = { tokenize: function (e) { const t = this, n = []; let r, i, o, a = 0; return s; function s(r) { if (a < n.length) { const i = n[a]; return t.containerState = i[1], e.attempt(i[0].continuation, l, c)(r) } return c(r) } function l(e) { if (a++, t.containerState._closeFlow) { t.containerState._closeFlow = void 0, r && y(); const n = t.events.length; let i, o = n; for (; o--;)if ("exit" === t.events[o][0] && "chunkFlow" === t.events[o][1].type) { i = t.events[o][1].end; break } v(a); let s = n; for (; s < t.events.length;)t.events[s][1].end = { ...i }, s++; return jh(t.events, o + 1, 0, t.events.slice(n)), t.events.length = s, c(e) } return s(e) } function c(i) { if (a === n.length) { if (!r) return h(i); if (r.currentConstruct && r.currentConstruct.concrete) return p(i); t.interrupt = Boolean(r.currentConstruct && !r._gfmTableDynamicInterruptHack) } return t.containerState = {}, e.check(ef, u, d)(i) } function u(e) { return r && y(), v(a), h(e) } function d(e) { return t.parser.lazy[t.now().line] = a !== n.length, o = t.now().offset, p(e) } function h(n) { return t.containerState = {}, e.attempt(ef, f, p)(n) } function f(e) { return a++, n.push([t.currentConstruct, t.containerState]), h(e) } function p(n) { return null === n ? (r && y(), v(0), void e.consume(n)) : (r = r || t.parser.flow(t.now()), e.enter("chunkFlow", { _tokenizer: r, contentType: "flow", previous: i }), m(n)) } function m(n) { return null === n ? (g(e.exit("chunkFlow"), !0), v(0), void e.consume(n)) : Xh(n) ? (e.consume(n), g(e.exit("chunkFlow")), a = 0, t.interrupt = void 0, s) : (e.consume(n), m) } function g(e, n) { const s = t.sliceStream(e); if (n && s.push(null), e.previous = i, i && (i.next = e), i = e, r.defineSkip(e.start), r.write(s), t.parser.lazy[e.start.line]) { let e = r.events.length; for (; e--;)if (r.events[e][1].start.offset < o && (!r.events[e][1].end || r.events[e][1].end.offset > o)) return; const n = t.events.length; let i, s, l = n; for (; l--;)if ("exit" === t.events[l][0] && "chunkFlow" === t.events[l][1].type) { if (i) { s = t.events[l][1].end; break } i = !0 } for (v(a), e = n; e < t.events.length;)t.events[e][1].end = { ...s }, e++; jh(t.events, l + 1, 0, t.events.slice(n)), t.events.length = e } } function v(r) { let i = n.length; for (; i-- > r;) { const r = n[i]; t.containerState = r[1], r[0].exit.call(t, e) } n.length = r } function y() { r.write([null]), i = void 0, r = void 0, t.containerState._closeFlow = void 0 } } }, ef = { tokenize: function (e, t, n) { return Jh(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4) } }; const tf = { partial: !0, tokenize: function (e, t, n) { return function (t) { return qh(t) ? Jh(e, r, "linePrefix")(t) : r(t) }; function r(e) { return null === e || Xh(e) ? t(e) : n(e) } } }; const nf = { resolve: function (e) { return Ih(e), e }, tokenize: function (e, t) { let n; return function (t) { return e.enter("content"), n = e.enter("chunkContent", { contentType: "content" }), r(t) }; function r(t) { return null === t ? i(t) : Xh(t) ? e.check(rf, o, i)(t) : (e.consume(t), r) } function i(n) { return e.exit("chunkContent"), e.exit("content"), t(n) } function o(t) { return e.consume(t), e.exit("chunkContent"), n.next = e.enter("chunkContent", { contentType: "content", previous: n }), n = n.next, r } } }, rf = { partial: !0, tokenize: function (e, t, n) { const r = this; return function (t) { return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), Jh(e, i, "linePrefix") }; function i(i) { if (null === i || Xh(i)) return n(i); const o = r.events[r.events.length - 1]; return !r.parser.constructs.disable.null.includes("codeIndented") && o && "linePrefix" === o[1].type && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : e.interrupt(r.parser.constructs.flow, n, t)(i) } } }; const of = { tokenize: function (e) { const t = this, n = e.attempt(tf, (function (r) { if (null === r) return void e.consume(r); return e.enter("lineEndingBlank"), e.consume(r), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n }), e.attempt(this.parser.constructs.flowInitial, r, Jh(e, e.attempt(this.parser.constructs.flow, r, e.attempt(nf, r)), "linePrefix"))); return n; function r(r) { if (null !== r) return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), t.currentConstruct = void 0, n; e.consume(r) } } }; const af = { resolveAll: uf() }, sf = cf("string"), lf = cf("text"); function cf(e) { return { resolveAll: uf("text" === e ? df : void 0), tokenize: function (t) { const n = this, r = this.parser.constructs[e], i = t.attempt(r, o, a); return o; function o(e) { return l(e) ? i(e) : a(e) } function a(e) { if (null !== e) return t.enter("data"), t.consume(e), s; t.consume(e) } function s(e) { return l(e) ? (t.exit("data"), i(e)) : (t.consume(e), s) } function l(e) { if (null === e) return !0; const t = r[e]; let i = -1; if (t) for (; ++i < t.length;) { const e = t[i]; if (!e.previous || e.previous.call(n, n.previous)) return !0 } return !1 } } } } function uf(e) { return function (t, n) { let r, i = -1; for (; ++i <= t.length;)void 0 === r ? t[i] && "data" === t[i][1].type && (r = i, i++) : t[i] && "data" === t[i][1].type || (i !== r + 2 && (t[r][1].end = t[i - 1][1].end, t.splice(r + 2, i - r - 2), i = r + 2), r = void 0); return e ? e(t, n) : t } } function df(e, t) { let n = 0; for (; ++n <= e.length;)if ((n === e.length || "lineEnding" === e[n][1].type) && "data" === e[n - 1][1].type) { const r = e[n - 1][1], i = t.sliceStream(r); let o, a = i.length, s = -1, l = 0; for (; a--;) { const e = i[a]; if ("string" === typeof e) { for (s = e.length; 32 === e.charCodeAt(s - 1);)l++, s--; if (s) break; s = -1 } else if (-2 === e) o = !0, l++; else if (-1 !== e) { a++; break } } if (t._contentTypeTextTrailing && n === e.length && (l = 0), l) { const i = { type: n === e.length || o || l < 2 ? "lineSuffix" : "hardBreakTrailing", start: { _bufferIndex: a ? s : r.start._bufferIndex + s, _index: r.start._index + a, line: r.end.line, column: r.end.column - l, offset: r.end.offset - l }, end: { ...r.end } }; r.end = { ...i.start }, r.start.offset === r.end.offset ? Object.assign(r, i) : (e.splice(n, 0, ["enter", i, t], ["exit", i, t]), n += 2) } n++ } return e } const hf = { name: "thematicBreak", tokenize: function (e, t, n) { let r, i = 0; return function (t) { return e.enter("thematicBreak"), function (e) { return r = e, o(e) }(t) }; function o(o) { return o === r ? (e.enter("thematicBreakSequence"), a(o)) : i >= 3 && (null === o || Xh(o)) ? (e.exit("thematicBreak"), t(o)) : n(o) } function a(t) { return t === r ? (e.consume(t), i++, a) : (e.exit("thematicBreakSequence"), qh(t) ? Jh(e, o, "whitespace")(t) : o(t)) } } }; const ff = { continuation: { tokenize: function (e, t, n) { const r = this; return r.containerState._closeFlow = void 0, e.check(tf, i, o); function i(n) { return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Jh(e, t, "listItemIndent", r.containerState.size + 1)(n) } function o(n) { return r.containerState.furtherBlankLines || !qh(n) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, a(n)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(mf, t, a)(n)) } function a(i) { return r.containerState._closeFlow = !0, r.interrupt = void 0, Jh(e, e.attempt(ff, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(i) } } }, exit: function (e) { e.exit(this.containerState.type) }, name: "list", tokenize: function (e, t, n) { const r = this, i = r.events[r.events.length - 1]; let o = i && "linePrefix" === i[1].type ? i[2].sliceSerialize(i[1], !0).length : 0, a = 0; return function (t) { const i = r.containerState.type || (42 === t || 43 === t || 45 === t ? "listUnordered" : "listOrdered"); if ("listUnordered" === i ? !r.containerState.marker || t === r.containerState.marker : Wh(t)) { if (r.containerState.type || (r.containerState.type = i, e.enter(i, { _container: !0 })), "listUnordered" === i) return e.enter("listItemPrefix"), 42 === t || 45 === t ? e.check(hf, n, l)(t) : l(t); if (!r.interrupt || 49 === t) return e.enter("listItemPrefix"), e.enter("listItemValue"), s(t) } return n(t) }; function s(t) { return Wh(t) && ++a < 10 ? (e.consume(t), s) : (!r.interrupt || a < 2) && (r.containerState.marker ? t === r.containerState.marker : 41 === t || 46 === t) ? (e.exit("listItemValue"), l(t)) : n(t) } function l(t) { return e.enter("listItemMarker"), e.consume(t), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || t, e.check(tf, r.interrupt ? n : c, e.attempt(pf, d, u)) } function c(e) { return r.containerState.initialBlankLine = !0, o++, d(e) } function u(t) { return qh(t) ? (e.enter("listItemPrefixWhitespace"), e.consume(t), e.exit("listItemPrefixWhitespace"), d) : n(t) } function d(n) { return r.containerState.size = o + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(n) } } }, pf = { partial: !0, tokenize: function (e, t, n) { const r = this; return Jh(e, (function (e) { const i = r.events[r.events.length - 1]; return !qh(e) && i && "listItemPrefixWhitespace" === i[1].type ? t(e) : n(e) }), "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5) } }, mf = { partial: !0, tokenize: function (e, t, n) { const r = this; return Jh(e, (function (e) { const i = r.events[r.events.length - 1]; return i && "listItemIndent" === i[1].type && i[2].sliceSerialize(i[1], !0).length === r.containerState.size ? t(e) : n(e) }), "listItemIndent", r.containerState.size + 1) } }; const gf = { continuation: { tokenize: function (e, t, n) { const r = this; return function (t) { if (qh(t)) return Jh(e, i, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t); return i(t) }; function i(r) { return e.attempt(gf, t, n)(r) } } }, exit: function (e) { e.exit("blockQuote") }, name: "blockQuote", tokenize: function (e, t, n) { const r = this; return function (t) { if (62 === t) { const n = r.containerState; return n.open || (e.enter("blockQuote", { _container: !0 }), n.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(t), e.exit("blockQuoteMarker"), i } return n(t) }; function i(n) { return qh(n) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(n), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(n)) } } }; function vf(e, t, n, r, i, o, a, s, l) { const c = l || Number.POSITIVE_INFINITY; let u = 0; return function (t) { if (60 === t) return e.enter(r), e.enter(i), e.enter(o), e.consume(t), e.exit(o), d; if (null === t || 32 === t || 41 === t || Uh(t)) return n(t); return e.enter(r), e.enter(a), e.enter(s), e.enter("chunkString", { contentType: "string" }), p(t) }; function d(n) { return 62 === n ? (e.enter(o), e.consume(n), e.exit(o), e.exit(i), e.exit(r), t) : (e.enter(s), e.enter("chunkString", { contentType: "string" }), h(n)) } function h(t) { return 62 === t ? (e.exit("chunkString"), e.exit(s), d(t)) : null === t || 60 === t || Xh(t) ? n(t) : (e.consume(t), 92 === t ? f : h) } function f(t) { return 60 === t || 62 === t || 92 === t ? (e.consume(t), h) : h(t) } function p(i) { return u || null !== i && 41 !== i && !Qh(i) ? u < c && 40 === i ? (e.consume(i), u++, p) : 41 === i ? (e.consume(i), u--, p) : null === i || 32 === i || 40 === i || Uh(i) ? n(i) : (e.consume(i), 92 === i ? m : p) : (e.exit("chunkString"), e.exit(s), e.exit(a), e.exit(r), t(i)) } function m(t) { return 40 === t || 41 === t || 92 === t ? (e.consume(t), p) : p(t) } } function yf(e, t, n, r, i, o) { const a = this; let s, l = 0; return function (t) { return e.enter(r), e.enter(i), e.consume(t), e.exit(i), e.enter(o), c }; function c(d) { return l > 999 || null === d || 91 === d || 93 === d && !s || 94 === d && !l && "_hiddenFootnoteSupport" in a.parser.constructs ? n(d) : 93 === d ? (e.exit(o), e.enter(i), e.consume(d), e.exit(i), e.exit(r), t) : Xh(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), c) : (e.enter("chunkString", { contentType: "string" }), u(d)) } function u(t) { return null === t || 91 === t || 93 === t || Xh(t) || l++ > 999 ? (e.exit("chunkString"), c(t)) : (e.consume(t), s || (s = !qh(t)), 92 === t ? d : u) } function d(t) { return 91 === t || 92 === t || 93 === t ? (e.consume(t), l++, u) : u(t) } } function bf(e, t, n, r, i, o) { let a; return function (t) { if (34 === t || 39 === t || 40 === t) return e.enter(r), e.enter(i), e.consume(t), e.exit(i), a = 40 === t ? 41 : t, s; return n(t) }; function s(n) { return n === a ? (e.enter(i), e.consume(n), e.exit(i), e.exit(r), t) : (e.enter(o), l(n)) } function l(t) { return t === a ? (e.exit(o), s(a)) : null === t ? n(t) : Xh(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), Jh(e, l, "linePrefix")) : (e.enter("chunkString", { contentType: "string" }), c(t)) } function c(t) { return t === a || null === t || Xh(t) ? (e.exit("chunkString"), l(t)) : (e.consume(t), 92 === t ? u : c) } function u(t) { return t === a || 92 === t ? (e.consume(t), c) : c(t) } } function xf(e, t) { let n; return function r(i) { if (Xh(i)) return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r; if (qh(i)) return Jh(e, r, n ? "linePrefix" : "lineSuffix")(i); return t(i) } } function wf(e) { return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase() } const kf = { name: "definition", tokenize: function (e, t, n) { const r = this; let i; return function (t) { return e.enter("definition"), function (t) { return yf.call(r, e, o, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(t) }(t) }; function o(t) { return i = wf(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), 58 === t ? (e.enter("definitionMarker"), e.consume(t), e.exit("definitionMarker"), a) : n(t) } function a(t) { return Qh(t) ? xf(e, s)(t) : s(t) } function s(t) { return vf(e, l, n, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(t) } function l(t) { return e.attempt(Sf, c, c)(t) } function c(t) { return qh(t) ? Jh(e, u, "whitespace")(t) : u(t) } function u(o) { return null === o || Xh(o) ? (e.exit("definition"), r.parser.defined.push(i), t(o)) : n(o) } } }, Sf = { partial: !0, tokenize: function (e, t, n) { return function (t) { return Qh(t) ? xf(e, r)(t) : n(t) }; function r(t) { return bf(e, i, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(t) } function i(t) { return qh(t) ? Jh(e, o, "whitespace")(t) : o(t) } function o(e) { return null === e || Xh(e) ? t(e) : n(e) } } }; const Af = { name: "codeIndented", tokenize: function (e, t, n) { const r = this; return function (t) { return e.enter("codeIndented"), Jh(e, i, "linePrefix", 5)(t) }; function i(e) { const t = r.events[r.events.length - 1]; return t && "linePrefix" === t[1].type && t[2].sliceSerialize(t[1], !0).length >= 4 ? o(e) : n(e) } function o(t) { return null === t ? s(t) : Xh(t) ? e.attempt(Ef, o, s)(t) : (e.enter("codeFlowValue"), a(t)) } function a(t) { return null === t || Xh(t) ? (e.exit("codeFlowValue"), o(t)) : (e.consume(t), a) } function s(n) { return e.exit("codeIndented"), t(n) } } }, Ef = { partial: !0, tokenize: function (e, t, n) { const r = this; return i; function i(t) { return r.parser.lazy[r.now().line] ? n(t) : Xh(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), i) : Jh(e, o, "linePrefix", 5)(t) } function o(e) { const o = r.events[r.events.length - 1]; return o && "linePrefix" === o[1].type && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(e) : Xh(e) ? i(e) : n(e) } } }; const Cf = { name: "headingAtx", resolve: function (e, t) { let n, r, i = e.length - 2, o = 3; "whitespace" === e[o][1].type && (o += 2); i - 2 > o && "whitespace" === e[i][1].type && (i -= 2); "atxHeadingSequence" === e[i][1].type && (o === i - 1 || i - 4 > o && "whitespace" === e[i - 2][1].type) && (i -= o + 1 === i ? 2 : 4); i > o && (n = { type: "atxHeadingText", start: e[o][1].start, end: e[i][1].end }, r = { type: "chunkText", start: e[o][1].start, end: e[i][1].end, contentType: "text" }, jh(e, o, i - o + 1, [["enter", n, t], ["enter", r, t], ["exit", r, t], ["exit", n, t]])); return e }, tokenize: function (e, t, n) { let r = 0; return function (t) { return e.enter("atxHeading"), function (t) { return e.enter("atxHeadingSequence"), i(t) }(t) }; function i(t) { return 35 === t && r++ < 6 ? (e.consume(t), i) : null === t || Qh(t) ? (e.exit("atxHeadingSequence"), o(t)) : n(t) } function o(n) { return 35 === n ? (e.enter("atxHeadingSequence"), a(n)) : null === n || Xh(n) ? (e.exit("atxHeading"), t(n)) : qh(n) ? Jh(e, o, "whitespace")(n) : (e.enter("atxHeadingText"), s(n)) } function a(t) { return 35 === t ? (e.consume(t), a) : (e.exit("atxHeadingSequence"), o(t)) } function s(t) { return null === t || 35 === t || Qh(t) ? (e.exit("atxHeadingText"), o(t)) : (e.consume(t), s) } } }; const Pf = { name: "setextUnderline", resolveTo: function (e, t) { let n, r, i, o = e.length; for (; o--;)if ("enter" === e[o][0]) { if ("content" === e[o][1].type) { n = o; break } "paragraph" === e[o][1].type && (r = o) } else "content" === e[o][1].type && e.splice(o, 1), i || "definition" !== e[o][1].type || (i = o); const a = { type: "setextHeading", start: { ...e[n][1].start }, end: { ...e[e.length - 1][1].end } }; e[r][1].type = "setextHeadingText", i ? (e.splice(r, 0, ["enter", a, t]), e.splice(i + 1, 0, ["exit", e[n][1], t]), e[n][1].end = { ...e[i][1].end }) : e[n][1] = a; return e.push(["exit", a, t]), e }, tokenize: function (e, t, n) { const r = this; let i; return function (t) { let a, s = r.events.length; for (; s--;)if ("lineEnding" !== r.events[s][1].type && "linePrefix" !== r.events[s][1].type && "content" !== r.events[s][1].type) { a = "paragraph" === r.events[s][1].type; break } if (!r.parser.lazy[r.now().line] && (r.interrupt || a)) return e.enter("setextHeadingLine"), i = t, function (t) { return e.enter("setextHeadingLineSequence"), o(t) }(t); return n(t) }; function o(t) { return t === i ? (e.consume(t), o) : (e.exit("setextHeadingLineSequence"), qh(t) ? Jh(e, a, "lineSuffix")(t) : a(t)) } function a(r) { return null === r || Xh(r) ? (e.exit("setextHeadingLine"), t(r)) : n(r) } } }; const jf = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], Nf = ["pre", "script", "style", "textarea"], Mf = { concrete: !0, name: "htmlFlow", resolveTo: function (e) { let t = e.length; for (; t-- && ("enter" !== e[t][0] || "htmlFlow" !== e[t][1].type);); t > 1 && "linePrefix" === e[t - 2][1].type && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)); return e }, tokenize: function (e, t, n) { const r = this; let i, o, a, s, l; return function (t) { return function (t) { return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(t), c }(t) }; function c(s) { return 33 === s ? (e.consume(s), u) : 47 === s ? (e.consume(s), o = !0, f) : 63 === s ? (e.consume(s), i = 3, r.interrupt ? t : R) : Bh(s) ? (e.consume(s), a = String.fromCharCode(s), p) : n(s) } function u(o) { return 45 === o ? (e.consume(o), i = 2, d) : 91 === o ? (e.consume(o), i = 5, s = 0, h) : Bh(o) ? (e.consume(o), i = 4, r.interrupt ? t : R) : n(o) } function d(i) { return 45 === i ? (e.consume(i), r.interrupt ? t : R) : n(i) } function h(i) { const o = "CDATA["; return i === o.charCodeAt(s++) ? (e.consume(i), 6 === s ? r.interrupt ? t : C : h) : n(i) } function f(t) { return Bh(t) ? (e.consume(t), a = String.fromCharCode(t), p) : n(t) } function p(s) { if (null === s || 47 === s || 62 === s || Qh(s)) { const l = 47 === s, c = a.toLowerCase(); return l || o || !Nf.includes(c) ? jf.includes(a.toLowerCase()) ? (i = 6, l ? (e.consume(s), m) : r.interrupt ? t(s) : C(s)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(s) : o ? g(s) : v(s)) : (i = 1, r.interrupt ? t(s) : C(s)) } return 45 === s || Fh(s) ? (e.consume(s), a += String.fromCharCode(s), p) : n(s) } function m(i) { return 62 === i ? (e.consume(i), r.interrupt ? t : C) : n(i) } function g(t) { return qh(t) ? (e.consume(t), g) : A(t) } function v(t) { return 47 === t ? (e.consume(t), A) : 58 === t || 95 === t || Bh(t) ? (e.consume(t), y) : qh(t) ? (e.consume(t), v) : A(t) } function y(t) { return 45 === t || 46 === t || 58 === t || 95 === t || Fh(t) ? (e.consume(t), y) : b(t) } function b(t) { return 61 === t ? (e.consume(t), x) : qh(t) ? (e.consume(t), b) : v(t) } function x(t) { return null === t || 60 === t || 61 === t || 62 === t || 96 === t ? n(t) : 34 === t || 39 === t ? (e.consume(t), l = t, w) : qh(t) ? (e.consume(t), x) : k(t) } function w(t) { return t === l ? (e.consume(t), l = null, S) : null === t || Xh(t) ? n(t) : (e.consume(t), w) } function k(t) { return null === t || 34 === t || 39 === t || 47 === t || 60 === t || 61 === t || 62 === t || 96 === t || Qh(t) ? b(t) : (e.consume(t), k) } function S(e) { return 47 === e || 62 === e || qh(e) ? v(e) : n(e) } function A(t) { return 62 === t ? (e.consume(t), E) : n(t) } function E(t) { return null === t || Xh(t) ? C(t) : qh(t) ? (e.consume(t), E) : n(t) } function C(t) { return 45 === t && 2 === i ? (e.consume(t), M) : 60 === t && 1 === i ? (e.consume(t), T) : 62 === t && 4 === i ? (e.consume(t), D) : 63 === t && 3 === i ? (e.consume(t), R) : 93 === t && 5 === i ? (e.consume(t), L) : !Xh(t) || 6 !== i && 7 !== i ? null === t || Xh(t) ? (e.exit("htmlFlowData"), P(t)) : (e.consume(t), C) : (e.exit("htmlFlowData"), e.check(Tf, z, P)(t)) } function P(t) { return e.check(If, j, z)(t) } function j(t) { return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), N } function N(t) { return null === t || Xh(t) ? P(t) : (e.enter("htmlFlowData"), C(t)) } function M(t) { return 45 === t ? (e.consume(t), R) : C(t) } function T(t) { return 47 === t ? (e.consume(t), a = "", I) : C(t) } function I(t) { if (62 === t) { const n = a.toLowerCase(); return Nf.includes(n) ? (e.consume(t), D) : C(t) } return Bh(t) && a.length < 8 ? (e.consume(t), a += String.fromCharCode(t), I) : C(t) } function L(t) { return 93 === t ? (e.consume(t), R) : C(t) } function R(t) { return 62 === t ? (e.consume(t), D) : 45 === t && 2 === i ? (e.consume(t), R) : C(t) } function D(t) { return null === t || Xh(t) ? (e.exit("htmlFlowData"), z(t)) : (e.consume(t), D) } function z(n) { return e.exit("htmlFlow"), t(n) } } }, Tf = { partial: !0, tokenize: function (e, t, n) { return function (r) { return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), e.attempt(tf, t, n) } } }, If = { partial: !0, tokenize: function (e, t, n) { const r = this; return function (t) { if (Xh(t)) return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), i; return n(t) }; function i(e) { return r.parser.lazy[r.now().line] ? n(e) : t(e) } } }; const Lf = { partial: !0, tokenize: function (e, t, n) { const r = this; return function (t) { if (null === t) return n(t); return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), i }; function i(e) { return r.parser.lazy[r.now().line] ? n(e) : t(e) } } }, Rf = { concrete: !0, name: "codeFenced", tokenize: function (e, t, n) { const r = this, i = { partial: !0, tokenize: function (e, t, n) { let i = 0; return a; function a(t) { return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), l } function l(t) { return e.enter("codeFencedFence"), qh(t) ? Jh(e, c, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : c(t) } function c(t) { return t === o ? (e.enter("codeFencedFenceSequence"), u(t)) : n(t) } function u(t) { return t === o ? (i++, e.consume(t), u) : i >= s ? (e.exit("codeFencedFenceSequence"), qh(t) ? Jh(e, d, "whitespace")(t) : d(t)) : n(t) } function d(r) { return null === r || Xh(r) ? (e.exit("codeFencedFence"), t(r)) : n(r) } } }; let o, a = 0, s = 0; return function (t) { return function (t) { const n = r.events[r.events.length - 1]; return a = n && "linePrefix" === n[1].type ? n[2].sliceSerialize(n[1], !0).length : 0, o = t, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), l(t) }(t) }; function l(t) { return t === o ? (s++, e.consume(t), l) : s < 3 ? n(t) : (e.exit("codeFencedFenceSequence"), qh(t) ? Jh(e, c, "whitespace")(t) : c(t)) } function c(n) { return null === n || Xh(n) ? (e.exit("codeFencedFence"), r.interrupt ? t(n) : e.check(Lf, f, y)(n)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", { contentType: "string" }), u(n)) } function u(t) { return null === t || Xh(t) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), c(t)) : qh(t) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Jh(e, d, "whitespace")(t)) : 96 === t && t === o ? n(t) : (e.consume(t), u) } function d(t) { return null === t || Xh(t) ? c(t) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", { contentType: "string" }), h(t)) } function h(t) { return null === t || Xh(t) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), c(t)) : 96 === t && t === o ? n(t) : (e.consume(t), h) } function f(t) { return e.attempt(i, y, p)(t) } function p(t) { return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), m } function m(t) { return a > 0 && qh(t) ? Jh(e, g, "linePrefix", a + 1)(t) : g(t) } function g(t) { return null === t || Xh(t) ? e.check(Lf, f, y)(t) : (e.enter("codeFlowValue"), v(t)) } function v(t) { return null === t || Xh(t) ? (e.exit("codeFlowValue"), g(t)) : (e.consume(t), v) } function y(n) { return e.exit("codeFenced"), t(n) } } }; const Df = document.createElement("i"); function zf(e) { const t = "&" + e + ";"; Df.innerHTML = t; const n = Df.textContent; return (59 !== n.charCodeAt(n.length - 1) || "semi" === e) && (n !== t && n) } const Of = { name: "characterReference", tokenize: function (e, t, n) { const r = this; let i, o, a = 0; return function (t) { return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(t), e.exit("characterReferenceMarker"), s }; function s(t) { return 35 === t ? (e.enter("characterReferenceMarkerNumeric"), e.consume(t), e.exit("characterReferenceMarkerNumeric"), l) : (e.enter("characterReferenceValue"), i = 31, o = Fh, c(t)) } function l(t) { return 88 === t || 120 === t ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(t), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), i = 6, o = Hh, c) : (e.enter("characterReferenceValue"), i = 7, o = Wh, c(t)) } function c(s) { if (59 === s && a) { const i = e.exit("characterReferenceValue"); return o !== Fh || zf(r.sliceSerialize(i)) ? (e.enter("characterReferenceMarker"), e.consume(s), e.exit("characterReferenceMarker"), e.exit("characterReference"), t) : n(s) } return o(s) && a++ < i ? (e.consume(s), c) : n(s) } } }; const Bf = { name: "characterEscape", tokenize: function (e, t, n) { return function (t) { return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(t), e.exit("escapeMarker"), r }; function r(r) { return Yh(r) ? (e.enter("characterEscapeValue"), e.consume(r), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(r) } } }; const Ff = { name: "lineEnding", tokenize: function (e, t) { return function (n) { return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), Jh(e, t, "linePrefix") } } }; function Vf(e, t, n) { const r = []; let i = -1; for (; ++i < e.length;) { const o = e[i].resolveAll; o && !r.includes(o) && (t = o(t, n), r.push(o)) } return t } const Uf = { name: "labelEnd", resolveAll: function (e) { let t = -1; const n = []; for (; ++t < e.length;) { const r = e[t][1]; if (n.push(e[t]), "labelImage" === r.type || "labelLink" === r.type || "labelEnd" === r.type) { const e = "labelImage" === r.type ? 4 : 2; r.type = "data", t += e } } e.length !== n.length && jh(e, 0, e.length, n); return e }, resolveTo: function (e, t) { let n, r, i, o, a = e.length, s = 0; for (; a--;)if (n = e[a][1], r) { if ("link" === n.type || "labelLink" === n.type && n._inactive) break; "enter" === e[a][0] && "labelLink" === n.type && (n._inactive = !0) } else if (i) { if ("enter" === e[a][0] && ("labelImage" === n.type || "labelLink" === n.type) && !n._balanced && (r = a, "labelLink" !== n.type)) { s = 2; break } } else "labelEnd" === n.type && (i = a); const l = { type: "labelLink" === e[r][1].type ? "link" : "image", start: { ...e[r][1].start }, end: { ...e[e.length - 1][1].end } }, c = { type: "label", start: { ...e[r][1].start }, end: { ...e[i][1].end } }, u = { type: "labelText", start: { ...e[r + s + 2][1].end }, end: { ...e[i - 2][1].start } }; return o = [["enter", l, t], ["enter", c, t]], o = Nh(o, e.slice(r + 1, r + s + 3)), o = Nh(o, [["enter", u, t]]), o = Nh(o, Vf(t.parser.constructs.insideSpan.null, e.slice(r + s + 4, i - 3), t)), o = Nh(o, [["exit", u, t], e[i - 2], e[i - 1], ["exit", c, t]]), o = Nh(o, e.slice(i + 1)), o = Nh(o, [["exit", l, t]]), jh(e, r, e.length, o), e }, tokenize: function (e, t, n) { const r = this; let i, o, a = r.events.length; for (; a--;)if (("labelImage" === r.events[a][1].type || "labelLink" === r.events[a][1].type) && !r.events[a][1]._balanced) { i = r.events[a][1]; break } return function (t) { if (!i) return n(t); if (i._inactive) return u(t); return o = r.parser.defined.includes(wf(r.sliceSerialize({ start: i.end, end: r.now() }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelEnd"), s }; function s(t) { return 40 === t ? e.attempt(Wf, c, o ? c : u)(t) : 91 === t ? e.attempt(Hf, c, o ? l : u)(t) : o ? c(t) : u(t) } function l(t) { return e.attempt(Yf, c, u)(t) } function c(e) { return t(e) } function u(e) { return i._balanced = !0, n(e) } } }, Wf = { tokenize: function (e, t, n) { return function (t) { return e.enter("resource"), e.enter("resourceMarker"), e.consume(t), e.exit("resourceMarker"), r }; function r(t) { return Qh(t) ? xf(e, i)(t) : i(t) } function i(t) { return 41 === t ? c(t) : vf(e, o, a, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(t) } function o(t) { return Qh(t) ? xf(e, s)(t) : c(t) } function a(e) { return n(e) } function s(t) { return 34 === t || 39 === t || 40 === t ? bf(e, l, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(t) : c(t) } function l(t) { return Qh(t) ? xf(e, c)(t) : c(t) } function c(r) { return 41 === r ? (e.enter("resourceMarker"), e.consume(r), e.exit("resourceMarker"), e.exit("resource"), t) : n(r) } } }, Hf = { tokenize: function (e, t, n) { const r = this; return function (t) { return yf.call(r, e, i, o, "reference", "referenceMarker", "referenceString")(t) }; function i(e) { return r.parser.defined.includes(wf(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(e) : n(e) } function o(e) { return n(e) } } }, Yf = { tokenize: function (e, t, n) { return function (t) { return e.enter("reference"), e.enter("referenceMarker"), e.consume(t), e.exit("referenceMarker"), r }; function r(r) { return 93 === r ? (e.enter("referenceMarker"), e.consume(r), e.exit("referenceMarker"), e.exit("reference"), t) : n(r) } } }; const Xf = { name: "labelStartImage", resolveAll: Uf.resolveAll, tokenize: function (e, t, n) { const r = this; return function (t) { return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(t), e.exit("labelImageMarker"), i }; function i(t) { return 91 === t ? (e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelImage"), o) : n(t) } function o(e) { return 94 === e && "_hiddenFootnoteSupport" in r.parser.constructs ? n(e) : t(e) } } }; function Qf(e) { return null === e || Qh(e) || Kh(e) ? 1 : Zh(e) ? 2 : void 0 } const qf = { name: "attention", resolveAll: function (e, t) { let n, r, i, o, a, s, l, c, u = -1; for (; ++u < e.length;)if ("enter" === e[u][0] && "attentionSequence" === e[u][1].type && e[u][1]._close) for (n = u; n--;)if ("exit" === e[n][0] && "attentionSequence" === e[n][1].type && e[n][1]._open && t.sliceSerialize(e[n][1]).charCodeAt(0) === t.sliceSerialize(e[u][1]).charCodeAt(0)) { if ((e[n][1]._close || e[u][1]._open) && (e[u][1].end.offset - e[u][1].start.offset) % 3 && !((e[n][1].end.offset - e[n][1].start.offset + e[u][1].end.offset - e[u][1].start.offset) % 3)) continue; s = e[n][1].end.offset - e[n][1].start.offset > 1 && e[u][1].end.offset - e[u][1].start.offset > 1 ? 2 : 1; const d = { ...e[n][1].end }, h = { ...e[u][1].start }; Zf(d, -s), Zf(h, s), o = { type: s > 1 ? "strongSequence" : "emphasisSequence", start: d, end: { ...e[n][1].end } }, a = { type: s > 1 ? "strongSequence" : "emphasisSequence", start: { ...e[u][1].start }, end: h }, i = { type: s > 1 ? "strongText" : "emphasisText", start: { ...e[n][1].end }, end: { ...e[u][1].start } }, r = { type: s > 1 ? "strong" : "emphasis", start: { ...o.start }, end: { ...a.end } }, e[n][1].end = { ...o.start }, e[u][1].start = { ...a.end }, l = [], e[n][1].end.offset - e[n][1].start.offset && (l = Nh(l, [["enter", e[n][1], t], ["exit", e[n][1], t]])), l = Nh(l, [["enter", r, t], ["enter", o, t], ["exit", o, t], ["enter", i, t]]), l = Nh(l, Vf(t.parser.constructs.insideSpan.null, e.slice(n + 1, u), t)), l = Nh(l, [["exit", i, t], ["enter", a, t], ["exit", a, t], ["exit", r, t]]), e[u][1].end.offset - e[u][1].start.offset ? (c = 2, l = Nh(l, [["enter", e[u][1], t], ["exit", e[u][1], t]])) : c = 0, jh(e, n - 1, u - n + 3, l), u = n + l.length - c - 2; break } u = -1; for (; ++u < e.length;)"attentionSequence" === e[u][1].type && (e[u][1].type = "data"); return e }, tokenize: function (e, t) { const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = Qf(r); let o; return function (t) { return o = t, e.enter("attentionSequence"), a(t) }; function a(s) { if (s === o) return e.consume(s), a; const l = e.exit("attentionSequence"), c = Qf(s), u = !c || 2 === c && i || n.includes(s), d = !i || 2 === i && c || n.includes(r); return l._open = Boolean(42 === o ? u : u && (i || !d)), l._close = Boolean(42 === o ? d : d && (c || !u)), t(s) } } }; function Zf(e, t) { e.column += t, e.offset += t, e._bufferIndex += t } const Kf = { name: "autolink", tokenize: function (e, t, n) { let r = 0; return function (t) { return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(t), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), i }; function i(t) { return Bh(t) ? (e.consume(t), o) : 64 === t ? n(t) : l(t) } function o(e) { return 43 === e || 45 === e || 46 === e || Fh(e) ? (r = 1, a(e)) : l(e) } function a(t) { return 58 === t ? (e.consume(t), r = 0, s) : (43 === t || 45 === t || 46 === t || Fh(t)) && r++ < 32 ? (e.consume(t), a) : (r = 0, l(t)) } function s(r) { return 62 === r ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(r), e.exit("autolinkMarker"), e.exit("autolink"), t) : null === r || 32 === r || 60 === r || Uh(r) ? n(r) : (e.consume(r), s) } function l(t) { return 64 === t ? (e.consume(t), c) : Vh(t) ? (e.consume(t), l) : n(t) } function c(e) { return Fh(e) ? u(e) : n(e) } function u(n) { return 46 === n ? (e.consume(n), r = 0, c) : 62 === n ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(n), e.exit("autolinkMarker"), e.exit("autolink"), t) : d(n) } function d(t) { if ((45 === t || Fh(t)) && r++ < 63) { const n = 45 === t ? d : u; return e.consume(t), n } return n(t) } } }; const Gf = { name: "htmlText", tokenize: function (e, t, n) { const r = this; let i, o, a; return function (t) { return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(t), s }; function s(t) { return 33 === t ? (e.consume(t), l) : 47 === t ? (e.consume(t), x) : 63 === t ? (e.consume(t), y) : Bh(t) ? (e.consume(t), S) : n(t) } function l(t) { return 45 === t ? (e.consume(t), c) : 91 === t ? (e.consume(t), o = 0, f) : Bh(t) ? (e.consume(t), v) : n(t) } function c(t) { return 45 === t ? (e.consume(t), h) : n(t) } function u(t) { return null === t ? n(t) : 45 === t ? (e.consume(t), d) : Xh(t) ? (a = u, I(t)) : (e.consume(t), u) } function d(t) { return 45 === t ? (e.consume(t), h) : u(t) } function h(e) { return 62 === e ? T(e) : 45 === e ? d(e) : u(e) } function f(t) { const r = "CDATA["; return t === r.charCodeAt(o++) ? (e.consume(t), 6 === o ? p : f) : n(t) } function p(t) { return null === t ? n(t) : 93 === t ? (e.consume(t), m) : Xh(t) ? (a = p, I(t)) : (e.consume(t), p) } function m(t) { return 93 === t ? (e.consume(t), g) : p(t) } function g(t) { return 62 === t ? T(t) : 93 === t ? (e.consume(t), g) : p(t) } function v(t) { return null === t || 62 === t ? T(t) : Xh(t) ? (a = v, I(t)) : (e.consume(t), v) } function y(t) { return null === t ? n(t) : 63 === t ? (e.consume(t), b) : Xh(t) ? (a = y, I(t)) : (e.consume(t), y) } function b(e) { return 62 === e ? T(e) : y(e) } function x(t) { return Bh(t) ? (e.consume(t), w) : n(t) } function w(t) { return 45 === t || Fh(t) ? (e.consume(t), w) : k(t) } function k(t) { return Xh(t) ? (a = k, I(t)) : qh(t) ? (e.consume(t), k) : T(t) } function S(t) { return 45 === t || Fh(t) ? (e.consume(t), S) : 47 === t || 62 === t || Qh(t) ? A(t) : n(t) } function A(t) { return 47 === t ? (e.consume(t), T) : 58 === t || 95 === t || Bh(t) ? (e.consume(t), E) : Xh(t) ? (a = A, I(t)) : qh(t) ? (e.consume(t), A) : T(t) } function E(t) { return 45 === t || 46 === t || 58 === t || 95 === t || Fh(t) ? (e.consume(t), E) : C(t) } function C(t) { return 61 === t ? (e.consume(t), P) : Xh(t) ? (a = C, I(t)) : qh(t) ? (e.consume(t), C) : A(t) } function P(t) { return null === t || 60 === t || 61 === t || 62 === t || 96 === t ? n(t) : 34 === t || 39 === t ? (e.consume(t), i = t, j) : Xh(t) ? (a = P, I(t)) : qh(t) ? (e.consume(t), P) : (e.consume(t), N) } function j(t) { return t === i ? (e.consume(t), i = void 0, M) : null === t ? n(t) : Xh(t) ? (a = j, I(t)) : (e.consume(t), j) } function N(t) { return null === t || 34 === t || 39 === t || 60 === t || 61 === t || 96 === t ? n(t) : 47 === t || 62 === t || Qh(t) ? A(t) : (e.consume(t), N) } function M(e) { return 47 === e || 62 === e || Qh(e) ? A(e) : n(e) } function T(r) { return 62 === r ? (e.consume(r), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(r) } function I(t) { return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), L } function L(t) { return qh(t) ? Jh(e, R, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : R(t) } function R(t) { return e.enter("htmlTextData"), a(t) } } }; const Jf = { name: "labelStartLink", resolveAll: Uf.resolveAll, tokenize: function (e, t, n) { const r = this; return function (t) { return e.enter("labelLink"), e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelLink"), i }; function i(e) { return 94 === e && "_hiddenFootnoteSupport" in r.parser.constructs ? n(e) : t(e) } } }; const _f = { name: "hardBreakEscape", tokenize: function (e, t, n) { return function (t) { return e.enter("hardBreakEscape"), e.consume(t), r }; function r(r) { return Xh(r) ? (e.exit("hardBreakEscape"), t(r)) : n(r) } } }; const $f = { name: "codeText", previous: function (e) { return 96 !== e || "characterEscape" === this.events[this.events.length - 1][1].type }, resolve: function (e) { let t, n, r = e.length - 4, i = 3; if (("lineEnding" === e[i][1].type || "space" === e[i][1].type) && ("lineEnding" === e[r][1].type || "space" === e[r][1].type)) for (t = i; ++t < r;)if ("codeTextData" === e[t][1].type) { e[i][1].type = "codeTextPadding", e[r][1].type = "codeTextPadding", i += 2, r -= 2; break } t = i - 1, r++; for (; ++t <= r;)void 0 === n ? t !== r && "lineEnding" !== e[t][1].type && (n = t) : t !== r && "lineEnding" !== e[t][1].type || (e[n][1].type = "codeTextData", t !== n + 2 && (e[n][1].end = e[t - 1][1].end, e.splice(n + 2, t - n - 2), r -= t - n - 2, t = n + 2), n = void 0); return e }, tokenize: function (e, t, n) { let r, i, o = 0; return function (t) { return e.enter("codeText"), e.enter("codeTextSequence"), a(t) }; function a(t) { return 96 === t ? (e.consume(t), o++, a) : (e.exit("codeTextSequence"), s(t)) } function s(t) { return null === t ? n(t) : 32 === t ? (e.enter("space"), e.consume(t), e.exit("space"), s) : 96 === t ? (i = e.enter("codeTextSequence"), r = 0, c(t)) : Xh(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), s) : (e.enter("codeTextData"), l(t)) } function l(t) { return null === t || 32 === t || 96 === t || Xh(t) ? (e.exit("codeTextData"), s(t)) : (e.consume(t), l) } function c(n) { return 96 === n ? (e.consume(n), r++, c) : r === o ? (e.exit("codeTextSequence"), e.exit("codeText"), t(n)) : (i.type = "codeTextData", l(n)) } } }; const ep = { 42: ff, 43: ff, 45: ff, 48: ff, 49: ff, 50: ff, 51: ff, 52: ff, 53: ff, 54: ff, 55: ff, 56: ff, 57: ff, 62: gf }, tp = { 91: kf }, np = { [-2]: Af, [-1]: Af, 32: Af }, rp = { 35: Cf, 42: hf, 45: [Pf, hf], 60: Mf, 61: Pf, 95: hf, 96: Rf, 126: Rf }, ip = { 38: Of, 92: Bf }, op = { [-5]: Ff, [-4]: Ff, [-3]: Ff, 33: Xf, 38: Of, 42: qf, 60: [Kf, Gf], 91: Jf, 92: [_f, Bf], 93: Uf, 95: qf, 96: $f }, ap = { null: [qf, af] }, sp = { null: [42, 95] }, lp = { null: [] }; function cp(e, t, n) { let r = { _bufferIndex: -1, _index: 0, line: n && n.line || 1, column: n && n.column || 1, offset: n && n.offset || 0 }; const i = {}, o = []; let a = [], s = [], l = !0; const c = { attempt: y((function (e, t) { b(e, t.from) })), check: y(v), consume: function (e) { Xh(e) ? (r.line++, r.column = 1, r.offset += -3 === e ? 2 : 1, x()) : -1 !== e && (r.column++, r.offset++); r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === a[r._index].length && (r._bufferIndex = -1, r._index++)); u.previous = e, l = !0 }, enter: function (e, t) { const n = t || {}; return n.type = e, n.start = p(), u.events.push(["enter", n, u]), s.push(n), n }, exit: function (e) { const t = s.pop(); return t.end = p(), u.events.push(["exit", t, u]), t }, interrupt: y(v, { interrupt: !0 }) }, u = { code: null, containerState: {}, defineSkip: function (e) { i[e.line] = e.column, x() }, events: [], now: p, parser: e, previous: null, sliceSerialize: function (e, t) { return function (e, t) { let n = -1; const r = []; let i; for (; ++n < e.length;) { const o = e[n]; let a; if ("string" === typeof o) a = o; else switch (o) { case -5: a = "\r"; break; case -4: a = "\n"; break; case -3: a = "\r\n"; break; case -2: a = t ? " " : "\t"; break; case -1: if (!t && i) continue; a = " "; break; default: a = String.fromCharCode(o) }i = -2 === o, r.push(a) } return r.join("") }(f(e), t) }, sliceStream: f, write: function (e) { if (a = Nh(a, e), m(), null !== a[a.length - 1]) return []; return b(t, 0), u.events = Vf(o, u.events, u), u.events } }; let d, h = t.tokenize.call(u, c); return t.resolveAll && o.push(t), u; function f(e) { return function (e, t) { const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, o = t.end._bufferIndex; let a; if (n === i) a = [e[n].slice(r, o)]; else { if (a = e.slice(n, i), r > -1) { const e = a[0]; "string" === typeof e ? a[0] = e.slice(r) : a.shift() } o > 0 && a.push(e[i].slice(0, o)) } return a }(a, e) } function p() { const { _bufferIndex: e, _index: t, line: n, column: i, offset: o } = r; return { _bufferIndex: e, _index: t, line: n, column: i, offset: o } } function m() { let e; for (; r._index < a.length;) { const t = a[r._index]; if ("string" === typeof t) for (e = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === e && r._bufferIndex < t.length;)g(t.charCodeAt(r._bufferIndex)); else g(t) } } function g(e) { l = void 0, d = e, h = h(e) } function v(e, t) { t.restore() } function y(e, t) { return function (n, i, o) { let a, d, h, f; return Array.isArray(n) ? m(n) : "tokenize" in n ? m([n]) : function (e) { return t; function t(t) { const n = null !== t && e[t], r = null !== t && e.null; return m([...Array.isArray(n) ? n : n ? [n] : [], ...Array.isArray(r) ? r : r ? [r] : []])(t) } }(n); function m(e) { return a = e, d = 0, 0 === e.length ? o : g(e[d]) } function g(e) { return function (n) { f = function () { const e = p(), t = u.previous, n = u.currentConstruct, i = u.events.length, o = Array.from(s); return { from: i, restore: a }; function a() { r = e, u.previous = t, u.currentConstruct = n, u.events.length = i, s = o, x() } }(), h = e, e.partial || (u.currentConstruct = e); if (e.name && u.parser.constructs.disable.null.includes(e.name)) return y(n); return e.tokenize.call(t ? Object.assign(Object.create(u), t) : u, c, v, y)(n) } } function v(t) { return l = !0, e(h, f), i } function y(e) { return l = !0, f.restore(), ++d < a.length ? g(a[d]) : o } } } function b(e, t) { e.resolveAll && !o.includes(e) && o.push(e), e.resolve && jh(u.events, t, u.events.length - t, e.resolve(u.events.slice(t), u)), e.resolveTo && (u.events = e.resolveTo(u.events, u)) } function x() { r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1) } } const up = /[\0\t\n\r]/g; function dp(e, t) { const n = Number.parseInt(e, t); return n < 9 || 11 === n || n > 13 && n < 32 || n > 126 && n < 160 || n > 55295 && n < 57344 || n > 64975 && n < 65008 || 65535 === (65535 & n) || 65534 === (65535 & n) || n > 1114111 ? "\ufffd" : String.fromCodePoint(n) } const hp = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi; function fp(e, t, n) { if (t) return t; if (35 === n.charCodeAt(0)) { const e = n.charCodeAt(1), t = 120 === e || 88 === e; return dp(n.slice(t ? 2 : 1), t ? 16 : 10) } return zf(n) || e } const pp = {}.hasOwnProperty; function mp(e, n, r) { return "string" !== typeof n && (r = n, n = void 0), function (e) { const t = { transforms: [], canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"], enter: { autolink: o(te), autolinkProtocol: E, autolinkEmail: E, atxHeading: o(J), blockQuote: o(Q), characterEscape: E, characterReference: E, codeFenced: o(q), codeFencedFenceInfo: a, codeFencedFenceMeta: a, codeIndented: o(q, a), codeText: o(Z, a), codeTextData: E, data: E, codeFlowValue: E, definition: o(K), definitionDestinationString: a, definitionLabelString: a, definitionTitleString: a, emphasis: o(G), hardBreakEscape: o(_), hardBreakTrailing: o(_), htmlFlow: o($, a), htmlFlowData: E, htmlText: o($, a), htmlTextData: E, image: o(ee), label: a, link: o(te), listItem: o(re), listItemValue: h, listOrdered: o(ne, d), listUnordered: o(ne), paragraph: o(ie), reference: F, referenceString: a, resourceDestinationString: a, resourceTitleString: a, setextHeading: o(J), strong: o(oe), thematicBreak: o(se) }, exit: { atxHeading: l(), atxHeadingSequence: w, autolink: l(), autolinkEmail: X, autolinkProtocol: Y, blockQuote: l(), characterEscapeValue: C, characterReferenceMarkerHexadecimal: U, characterReferenceMarkerNumeric: U, characterReferenceValue: W, characterReference: H, codeFenced: l(g), codeFencedFence: m, codeFencedFenceInfo: f, codeFencedFenceMeta: p, codeFlowValue: C, codeIndented: l(v), codeText: l(T), codeTextData: C, data: C, definition: l(), definitionDestinationString: x, definitionLabelString: y, definitionTitleString: b, emphasis: l(), hardBreakEscape: l(j), hardBreakTrailing: l(j), htmlFlow: l(N), htmlFlowData: C, htmlText: l(M), htmlTextData: C, image: l(L), label: D, labelText: R, lineEnding: P, link: l(I), listItem: l(), listOrdered: l(), listUnordered: l(), paragraph: l(), referenceString: V, resourceDestinationString: z, resourceTitleString: O, resource: B, setextHeading: l(A), setextHeadingLineSequence: S, setextHeadingText: k, strong: l(), thematicBreak: l() } }; vp(t, (e || {}).mdastExtensions || []); const n = {}; return r; function r(e) { let r = { type: "root", children: [] }; const o = { stack: [r], tokenStack: [], config: t, enter: s, exit: c, buffer: a, resume: u, data: n }, l = []; let d = -1; for (; ++d < e.length;)if ("listOrdered" === e[d][1].type || "listUnordered" === e[d][1].type) if ("enter" === e[d][0]) l.push(d); else { d = i(e, l.pop(), d) } for (d = -1; ++d < e.length;) { const n = t[e[d][0]]; pp.call(n, e[d][1].type) && n[e[d][1].type].call(Object.assign({ sliceSerialize: e[d][2].sliceSerialize }, o), e[d][1]) } if (o.tokenStack.length > 0) { const e = o.tokenStack[o.tokenStack.length - 1]; (e[1] || bp).call(o, void 0, e[0]) } for (r.position = { start: gp(e.length > 0 ? e[0][1].start : { line: 1, column: 1, offset: 0 }), end: gp(e.length > 0 ? e[e.length - 2][1].end : { line: 1, column: 1, offset: 0 }) }, d = -1; ++d < t.transforms.length;)r = t.transforms[d](r) || r; return r } function i(e, t, n) { let r, i, o, a, s = t - 1, l = -1, c = !1; for (; ++s <= n;) { const t = e[s]; switch (t[1].type) { case "listUnordered": case "listOrdered": case "blockQuote": "enter" === t[0] ? l++ : l--, a = void 0; break; case "lineEndingBlank": "enter" === t[0] && (!r || a || l || o || (o = s), a = void 0); break; case "linePrefix": case "listItemValue": case "listItemMarker": case "listItemPrefix": case "listItemPrefixWhitespace": break; default: a = void 0 }if (!l && "enter" === t[0] && "listItemPrefix" === t[1].type || -1 === l && "exit" === t[0] && ("listUnordered" === t[1].type || "listOrdered" === t[1].type)) { if (r) { let a = s; for (i = void 0; a--;) { const t = e[a]; if ("lineEnding" === t[1].type || "lineEndingBlank" === t[1].type) { if ("exit" === t[0]) continue; i && (e[i][1].type = "lineEndingBlank", c = !0), t[1].type = "lineEnding", i = a } else if ("linePrefix" !== t[1].type && "blockQuotePrefix" !== t[1].type && "blockQuotePrefixWhitespace" !== t[1].type && "blockQuoteMarker" !== t[1].type && "listItemIndent" !== t[1].type) break } o && (!i || o < i) && (r._spread = !0), r.end = Object.assign({}, i ? e[i][1].start : t[1].end), e.splice(i || s, 0, ["exit", r, t[2]]), s++, n++ } if ("listItemPrefix" === t[1].type) { const i = { type: "listItem", _spread: !1, start: Object.assign({}, t[1].start), end: void 0 }; r = i, e.splice(s, 0, ["enter", i, t[2]]), s++, n++, o = void 0, a = !0 } } } return e[t][1]._spread = c, n } function o(e, t) { return n; function n(n) { s.call(this, e(n), n), t && t.call(this, n) } } function a() { this.stack.push({ type: "fragment", children: [] }) } function s(e, t, n) { this.stack[this.stack.length - 1].children.push(e), this.stack.push(e), this.tokenStack.push([t, n || void 0]), e.position = { start: gp(t.start), end: void 0 } } function l(e) { return t; function t(t) { e && e.call(this, t), c.call(this, t) } } function c(e, t) { const n = this.stack.pop(), r = this.tokenStack.pop(); if (!r) throw new Error("Cannot close `" + e.type + "` (" + nh({ start: e.start, end: e.end }) + "): it\u2019s not open"); if (r[0].type !== e.type) if (t) t.call(this, e, r[0]); else { (r[1] || bp).call(this, e, r[0]) } n.position.end = gp(e.end) } function u() { return Eh(this.stack.pop()) } function d() { this.data.expectingFirstListItemValue = !0 } function h(e) { if (this.data.expectingFirstListItemValue) { this.stack[this.stack.length - 2].start = Number.parseInt(this.sliceSerialize(e), 10), this.data.expectingFirstListItemValue = void 0 } } function f() { const e = this.resume(); this.stack[this.stack.length - 1].lang = e } function p() { const e = this.resume(); this.stack[this.stack.length - 1].meta = e } function m() { this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0) } function g() { const e = this.resume(); this.stack[this.stack.length - 1].value = e.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0 } function v() { const e = this.resume(); this.stack[this.stack.length - 1].value = e.replace(/(\r?\n|\r)$/g, "") } function y(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.label = t, n.identifier = wf(this.sliceSerialize(e)).toLowerCase() } function b() { const e = this.resume(); this.stack[this.stack.length - 1].title = e } function x() { const e = this.resume(); this.stack[this.stack.length - 1].url = e } function w(e) { const t = this.stack[this.stack.length - 1]; if (!t.depth) { const n = this.sliceSerialize(e).length; t.depth = n } } function k() { this.data.setextHeadingSlurpLineEnding = !0 } function S(e) { this.stack[this.stack.length - 1].depth = 61 === this.sliceSerialize(e).codePointAt(0) ? 1 : 2 } function A() { this.data.setextHeadingSlurpLineEnding = void 0 } function E(e) { const t = this.stack[this.stack.length - 1].children; let n = t[t.length - 1]; n && "text" === n.type || (n = ae(), n.position = { start: gp(e.start), end: void 0 }, t.push(n)), this.stack.push(n) } function C(e) { const t = this.stack.pop(); t.value += this.sliceSerialize(e), t.position.end = gp(e.end) } function P(e) { const n = this.stack[this.stack.length - 1]; if (this.data.atHardBreak) { return n.children[n.children.length - 1].position.end = gp(e.end), void (this.data.atHardBreak = void 0) } !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(n.type) && (E.call(this, e), C.call(this, e)) } function j() { this.data.atHardBreak = !0 } function N() { const e = this.resume(); this.stack[this.stack.length - 1].value = e } function M() { const e = this.resume(); this.stack[this.stack.length - 1].value = e } function T() { const e = this.resume(); this.stack[this.stack.length - 1].value = e } function I() { const e = this.stack[this.stack.length - 1]; if (this.data.inReference) { const t = this.data.referenceType || "shortcut"; e.type += "Reference", e.referenceType = t, delete e.url, delete e.title } else delete e.identifier, delete e.label; this.data.referenceType = void 0 } function L() { const e = this.stack[this.stack.length - 1]; if (this.data.inReference) { const t = this.data.referenceType || "shortcut"; e.type += "Reference", e.referenceType = t, delete e.url, delete e.title } else delete e.identifier, delete e.label; this.data.referenceType = void 0 } function R(e) { const t = this.sliceSerialize(e), n = this.stack[this.stack.length - 2]; n.label = function (e) { return e.replace(hp, fp) }(t), n.identifier = wf(t).toLowerCase() } function D() { const e = this.stack[this.stack.length - 1], t = this.resume(), n = this.stack[this.stack.length - 1]; if (this.data.inReference = !0, "link" === n.type) { const t = e.children; n.children = t } else n.alt = t } function z() { const e = this.resume(); this.stack[this.stack.length - 1].url = e } function O() { const e = this.resume(); this.stack[this.stack.length - 1].title = e } function B() { this.data.inReference = void 0 } function F() { this.data.referenceType = "collapsed" } function V(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.label = t, n.identifier = wf(this.sliceSerialize(e)).toLowerCase(), this.data.referenceType = "full" } function U(e) { this.data.characterReferenceType = e.type } function W(e) { const t = this.sliceSerialize(e), n = this.data.characterReferenceType; let r; if (n) r = dp(t, "characterReferenceMarkerNumeric" === n ? 10 : 16), this.data.characterReferenceType = void 0; else { r = zf(t) } this.stack[this.stack.length - 1].value += r } function H(e) { this.stack.pop().position.end = gp(e.end) } function Y(e) { C.call(this, e); this.stack[this.stack.length - 1].url = this.sliceSerialize(e) } function X(e) { C.call(this, e); this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(e) } function Q() { return { type: "blockquote", children: [] } } function q() { return { type: "code", lang: null, meta: null, value: "" } } function Z() { return { type: "inlineCode", value: "" } } function K() { return { type: "definition", identifier: "", label: null, title: null, url: "" } } function G() { return { type: "emphasis", children: [] } } function J() { return { type: "heading", depth: 0, children: [] } } function _() { return { type: "break" } } function $() { return { type: "html", value: "" } } function ee() { return { type: "image", title: null, url: "", alt: null } } function te() { return { type: "link", title: null, url: "", children: [] } } function ne(e) { return { type: "list", ordered: "listOrdered" === e.type, start: null, spread: e._spread, children: [] } } function re(e) { return { type: "listItem", spread: e._spread, checked: null, children: [] } } function ie() { return { type: "paragraph", children: [] } } function oe() { return { type: "strong", children: [] } } function ae() { return { type: "text", value: "" } } function se() { return { type: "thematicBreak" } } }(r)(function (e) { for (; !Ih(e);); return e }(function (e) { const n = { constructs: Dh([t, ...(e || {}).extensions || []]), content: r(_h), defined: [], document: r($h), flow: r(of), lazy: {}, string: r(sf), text: r(lf) }; return n; function r(e) { return function (t) { return cp(n, e, t) } } }(r).document().write(function () { let e, t = 1, n = "", r = !0; return function (i, o, a) { const s = []; let l, c, u, d, h; for (i = n + ("string" === typeof i ? i.toString() : new TextDecoder(o || void 0).decode(i)), u = 0, n = "", r && (65279 === i.charCodeAt(0) && u++, r = void 0); u < i.length;) { if (up.lastIndex = u, l = up.exec(i), d = l && void 0 !== l.index ? l.index : i.length, h = i.charCodeAt(d), !l) { n = i.slice(u); break } if (10 === h && u === d && e) s.push(-3), e = void 0; else switch (e && (s.push(-5), e = void 0), u < d && (s.push(i.slice(u, d)), t += d - u), h) { case 0: s.push(65533), t++; break; case 9: for (c = 4 * Math.ceil(t / 4), s.push(-2); t++ < c;)s.push(-1); break; case 10: s.push(-4), t = 1; break; default: e = !0, t = 1 }u = d + 1 } return a && (e && s.push(-5), n && s.push(n), s.push(null)), s } }()(e, n, !0)))) } function gp(e) { return { line: e.line, column: e.column, offset: e.offset } } function vp(e, t) { let n = -1; for (; ++n < t.length;) { const r = t[n]; Array.isArray(r) ? vp(e, r) : yp(e, r) } } function yp(e, t) { let n; for (n in t) if (pp.call(t, n)) switch (n) { case "canContainEols": { const r = t[n]; r && e[n].push(...r); break } case "transforms": { const r = t[n]; r && e[n].push(...r); break } case "enter": case "exit": { const r = t[n]; r && Object.assign(e[n], r); break } } } function bp(e, t) { throw e ? new Error("Cannot close `" + e.type + "` (" + nh({ start: e.start, end: e.end }) + "): a different token (`" + t.type + "`, " + nh({ start: t.start, end: t.end }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + nh({ start: t.start, end: t.end }) + ") is still open") } function xp(e) { const t = this; t.parser = function (n) { return mp(n, { ...t.data("settings"), ...e, extensions: t.data("micromarkExtensions") || [], mdastExtensions: t.data("fromMarkdownExtensions") || [] }) } } const wp = "object" === typeof self ? self : globalThis, kp = e => ((e, t) => { const n = (t, n) => (e.set(n, t), t), r = i => { if (e.has(i)) return e.get(i); const [o, a] = t[i]; switch (o) { case 0: case -1: return n(a, i); case 1: { const e = n([], i); for (const t of a) e.push(r(t)); return e } case 2: { const e = n({}, i); for (const [t, n] of a) e[r(t)] = r(n); return e } case 3: return n(new Date(a), i); case 4: { const { source: e, flags: t } = a; return n(new RegExp(e, t), i) } case 5: { const e = n(new Map, i); for (const [t, n] of a) e.set(r(t), r(n)); return e } case 6: { const e = n(new Set, i); for (const t of a) e.add(r(t)); return e } case 7: { const { name: e, message: t } = a; return n(new wp[e](t), i) } case 8: return n(BigInt(a), i); case "BigInt": return n(Object(BigInt(a)), i) }return n(new wp[o](a), i) }; return r })(new Map, e)(0), Sp = "", { toString: Ap } = {}, { keys: Ep } = Object, Cp = e => { const t = typeof e; if ("object" !== t || !e) return [0, t]; const n = Ap.call(e).slice(8, -1); switch (n) { case "Array": return [1, Sp]; case "Object": return [2, Sp]; case "Date": return [3, Sp]; case "RegExp": return [4, Sp]; case "Map": return [5, Sp]; case "Set": return [6, Sp] }return n.includes("Array") ? [1, n] : n.includes("Error") ? [7, n] : [2, n] }, Pp = e => { let [t, n] = e; return 0 === t && ("function" === n || "symbol" === n) }, jp = function (e) { let { json: t, lossy: n } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const r = []; return ((e, t, n, r) => { const i = (e, t) => { const i = r.push(e) - 1; return n.set(t, i), i }, o = r => { if (n.has(r)) return n.get(r); let [a, s] = Cp(r); switch (a) { case 0: { let t = r; switch (s) { case "bigint": a = 8, t = r.toString(); break; case "function": case "symbol": if (e) throw new TypeError("unable to serialize " + s); t = null; break; case "undefined": return i([-1], r) }return i([a, t], r) } case 1: { if (s) return i([s, [...r]], r); const e = [], t = i([a, e], r); for (const n of r) e.push(o(n)); return t } case 2: { if (s) switch (s) { case "BigInt": return i([s, r.toString()], r); case "Boolean": case "Number": case "String": return i([s, r.valueOf()], r) }if (t && "toJSON" in r) return o(r.toJSON()); const n = [], l = i([a, n], r); for (const t of Ep(r)) !e && Pp(Cp(r[t])) || n.push([o(t), o(r[t])]); return l } case 3: return i([a, r.toISOString()], r); case 4: { const { source: e, flags: t } = r; return i([a, { source: e, flags: t }], r) } case 5: { const t = [], n = i([a, t], r); for (const [i, a] of r) (e || !Pp(Cp(i)) && !Pp(Cp(a))) && t.push([o(i), o(a)]); return n } case 6: { const t = [], n = i([a, t], r); for (const i of r) !e && Pp(Cp(i)) || t.push(o(i)); return n } }const { message: l } = r; return i([a, { name: s, message: l }], r) }; return o })(!(t || n), !!t, new Map, r)(e), r }, Np = "function" === typeof structuredClone ? (e, t) => t && ("json" in t || "lossy" in t) ? kp(jp(e, t)) : structuredClone(e) : (e, t) => kp(jp(e, t)); function Mp(e) { const t = []; let n = -1, r = 0, i = 0; for (; ++n < e.length;) { const o = e.charCodeAt(n); let a = ""; if (37 === o && Fh(e.charCodeAt(n + 1)) && Fh(e.charCodeAt(n + 2))) i = 2; else if (o < 128) /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (a = String.fromCharCode(o)); else if (o > 55295 && o < 57344) { const t = e.charCodeAt(n + 1); o < 56320 && t > 56319 && t < 57344 ? (a = String.fromCharCode(o, t), i = 1) : a = "\ufffd" } else a = String.fromCharCode(o); a && (t.push(e.slice(r, n), encodeURIComponent(a)), r = n + i + 1, a = ""), i && (n += i, i = 0) } return t.join("") + e.slice(r) } function Tp(e, t) { const n = [{ type: "text", value: "\u21a9" }]; return t > 1 && n.push({ type: "element", tagName: "sup", properties: {}, children: [{ type: "text", value: String(t) }] }), n } function Ip(e, t) { return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "") } const Lp = function (e) { if (null === e || void 0 === e) return Dp; if ("function" === typeof e) return Rp(e); if ("object" === typeof e) return Array.isArray(e) ? function (e) { const t = []; let n = -1; for (; ++n < e.length;)t[n] = Lp(e[n]); return Rp(r); function r() { let e = -1; for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; for (; ++e < t.length;)if (t[e].apply(this, r)) return !0; return !1 } }(e) : function (e) { const t = e; return Rp(n); function n(n) { const r = n; let i; for (i in e) if (r[i] !== t[i]) return !1; return !0 } }(e); if ("string" === typeof e) return function (e) { return Rp(t); function t(t) { return t && t.type === e } }(e); throw new Error("Expected function, string, or object as test") }; function Rp(e) { return function (t, n, r) { return Boolean(zp(t) && e.call(this, t, "number" === typeof n ? n : void 0, r || void 0)) } } function Dp() { return !0 } function zp(e) { return null !== e && "object" === typeof e && "type" in e } const Op = [], Bp = !0, Fp = !1, Vp = "skip"; function Up(e, t, n, r) { let i; "function" === typeof t && "function" !== typeof n ? (r = n, n = t) : i = t; const o = Lp(i), a = r ? -1 : 1; !function e(i, s, l) { const c = i && "object" === typeof i ? i : {}; if ("string" === typeof c.type) { const e = "string" === typeof c.tagName ? c.tagName : "string" === typeof c.name ? c.name : void 0; Object.defineProperty(u, "name", { value: "node (" + i.type + (e ? "<" + e + ">" : "") + ")" }) } return u; function u() { let c, u, d, h = Op; if ((!t || o(i, s, l[l.length - 1] || void 0)) && (h = function (e) { if (Array.isArray(e)) return e; if ("number" === typeof e) return [Bp, e]; return null === e || void 0 === e ? Op : [e] }(n(i, l)), h[0] === Fp)) return h; if ("children" in i && i.children) { const t = i; if (t.children && h[0] !== Vp) for (u = (r ? t.children.length : -1) + a, d = l.concat(t); u > -1 && u < t.children.length;) { const n = t.children[u]; if (c = e(n, u, d)(), c[0] === Fp) return c; u = "number" === typeof c[1] ? c[1] : u + a } } return h } }(e, void 0, [])() } function Wp(e, t, n, r) { let i, o, a; "function" === typeof t && "function" !== typeof n ? (o = void 0, a = t, i = n) : (o = t, a = n, i = r), Up(e, o, (function (e, t) { const n = t[t.length - 1], r = n ? n.children.indexOf(e) : void 0; return a(e, r, n) }), i) } function Hp(e, t) { const n = t.referenceType; let r = "]"; if ("collapsed" === n ? r += "[]" : "full" === n && (r += "[" + (t.label || t.identifier) + "]"), "imageReference" === t.type) return [{ type: "text", value: "![" + t.alt + r }]; const i = e.all(t), o = i[0]; o && "text" === o.type ? o.value = "[" + o.value : i.unshift({ type: "text", value: "[" }); const a = i[i.length - 1]; return a && "text" === a.type ? a.value += r : i.push({ type: "text", value: r }), i } function Yp(e) { const t = e.spread; return null === t || void 0 === t ? e.children.length > 1 : t } const Xp = 9, Qp = 32; function qp(e) { const t = String(e), n = /\r?\n|\r/g; let r = n.exec(t), i = 0; const o = []; for (; r;)o.push(Zp(t.slice(i, r.index), i > 0, !0), r[0]), i = r.index + r[0].length, r = n.exec(t); return o.push(Zp(t.slice(i), i > 0, !1)), o.join("") } function Zp(e, t, n) { let r = 0, i = e.length; if (t) { let t = e.codePointAt(r); for (; t === Xp || t === Qp;)r++, t = e.codePointAt(r) } if (n) { let t = e.codePointAt(i - 1); for (; t === Xp || t === Qp;)i--, t = e.codePointAt(i - 1) } return i > r ? e.slice(r, i) : "" } const Kp = { blockquote: function (e, t) { const n = { type: "element", tagName: "blockquote", properties: {}, children: e.wrap(e.all(t), !0) }; return e.patch(t, n), e.applyData(t, n) }, break: function (e, t) { const n = { type: "element", tagName: "br", properties: {}, children: [] }; return e.patch(t, n), [e.applyData(t, n), { type: "text", value: "\n" }] }, code: function (e, t) { const n = t.value ? t.value + "\n" : "", r = {}; t.lang && (r.className = ["language-" + t.lang]); let i = { type: "element", tagName: "code", properties: r, children: [{ type: "text", value: n }] }; return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i }, delete: function (e, t) { const n = { type: "element", tagName: "del", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, emphasis: function (e, t) { const n = { type: "element", tagName: "em", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, footnoteReference: function (e, t) { const n = "string" === typeof e.options.clobberPrefix ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = Mp(r.toLowerCase()), o = e.footnoteOrder.indexOf(r); let a, s = e.footnoteCounts.get(r); void 0 === s ? (s = 0, e.footnoteOrder.push(r), a = e.footnoteOrder.length) : a = o + 1, s += 1, e.footnoteCounts.set(r, s); const l = { type: "element", tagName: "a", properties: { href: "#" + n + "fn-" + i, id: n + "fnref-" + i + (s > 1 ? "-" + s : ""), dataFootnoteRef: !0, ariaDescribedBy: ["footnote-label"] }, children: [{ type: "text", value: String(a) }] }; e.patch(t, l); const c = { type: "element", tagName: "sup", properties: {}, children: [l] }; return e.patch(t, c), e.applyData(t, c) }, heading: function (e, t) { const n = { type: "element", tagName: "h" + t.depth, properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, html: function (e, t) { if (e.options.allowDangerousHtml) { const n = { type: "raw", value: t.value }; return e.patch(t, n), e.applyData(t, n) } }, imageReference: function (e, t) { const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n); if (!r) return Hp(e, t); const i = { src: Mp(r.url || ""), alt: t.alt }; null !== r.title && void 0 !== r.title && (i.title = r.title); const o = { type: "element", tagName: "img", properties: i, children: [] }; return e.patch(t, o), e.applyData(t, o) }, image: function (e, t) { const n = { src: Mp(t.url) }; null !== t.alt && void 0 !== t.alt && (n.alt = t.alt), null !== t.title && void 0 !== t.title && (n.title = t.title); const r = { type: "element", tagName: "img", properties: n, children: [] }; return e.patch(t, r), e.applyData(t, r) }, inlineCode: function (e, t) { const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") }; e.patch(t, n); const r = { type: "element", tagName: "code", properties: {}, children: [n] }; return e.patch(t, r), e.applyData(t, r) }, linkReference: function (e, t) { const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n); if (!r) return Hp(e, t); const i = { href: Mp(r.url || "") }; null !== r.title && void 0 !== r.title && (i.title = r.title); const o = { type: "element", tagName: "a", properties: i, children: e.all(t) }; return e.patch(t, o), e.applyData(t, o) }, link: function (e, t) { const n = { href: Mp(t.url) }; null !== t.title && void 0 !== t.title && (n.title = t.title); const r = { type: "element", tagName: "a", properties: n, children: e.all(t) }; return e.patch(t, r), e.applyData(t, r) }, listItem: function (e, t, n) { const r = e.all(t), i = n ? function (e) { let t = !1; if ("list" === e.type) { t = e.spread || !1; const n = e.children; let r = -1; for (; !t && ++r < n.length;)t = Yp(n[r]) } return t }(n) : Yp(t), o = {}, a = []; if ("boolean" === typeof t.checked) { const e = r[0]; let n; e && "element" === e.type && "p" === e.tagName ? n = e : (n = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(n)), n.children.length > 0 && n.children.unshift({ type: "text", value: " " }), n.children.unshift({ type: "element", tagName: "input", properties: { type: "checkbox", checked: t.checked, disabled: !0 }, children: [] }), o.className = ["task-list-item"] } let s = -1; for (; ++s < r.length;) { const e = r[s]; (i || 0 !== s || "element" !== e.type || "p" !== e.tagName) && a.push({ type: "text", value: "\n" }), "element" !== e.type || "p" !== e.tagName || i ? a.push(e) : a.push(...e.children) } const l = r[r.length - 1]; l && (i || "element" !== l.type || "p" !== l.tagName) && a.push({ type: "text", value: "\n" }); const c = { type: "element", tagName: "li", properties: o, children: a }; return e.patch(t, c), e.applyData(t, c) }, list: function (e, t) { const n = {}, r = e.all(t); let i = -1; for ("number" === typeof t.start && 1 !== t.start && (n.start = t.start); ++i < r.length;) { const e = r[i]; if ("element" === e.type && "li" === e.tagName && e.properties && Array.isArray(e.properties.className) && e.properties.className.includes("task-list-item")) { n.className = ["contains-task-list"]; break } } const o = { type: "element", tagName: t.ordered ? "ol" : "ul", properties: n, children: e.wrap(r, !0) }; return e.patch(t, o), e.applyData(t, o) }, paragraph: function (e, t) { const n = { type: "element", tagName: "p", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, root: function (e, t) { const n = { type: "root", children: e.wrap(e.all(t)) }; return e.patch(t, n), e.applyData(t, n) }, strong: function (e, t) { const n = { type: "element", tagName: "strong", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, table: function (e, t) { const n = e.all(t), r = n.shift(), i = []; if (r) { const n = { type: "element", tagName: "thead", properties: {}, children: e.wrap([r], !0) }; e.patch(t.children[0], n), i.push(n) } if (n.length > 0) { const r = { type: "element", tagName: "tbody", properties: {}, children: e.wrap(n, !0) }, o = eh(t.children[1]), a = $d(t.children[t.children.length - 1]); o && a && (r.position = { start: o, end: a }), i.push(r) } const o = { type: "element", tagName: "table", properties: {}, children: e.wrap(i, !0) }; return e.patch(t, o), e.applyData(t, o) }, tableCell: function (e, t) { const n = { type: "element", tagName: "td", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, tableRow: function (e, t, n) { const r = n ? n.children : void 0, i = 0 === (r ? r.indexOf(t) : 1) ? "th" : "td", o = n && "table" === n.type ? n.align : void 0, a = o ? o.length : t.children.length; let s = -1; const l = []; for (; ++s < a;) { const n = t.children[s], r = {}, a = o ? o[s] : void 0; a && (r.align = a); let c = { type: "element", tagName: i, properties: r, children: [] }; n && (c.children = e.all(n), e.patch(n, c), c = e.applyData(n, c)), l.push(c) } const c = { type: "element", tagName: "tr", properties: {}, children: e.wrap(l, !0) }; return e.patch(t, c), e.applyData(t, c) }, text: function (e, t) { const n = { type: "text", value: qp(String(t.value)) }; return e.patch(t, n), e.applyData(t, n) }, thematicBreak: function (e, t) { const n = { type: "element", tagName: "hr", properties: {}, children: [] }; return e.patch(t, n), e.applyData(t, n) }, toml: Gp, yaml: Gp, definition: Gp, footnoteDefinition: Gp }; function Gp() { } const Jp = {}.hasOwnProperty, _p = {}; function $p(e, t) { e.position && (t.position = function (e) { const t = eh(e), n = $d(e); if (t && n) return { start: t, end: n } }(e)) } function em(e, t) { let n = t; if (e && e.data) { const t = e.data.hName, r = e.data.hChildren, i = e.data.hProperties; if ("string" === typeof t) if ("element" === n.type) n.tagName = t; else { n = { type: "element", tagName: t, properties: {}, children: "children" in n ? n.children : [n] } } "element" === n.type && i && Object.assign(n.properties, Np(i)), "children" in n && n.children && null !== r && void 0 !== r && (n.children = r) } return n } function tm(e, t) { const n = t.data || {}, r = !("value" in t) || Jp.call(n, "hProperties") || Jp.call(n, "hChildren") ? { type: "element", tagName: "div", properties: {}, children: e.all(t) } : { type: "text", value: t.value }; return e.patch(t, r), e.applyData(t, r) } function nm(e, t) { const n = []; let r = -1; for (t && n.push({ type: "text", value: "\n" }); ++r < e.length;)r && n.push({ type: "text", value: "\n" }), n.push(e[r]); return t && e.length > 0 && n.push({ type: "text", value: "\n" }), n } function rm(e) { let t = 0, n = e.charCodeAt(t); for (; 9 === n || 32 === n;)t++, n = e.charCodeAt(t); return e.slice(t) } function im(e, t) { const n = function (e, t) { const n = t || _p, r = new Map, i = new Map, o = new Map, a = { ...Kp, ...n.handlers }, s = { all: function (e) { const t = []; if ("children" in e) { const n = e.children; let r = -1; for (; ++r < n.length;) { const i = s.one(n[r], e); if (i) { if (r && "break" === n[r - 1].type && (Array.isArray(i) || "text" !== i.type || (i.value = rm(i.value)), !Array.isArray(i) && "element" === i.type)) { const e = i.children[0]; e && "text" === e.type && (e.value = rm(e.value)) } Array.isArray(i) ? t.push(...i) : t.push(i) } } } return t }, applyData: em, definitionById: r, footnoteById: i, footnoteCounts: o, footnoteOrder: [], handlers: a, one: function (e, t) { const n = e.type, r = s.handlers[n]; if (Jp.call(s.handlers, n) && r) return r(s, e, t); if (s.options.passThrough && s.options.passThrough.includes(n)) { if ("children" in e) { const { children: t, ...n } = e, r = Np(n); return r.children = s.all(e), r } return Np(e) } return (s.options.unknownHandler || tm)(s, e, t) }, options: n, patch: $p, wrap: nm }; return Wp(e, (function (e) { if ("definition" === e.type || "footnoteDefinition" === e.type) { const t = "definition" === e.type ? r : i, n = String(e.identifier).toUpperCase(); t.has(n) || t.set(n, e) } })), s }(e, t), r = n.one(e, void 0), i = function (e) { const t = "string" === typeof e.options.clobberPrefix ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || Tp, r = e.options.footnoteBackLabel || Ip, i = e.options.footnoteLabel || "Footnotes", o = e.options.footnoteLabelTagName || "h2", a = e.options.footnoteLabelProperties || { className: ["sr-only"] }, s = []; let l = -1; for (; ++l < e.footnoteOrder.length;) { const i = e.footnoteById.get(e.footnoteOrder[l]); if (!i) continue; const o = e.all(i), a = String(i.identifier).toUpperCase(), c = Mp(a.toLowerCase()); let u = 0; const d = [], h = e.footnoteCounts.get(a); for (; void 0 !== h && ++u <= h;) { d.length > 0 && d.push({ type: "text", value: " " }); let e = "string" === typeof n ? n : n(l, u); "string" === typeof e && (e = { type: "text", value: e }), d.push({ type: "element", tagName: "a", properties: { href: "#" + t + "fnref-" + c + (u > 1 ? "-" + u : ""), dataFootnoteBackref: "", ariaLabel: "string" === typeof r ? r : r(l, u), className: ["data-footnote-backref"] }, children: Array.isArray(e) ? e : [e] }) } const f = o[o.length - 1]; if (f && "element" === f.type && "p" === f.tagName) { const e = f.children[f.children.length - 1]; e && "text" === e.type ? e.value += " " : f.children.push({ type: "text", value: " " }), f.children.push(...d) } else o.push(...d); const p = { type: "element", tagName: "li", properties: { id: t + "fn-" + c }, children: e.wrap(o, !0) }; e.patch(i, p), s.push(p) } if (0 !== s.length) return { type: "element", tagName: "section", properties: { dataFootnotes: !0, className: ["footnotes"] }, children: [{ type: "element", tagName: o, properties: { ...Np(a), id: "footnote-label" }, children: [{ type: "text", value: i }] }, { type: "text", value: "\n" }, { type: "element", tagName: "ol", properties: {}, children: e.wrap(s, !0) }, { type: "text", value: "\n" }] } }(n), o = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] }; return i && o.children.push({ type: "text", value: "\n" }, i), o } function om(e, t) { return e && "run" in e ? async function (n, r) { const i = im(n, { file: r, ...t }); await e.run(i, r) } : function (n, r) { return im(n, { file: r, ...e || t }) } } function am(e) { if (e) throw e } var sm = n(240); function lm(e) { if ("object" !== typeof e || null === e) return !1; const t = Object.getPrototypeOf(e); return (null === t || t === Object.prototype || null === Object.getPrototypeOf(t)) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e) } function cm() { const e = [], t = { run: function () { for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; let i = -1; const o = n.pop(); if ("function" !== typeof o) throw new TypeError("Expected function as last argument, not " + o); !function t(r) { const a = e[++i]; let s = -1; if (r) o(r); else { for (var l = arguments.length, c = new Array(l > 1 ? l - 1 : 0), u = 1; u < l; u++)c[u - 1] = arguments[u]; for (; ++s < n.length;)null !== c[s] && void 0 !== c[s] || (c[s] = n[s]); n = c, a ? function (e, t) { let n; return i; function i() { for (var t = arguments.length, i = new Array(t), s = 0; s < t; s++)i[s] = arguments[s]; const l = e.length > i.length; let c; l && i.push(o); try { c = e.apply(this, i) } catch (r) { if (l && n) throw r; return o(r) } l || (c && c.then && "function" === typeof c.then ? c.then(a, o) : c instanceof Error ? o(c) : a(c)) } function o(e) { if (!n) { n = !0; for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)i[o - 1] = arguments[o]; t(e, ...i) } } function a(e) { o(null, e) } }(a, t)(...c) : o(null, ...c) } }(null, ...n) }, use: function (n) { if ("function" !== typeof n) throw new TypeError("Expected `middelware` to be a function, not " + n); return e.push(n), t } }; return t } const um = { basename: function (e, t) { if (void 0 !== t && "string" !== typeof t) throw new TypeError('"ext" argument must be a string'); dm(e); let n, r = 0, i = -1, o = e.length; if (void 0 === t || 0 === t.length || t.length > e.length) { for (; o--;)if (47 === e.codePointAt(o)) { if (n) { r = o + 1; break } } else i < 0 && (n = !0, i = o + 1); return i < 0 ? "" : e.slice(r, i) } if (t === e) return ""; let a = -1, s = t.length - 1; for (; o--;)if (47 === e.codePointAt(o)) { if (n) { r = o + 1; break } } else a < 0 && (n = !0, a = o + 1), s > -1 && (e.codePointAt(o) === t.codePointAt(s--) ? s < 0 && (i = o) : (s = -1, i = a)); r === i ? i = a : i < 0 && (i = e.length); return e.slice(r, i) }, dirname: function (e) { if (dm(e), 0 === e.length) return "."; let t, n = -1, r = e.length; for (; --r;)if (47 === e.codePointAt(r)) { if (t) { n = r; break } } else t || (t = !0); return n < 0 ? 47 === e.codePointAt(0) ? "/" : "." : 1 === n && 47 === e.codePointAt(0) ? "//" : e.slice(0, n) }, extname: function (e) { dm(e); let t, n = e.length, r = -1, i = 0, o = -1, a = 0; for (; n--;) { const s = e.codePointAt(n); if (47 !== s) r < 0 && (t = !0, r = n + 1), 46 === s ? o < 0 ? o = n : 1 !== a && (a = 1) : o > -1 && (a = -1); else if (t) { i = n + 1; break } } if (o < 0 || r < 0 || 0 === a || 1 === a && o === r - 1 && o === i + 1) return ""; return e.slice(o, r) }, join: function () { let e, t = -1; for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; for (; ++t < r.length;)dm(r[t]), r[t] && (e = void 0 === e ? r[t] : e + "/" + r[t]); return void 0 === e ? "." : function (e) { dm(e); const t = 47 === e.codePointAt(0); let n = function (e, t) { let n, r, i = "", o = 0, a = -1, s = 0, l = -1; for (; ++l <= e.length;) { if (l < e.length) n = e.codePointAt(l); else { if (47 === n) break; n = 47 } if (47 === n) { if (a === l - 1 || 1 === s); else if (a !== l - 1 && 2 === s) { if (i.length < 2 || 2 !== o || 46 !== i.codePointAt(i.length - 1) || 46 !== i.codePointAt(i.length - 2)) if (i.length > 2) { if (r = i.lastIndexOf("/"), r !== i.length - 1) { r < 0 ? (i = "", o = 0) : (i = i.slice(0, r), o = i.length - 1 - i.lastIndexOf("/")), a = l, s = 0; continue } } else if (i.length > 0) { i = "", o = 0, a = l, s = 0; continue } t && (i = i.length > 0 ? i + "/.." : "..", o = 2) } else i.length > 0 ? i += "/" + e.slice(a + 1, l) : i = e.slice(a + 1, l), o = l - a - 1; a = l, s = 0 } else 46 === n && s > -1 ? s++ : s = -1 } return i }(e, !t); 0 !== n.length || t || (n = "."); n.length > 0 && 47 === e.codePointAt(e.length - 1) && (n += "/"); return t ? "/" + n : n }(e) }, sep: "/" }; function dm(e) { if ("string" !== typeof e) throw new TypeError("Path must be a string. Received " + JSON.stringify(e)) } const hm = { cwd: function () { return "/" } }; function fm(e) { return Boolean(null !== e && "object" === typeof e && "href" in e && e.href && "protocol" in e && e.protocol && void 0 === e.auth) } function pm(e) { if ("string" === typeof e) e = new URL(e); else if (!fm(e)) { const t = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + e + "`"); throw t.code = "ERR_INVALID_ARG_TYPE", t } if ("file:" !== e.protocol) { const e = new TypeError("The URL must be of scheme file"); throw e.code = "ERR_INVALID_URL_SCHEME", e } return function (e) { if ("" !== e.hostname) { const e = new TypeError('File URL host must be "localhost" or empty on darwin'); throw e.code = "ERR_INVALID_FILE_URL_HOST", e } const t = e.pathname; let n = -1; for (; ++n < t.length;)if (37 === t.codePointAt(n) && 50 === t.codePointAt(n + 1)) { const e = t.codePointAt(n + 2); if (70 === e || 102 === e) { const e = new TypeError("File URL path must not include encoded / characters"); throw e.code = "ERR_INVALID_FILE_URL_PATH", e } } return decodeURIComponent(t) }(e) } const mm = ["history", "path", "basename", "stem", "extname", "dirname"]; class gm { constructor(e) { let t; t = e ? fm(e) ? { path: e } : "string" === typeof e || function (e) { return Boolean(e && "object" === typeof e && "byteLength" in e && "byteOffset" in e) }(e) ? { value: e } : e : {}, this.cwd = "cwd" in t ? "" : hm.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored; let n, r = -1; for (; ++r < mm.length;) { const e = mm[r]; e in t && void 0 !== t[e] && null !== t[e] && (this[e] = "history" === e ? [...t[e]] : t[e]) } for (n in t) mm.includes(n) || (this[n] = t[n]) } get basename() { return "string" === typeof this.path ? um.basename(this.path) : void 0 } set basename(e) { ym(e, "basename"), vm(e, "basename"), this.path = um.join(this.dirname || "", e) } get dirname() { return "string" === typeof this.path ? um.dirname(this.path) : void 0 } set dirname(e) { bm(this.basename, "dirname"), this.path = um.join(e || "", this.basename) } get extname() { return "string" === typeof this.path ? um.extname(this.path) : void 0 } set extname(e) { if (vm(e, "extname"), bm(this.dirname, "extname"), e) { if (46 !== e.codePointAt(0)) throw new Error("`extname` must start with `.`"); if (e.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots") } this.path = um.join(this.dirname, this.stem + (e || "")) } get path() { return this.history[this.history.length - 1] } set path(e) { fm(e) && (e = pm(e)), ym(e, "path"), this.path !== e && this.history.push(e) } get stem() { return "string" === typeof this.path ? um.basename(this.path, this.extname) : void 0 } set stem(e) { ym(e, "stem"), vm(e, "stem"), this.path = um.join(this.dirname || "", e + (this.extname || "")) } fail(e, t, n) { const r = this.message(e, t, n); throw r.fatal = !0, r } info(e, t, n) { const r = this.message(e, t, n); return r.fatal = void 0, r } message(e, t, n) { const r = new ah(e, t, n); return this.path && (r.name = this.path + ":" + r.name, r.file = this.path), r.fatal = !1, this.messages.push(r), r } toString(e) { if (void 0 === this.value) return ""; if ("string" === typeof this.value) return this.value; return new TextDecoder(e || void 0).decode(this.value) } } function vm(e, t) { if (e && e.includes(um.sep)) throw new Error("`" + t + "` cannot be a path: did not expect `" + um.sep + "`") } function ym(e, t) { if (!e) throw new Error("`" + t + "` cannot be empty") } function bm(e, t) { if (!e) throw new Error("Setting `" + t + "` requires `path` to be set too") } const xm = function (e) { const t = this.constructor.prototype, n = t[e], r = function () { return n.apply(r, arguments) }; return Object.setPrototypeOf(r, t), r }, wm = {}.hasOwnProperty; class km extends xm { constructor() { super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = cm() } copy() { const e = new km; let t = -1; for (; ++t < this.attachers.length;) { const n = this.attachers[t]; e.use(...n) } return e.data(sm(!0, {}, this.namespace)), e } data(e, t) { return "string" === typeof e ? 2 === arguments.length ? (Cm("data", this.frozen), this.namespace[e] = t, this) : wm.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (Cm("data", this.frozen), this.namespace = e, this) : this.namespace } freeze() { if (this.frozen) return this; const e = this; for (; ++this.freezeIndex < this.attachers.length;) { const [t, ...n] = this.attachers[this.freezeIndex]; if (!1 === n[0]) continue; !0 === n[0] && (n[0] = void 0); const r = t.call(e, ...n); "function" === typeof r && this.transformers.use(r) } return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this } parse(e) { this.freeze(); const t = Nm(e), n = this.parser || this.Parser; return Am("parse", n), n(String(t), t) } process(e, t) { const n = this; return this.freeze(), Am("process", this.parser || this.Parser), Em("process", this.compiler || this.Compiler), t ? r(void 0, t) : new Promise(r); function r(r, i) { const o = Nm(e), a = n.parse(o); function s(e, n) { e || !n ? i(e) : r ? r(n) : t(void 0, n) } n.run(a, o, (function (e, t, r) { if (e || !t || !r) return s(e); const i = t, o = n.stringify(i, r); var a; "string" === typeof (a = o) || function (e) { return Boolean(e && "object" === typeof e && "byteLength" in e && "byteOffset" in e) }(a) ? r.value = o : r.result = o, s(e, r) })) } } processSync(e) { let t, n = !1; return this.freeze(), Am("processSync", this.parser || this.Parser), Em("processSync", this.compiler || this.Compiler), this.process(e, (function (e, r) { n = !0, am(e), t = r })), jm("processSync", "process", n), t } run(e, t, n) { Pm(e), this.freeze(); const r = this.transformers; return n || "function" !== typeof t || (n = t, t = void 0), n ? i(void 0, n) : new Promise(i); function i(i, o) { const a = Nm(t); r.run(e, a, (function (t, r, a) { const s = r || e; t ? o(t) : i ? i(s) : n(void 0, s, a) })) } } runSync(e, t) { let n, r = !1; return this.run(e, t, (function (e, t) { am(e), n = t, r = !0 })), jm("runSync", "run", r), n } stringify(e, t) { this.freeze(); const n = Nm(t), r = this.compiler || this.Compiler; return Em("stringify", r), Pm(e), r(e, n) } use(e) { const t = this.attachers, n = this.namespace; if (Cm("use", this.frozen), null === e || void 0 === e); else if ("function" === typeof e) { for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)i[o - 1] = arguments[o]; c(e, i) } else { if ("object" !== typeof e) throw new TypeError("Expected usable value, not `" + e + "`"); Array.isArray(e) ? l(e) : s(e) } return this; function a(e) { if ("function" === typeof e) c(e, []); else { if ("object" !== typeof e) throw new TypeError("Expected usable value, not `" + e + "`"); if (Array.isArray(e)) { const [t, ...n] = e; c(t, n) } else s(e) } } function s(e) { if (!("plugins" in e) && !("settings" in e)) throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"); l(e.plugins), e.settings && (n.settings = sm(!0, n.settings, e.settings)) } function l(e) { let t = -1; if (null === e || void 0 === e); else { if (!Array.isArray(e)) throw new TypeError("Expected a list of plugins, not `" + e + "`"); for (; ++t < e.length;) { a(e[t]) } } } function c(e, n) { let r = -1, i = -1; for (; ++r < t.length;)if (t[r][0] === e) { i = r; break } if (-1 === i) t.push([e, ...n]); else if (n.length > 0) { let [r, ...o] = n; const a = t[i][1]; lm(a) && lm(r) && (r = sm(!0, a, r)), t[i] = [e, r, ...o] } } } } const Sm = (new km).freeze(); function Am(e, t) { if ("function" !== typeof t) throw new TypeError("Cannot `" + e + "` without `parser`") } function Em(e, t) { if ("function" !== typeof t) throw new TypeError("Cannot `" + e + "` without `compiler`") } function Cm(e, t) { if (t) throw new Error("Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.") } function Pm(e) { if (!lm(e) || "string" !== typeof e.type) throw new TypeError("Expected node, got `" + e + "`") } function jm(e, t, n) { if (!n) throw new Error("`" + e + "` finished async. Use `" + t + "` instead") } function Nm(e) { return function (e) { return Boolean(e && "object" === typeof e && "message" in e && "messages" in e) }(e) ? e : new gm(e) } const Mm = [], Tm = { allowDangerousHtml: !0 }, Im = /^(https?|ircs?|mailto|xmpp)$/i, Lm = [{ from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" }, { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" }, { from: "allowNode", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowElement" }, { from: "allowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowedElements" }, { from: "className", id: "remove-classname" }, { from: "disallowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "disallowedElements" }, { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" }, { from: "includeElementIndex", id: "#remove-includeelementindex" }, { from: "includeNodeIndex", id: "change-includenodeindex-to-includeelementindex" }, { from: "linkTarget", id: "remove-linktarget" }, { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" }, { from: "rawSourcePos", id: "#remove-rawsourcepos" }, { from: "renderers", id: "change-renderers-to-components", to: "components" }, { from: "source", id: "change-source-to-children", to: "children" }, { from: "sourcePos", id: "#remove-sourcepos" }, { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" }, { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }]; function Rm(e) { const t = Dm(e), n = zm(e); return Om(t.runSync(t.parse(n), n), e) } function Dm(e) { const t = e.rehypePlugins || Mm, n = e.remarkPlugins || Mm, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Tm } : Tm; return Sm().use(xp).use(n).use(om, r).use(t) } function zm(e) { const t = e.children || "", n = new gm; return "string" === typeof t && (n.value = t), n } function Om(e, t) { const n = t.allowedElements, r = t.allowElement, i = t.components, o = t.disallowedElements, a = t.skipHtml, s = t.unwrapDisallowed, l = t.urlTransform || Bm; for (const c of Lm) Object.hasOwn(t, c.from) && (c.from, c.to && c.to, c.id); return Wp(e, (function (e, t, i) { if ("raw" === e.type && i && "number" === typeof t) return a ? i.children.splice(t, 1) : i.children[t] = { type: "text", value: e.value }, t; if ("element" === e.type) { let t; for (t in Sh) if (Object.hasOwn(Sh, t) && Object.hasOwn(e.properties, t)) { const n = e.properties[t], r = Sh[t]; (null === r || r.includes(e.tagName)) && (e.properties[t] = l(String(n || ""), t, e)) } } if ("element" === e.type) { let a = n ? !n.includes(e.tagName) : !!o && o.includes(e.tagName); if (!a && r && "number" === typeof t && (a = !r(e, t, i)), a && i && "number" === typeof t) return s && e.children ? i.children.splice(t, 1, ...e.children) : i.children.splice(t, 1), t } })), fh(e, { Fragment: Me.Fragment, components: i, ignoreInvalidStyle: !0, jsx: Me.jsx, jsxs: Me.jsxs, passKeys: !0, passNode: !0 }) } function Bm(e) { const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/"); return -1 === t || -1 !== i && t > i || -1 !== n && t > n || -1 !== r && t > r || Im.test(e.slice(0, t)) ? e : "" } function Fm(e, t) { const n = String(e); if ("string" !== typeof t) throw new TypeError("Expected character"); let r = 0, i = n.indexOf(t); for (; -1 !== i;)r++, i = n.indexOf(t, i + t.length); return r } function Vm(e, t, n) { const r = Lp((n || {}).ignore || []), i = function (e) { const t = []; if (!Array.isArray(e)) throw new TypeError("Expected find and replace tuple or list of tuples"); const n = !e[0] || Array.isArray(e[0]) ? e : [e]; let r = -1; for (; ++r < n.length;) { const e = n[r]; t.push([Um(e[0]), Wm(e[1])]) } return t }(t); let o = -1; for (; ++o < i.length;)Up(e, "text", a); function a(e, t) { let n, a = -1; for (; ++a < t.length;) { const e = t[a], i = n ? n.children : void 0; if (r(e, i ? i.indexOf(e) : void 0, n)) return; n = e } if (n) return function (e, t) { const n = t[t.length - 1], r = i[o][0], a = i[o][1]; let s = 0; const l = n.children.indexOf(e); let c = !1, u = []; r.lastIndex = 0; let d = r.exec(e.value); for (; d;) { const n = d.index, i = { index: d.index, input: d.input, stack: [...t, e] }; let o = a(...d, i); if ("string" === typeof o && (o = o.length > 0 ? { type: "text", value: o } : void 0), !1 === o ? r.lastIndex = n + 1 : (s !== n && u.push({ type: "text", value: e.value.slice(s, n) }), Array.isArray(o) ? u.push(...o) : o && u.push(o), s = n + d[0].length, c = !0), !r.global) break; d = r.exec(e.value) } c ? (s < e.value.length && u.push({ type: "text", value: e.value.slice(s) }), n.children.splice(l, 1, ...u)) : u = [e]; return l + u.length }(e, t) } } function Um(e) { return "string" === typeof e ? new RegExp(function (e) { if ("string" !== typeof e) throw new TypeError("Expected a string"); return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") }(e), "g") : e } function Wm(e) { return "function" === typeof e ? e : function () { return e } } const Hm = "phrasing", Ym = ["autolink", "link", "image", "label"]; function Xm(e) { this.enter({ type: "link", title: null, url: "", children: [] }, e) } function Qm(e) { this.config.enter.autolinkProtocol.call(this, e) } function qm(e) { this.config.exit.autolinkProtocol.call(this, e) } function Zm(e) { this.config.exit.data.call(this, e); const t = this.stack[this.stack.length - 1]; t.type, t.url = "http://" + this.sliceSerialize(e) } function Km(e) { this.config.exit.autolinkEmail.call(this, e) } function Gm(e) { this.exit(e) } function Jm(e) { Vm(e, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, _m], [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, $m]], { ignore: ["link", "linkReference"] }) } function _m(e, t, n, r, i) { let o = ""; if (!eg(i)) return !1; if (/^w/i.test(t) && (n = t + n, t = "", o = "http://"), !function (e) { const t = e.split("."); if (t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2]))) return !1; return !0 }(n)) return !1; const a = function (e) { const t = /[!"&'),.:;<>?\]}]+$/.exec(e); if (!t) return [e, void 0]; e = e.slice(0, t.index); let n = t[0], r = n.indexOf(")"); const i = Fm(e, "("); let o = Fm(e, ")"); for (; -1 !== r && i > o;)e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), o++; return [e, n] }(n + r); if (!a[0]) return !1; const s = { type: "link", title: null, url: o + t + a[0], children: [{ type: "text", value: t + a[0] }] }; return a[1] ? [s, { type: "text", value: a[1] }] : s } function $m(e, t, n, r) { return !(!eg(r, !0) || /[-\d_]$/.test(n)) && { type: "link", title: null, url: "mailto:" + t + "@" + n, children: [{ type: "text", value: t + "@" + n }] } } function eg(e, t) { const n = e.input.charCodeAt(e.index - 1); return (0 === e.index || Kh(n) || Zh(n)) && (!t || 47 !== n) } function tg() { this.buffer() } function ng(e) { this.enter({ type: "footnoteReference", identifier: "", label: "" }, e) } function rg() { this.buffer() } function ig(e) { this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, e) } function og(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = wf(this.sliceSerialize(e)).toLowerCase(), n.label = t } function ag(e) { this.exit(e) } function sg(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = wf(this.sliceSerialize(e)).toLowerCase(), n.label = t } function lg(e) { this.exit(e) } function cg(e, t, n, r) { const i = n.createTracker(r); let o = i.move("[^"); const a = n.enter("footnoteReference"), s = n.enter("reference"); return o += i.move(n.safe(n.associationId(e), { after: "]", before: o })), s(), a(), o += i.move("]"), o } function ug(e) { let t = !1; return e && e.firstLineBlank && (t = !0), { handlers: { footnoteDefinition: function (e, n, r, i) { const o = r.createTracker(i); let a = o.move("[^"); const s = r.enter("footnoteDefinition"), l = r.enter("label"); a += o.move(r.safe(r.associationId(e), { before: a, after: "]" })), l(), a += o.move("]:"), e.children && e.children.length > 0 && (o.shift(4), a += o.move((t ? "\n" : " ") + r.indentLines(r.containerFlow(e, o.current()), t ? hg : dg))); return s(), a }, footnoteReference: cg }, unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }] } } function dg(e, t, n) { return 0 === t ? e : hg(e, t, n) } function hg(e, t, n) { return (n ? "" : "    ") + e } cg.peek = function () { return "[" }; const fg = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"]; function pg(e) { this.enter({ type: "delete", children: [] }, e) } function mg(e) { this.exit(e) } function gg(e, t, n, r) { const i = n.createTracker(r), o = n.enter("strikethrough"); let a = i.move("~~"); return a += n.containerPhrasing(e, { ...i.current(), before: a, after: "~" }), a += i.move("~~"), o(), a } function vg(e) { return e.length } function yg(e) { const t = "string" === typeof e ? e.codePointAt(0) : 0; return 67 === t || 99 === t ? 99 : 76 === t || 108 === t ? 108 : 82 === t || 114 === t ? 114 : 0 } function bg(e, t, n) { return ">" + (n ? "" : " ") + e } function xg(e, t, n) { if ("string" === typeof t && (t = [t]), !t || 0 === t.length) return n; let r = -1; for (; ++r < t.length;)if (e.includes(t[r])) return !0; return !1 } function wg(e, t, n, r) { let i = -1; for (; ++i < n.unsafe.length;)if ("\n" === n.unsafe[i].character && (o = n.stack, a = n.unsafe[i], xg(o, a.inConstruct, !0) && !xg(o, a.notInConstruct, !1))) return /[ \t]/.test(r.before) ? "" : " "; var o, a; return "\\\n" } function kg(e, t, n) { return (n ? "" : "    ") + e } function Sg(e) { const t = e.options.quote || '"'; if ('"' !== t && "'" !== t) throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"); return t } function Ag(e) { return "&#x" + e.toString(16).toUpperCase() + ";" } function Eg(e, t, n) { const r = Qf(e), i = Qf(t); return void 0 === r ? void 0 === i ? "_" === n ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : 1 === i ? { inside: !0, outside: !0 } : { inside: !1, outside: !0 } : 1 === r ? void 0 === i ? { inside: !1, outside: !1 } : 1 === i ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : void 0 === i ? { inside: !1, outside: !1 } : 1 === i ? { inside: !0, outside: !1 } : { inside: !1, outside: !1 } } function Cg(e, t, n, r) { const i = function (e) { const t = e.options.emphasis || "*"; if ("*" !== t && "_" !== t) throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"); return t }(n), o = n.enter("emphasis"), a = n.createTracker(r), s = a.move(i); let l = a.move(n.containerPhrasing(e, { after: i, before: s, ...a.current() })); const c = l.charCodeAt(0), u = Eg(r.before.charCodeAt(r.before.length - 1), c, i); u.inside && (l = Ag(c) + l.slice(1)); const d = l.charCodeAt(l.length - 1), h = Eg(r.after.charCodeAt(0), d, i); h.inside && (l = l.slice(0, -1) + Ag(d)); const f = a.move(i); return o(), n.attentionEncodeSurroundingInfo = { after: h.outside, before: u.outside }, s + l + f } function Pg(e) { return e.value || "" } function jg(e, t, n, r) { const i = Sg(n), o = '"' === i ? "Quote" : "Apostrophe", a = n.enter("image"); let s = n.enter("label"); const l = n.createTracker(r); let c = l.move("!["); return c += l.move(n.safe(e.alt, { before: c, after: "]", ...l.current() })), c += l.move("]("), s(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(n.safe(e.url, { before: c, after: ">", ...l.current() })), c += l.move(">")) : (s = n.enter("destinationRaw"), c += l.move(n.safe(e.url, { before: c, after: e.title ? " " : ")", ...l.current() }))), s(), e.title && (s = n.enter("title".concat(o)), c += l.move(" " + i), c += l.move(n.safe(e.title, { before: c, after: i, ...l.current() })), c += l.move(i), s()), c += l.move(")"), a(), c } function Ng(e, t, n, r) { const i = e.referenceType, o = n.enter("imageReference"); let a = n.enter("label"); const s = n.createTracker(r); let l = s.move("!["); const c = n.safe(e.alt, { before: l, after: "]", ...s.current() }); l += s.move(c + "]["), a(); const u = n.stack; n.stack = [], a = n.enter("reference"); const d = n.safe(n.associationId(e), { before: l, after: "]", ...s.current() }); return a(), n.stack = u, o(), "full" !== i && c && c === d ? "shortcut" === i ? l = l.slice(0, -1) : l += s.move("]") : l += s.move(d + "]"), l } function Mg(e, t, n) { let r = e.value || "", i = "`", o = -1; for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r);)i += "`"; for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++o < n.unsafe.length;) { const e = n.unsafe[o], t = n.compilePattern(e); let i; if (e.atBreak) for (; i = t.exec(r);) { let e = i.index; 10 === r.charCodeAt(e) && 13 === r.charCodeAt(e - 1) && e--, r = r.slice(0, e) + " " + r.slice(i.index + 1) } } return i + r + i } function Tg(e, t) { const n = Eh(e); return Boolean(!t.options.resourceLink && e.url && !e.title && e.children && 1 === e.children.length && "text" === e.children[0].type && (n === e.url || "mailto:" + n === e.url) && /^[a-z][a-z+.-]+:/i.test(e.url) && !/[\0- <>\u007F]/.test(e.url)) } function Ig(e, t, n, r) { const i = Sg(n), o = '"' === i ? "Quote" : "Apostrophe", a = n.createTracker(r); let s, l; if (Tg(e, n)) { const t = n.stack; n.stack = [], s = n.enter("autolink"); let r = a.move("<"); return r += a.move(n.containerPhrasing(e, { before: r, after: ">", ...a.current() })), r += a.move(">"), s(), n.stack = t, r } s = n.enter("link"), l = n.enter("label"); let c = a.move("["); return c += a.move(n.containerPhrasing(e, { before: c, after: "](", ...a.current() })), c += a.move("]("), l(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += a.move("<"), c += a.move(n.safe(e.url, { before: c, after: ">", ...a.current() })), c += a.move(">")) : (l = n.enter("destinationRaw"), c += a.move(n.safe(e.url, { before: c, after: e.title ? " " : ")", ...a.current() }))), l(), e.title && (l = n.enter("title".concat(o)), c += a.move(" " + i), c += a.move(n.safe(e.title, { before: c, after: i, ...a.current() })), c += a.move(i), l()), c += a.move(")"), s(), c } function Lg(e, t, n, r) { const i = e.referenceType, o = n.enter("linkReference"); let a = n.enter("label"); const s = n.createTracker(r); let l = s.move("["); const c = n.containerPhrasing(e, { before: l, after: "]", ...s.current() }); l += s.move(c + "]["), a(); const u = n.stack; n.stack = [], a = n.enter("reference"); const d = n.safe(n.associationId(e), { before: l, after: "]", ...s.current() }); return a(), n.stack = u, o(), "full" !== i && c && c === d ? "shortcut" === i ? l = l.slice(0, -1) : l += s.move("]") : l += s.move(d + "]"), l } function Rg(e) { const t = e.options.bullet || "*"; if ("*" !== t && "+" !== t && "-" !== t) throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"); return t } function Dg(e) { const t = e.options.rule || "*"; if ("*" !== t && "-" !== t && "_" !== t) throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"); return t } gg.peek = function () { return "~" }, Cg.peek = function (e, t, n) { return n.options.emphasis || "*" }, Pg.peek = function () { return "<" }, jg.peek = function () { return "!" }, Ng.peek = function () { return "!" }, Mg.peek = function () { return "`" }, Ig.peek = function (e, t, n) { return Tg(e, n) ? "<" : "[" }, Lg.peek = function () { return "[" }; const zg = Lp(["break", "delete", "emphasis", "footnote", "footnoteReference", "image", "imageReference", "inlineCode", "inlineMath", "link", "linkReference", "mdxJsxTextElement", "mdxTextExpression", "strong", "text", "textDirective"]); function Og(e, t, n, r) { const i = function (e) { const t = e.options.strong || "*"; if ("*" !== t && "_" !== t) throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"); return t }(n), o = n.enter("strong"), a = n.createTracker(r), s = a.move(i + i); let l = a.move(n.containerPhrasing(e, { after: i, before: s, ...a.current() })); const c = l.charCodeAt(0), u = Eg(r.before.charCodeAt(r.before.length - 1), c, i); u.inside && (l = Ag(c) + l.slice(1)); const d = l.charCodeAt(l.length - 1), h = Eg(r.after.charCodeAt(0), d, i); h.inside && (l = l.slice(0, -1) + Ag(d)); const f = a.move(i + i); return o(), n.attentionEncodeSurroundingInfo = { after: h.outside, before: u.outside }, s + l + f } Og.peek = function (e, t, n) { return n.options.strong || "*" }; const Bg = { blockquote: function (e, t, n, r) { const i = n.enter("blockquote"), o = n.createTracker(r); o.move("> "), o.shift(2); const a = n.indentLines(n.containerFlow(e, o.current()), bg); return i(), a }, break: wg, code: function (e, t, n, r) { const i = function (e) { const t = e.options.fence || "`"; if ("`" !== t && "~" !== t) throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"); return t }(n), o = e.value || "", a = "`" === i ? "GraveAccent" : "Tilde"; if (function (e, t) { return Boolean(!1 === t.options.fences && e.value && !e.lang && /[^ \r\n]/.test(e.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value)) }(e, n)) { const e = n.enter("codeIndented"), t = n.indentLines(o, kg); return e(), t } const s = n.createTracker(r), l = i.repeat(Math.max(function (e, t) { const n = String(e); let r = n.indexOf(t), i = r, o = 0, a = 0; if ("string" !== typeof t) throw new TypeError("Expected substring"); for (; -1 !== r;)r === i ? ++o > a && (a = o) : o = 1, i = r + t.length, r = n.indexOf(t, i); return a }(o, i) + 1, 3)), c = n.enter("codeFenced"); let u = s.move(l); if (e.lang) { const t = n.enter("codeFencedLang".concat(a)); u += s.move(n.safe(e.lang, { before: u, after: " ", encode: ["`"], ...s.current() })), t() } if (e.lang && e.meta) { const t = n.enter("codeFencedMeta".concat(a)); u += s.move(" "), u += s.move(n.safe(e.meta, { before: u, after: "\n", encode: ["`"], ...s.current() })), t() } return u += s.move("\n"), o && (u += s.move(o + "\n")), u += s.move(l), c(), u }, definition: function (e, t, n, r) { const i = Sg(n), o = '"' === i ? "Quote" : "Apostrophe", a = n.enter("definition"); let s = n.enter("label"); const l = n.createTracker(r); let c = l.move("["); return c += l.move(n.safe(n.associationId(e), { before: c, after: "]", ...l.current() })), c += l.move("]: "), s(), !e.url || /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(n.safe(e.url, { before: c, after: ">", ...l.current() })), c += l.move(">")) : (s = n.enter("destinationRaw"), c += l.move(n.safe(e.url, { before: c, after: e.title ? " " : "\n", ...l.current() }))), s(), e.title && (s = n.enter("title".concat(o)), c += l.move(" " + i), c += l.move(n.safe(e.title, { before: c, after: i, ...l.current() })), c += l.move(i), s()), a(), c }, emphasis: Cg, hardBreak: wg, heading: function (e, t, n, r) { const i = Math.max(Math.min(6, e.depth || 1), 1), o = n.createTracker(r); if (function (e, t) { let n = !1; return Wp(e, (function (e) { if ("value" in e && /\r?\n|\r/.test(e.value) || "break" === e.type) return n = !0, Fp })), Boolean((!e.depth || e.depth < 3) && Eh(e) && (t.options.setext || n)) }(e, n)) { const t = n.enter("headingSetext"), r = n.enter("phrasing"), a = n.containerPhrasing(e, { ...o.current(), before: "\n", after: "\n" }); return r(), t(), a + "\n" + (1 === i ? "=" : "-").repeat(a.length - (Math.max(a.lastIndexOf("\r"), a.lastIndexOf("\n")) + 1)) } const a = "#".repeat(i), s = n.enter("headingAtx"), l = n.enter("phrasing"); o.move(a + " "); let c = n.containerPhrasing(e, { before: "# ", after: "\n", ...o.current() }); return /^[\t ]/.test(c) && (c = Ag(c.charCodeAt(0)) + c.slice(1)), c = c ? a + " " + c : a, n.options.closeAtx && (c += " " + a), l(), s(), c }, html: Pg, image: jg, imageReference: Ng, inlineCode: Mg, link: Ig, linkReference: Lg, list: function (e, t, n, r) { const i = n.enter("list"), o = n.bulletCurrent; let a = e.ordered ? function (e) { const t = e.options.bulletOrdered || "."; if ("." !== t && ")" !== t) throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"); return t }(n) : Rg(n); const s = e.ordered ? "." === a ? ")" : "." : function (e) { const t = Rg(e), n = e.options.bulletOther; if (!n) return "*" === t ? "-" : "*"; if ("*" !== n && "+" !== n && "-" !== n) throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"); if (n === t) throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"); return n }(n); let l = !(!t || !n.bulletLastUsed) && a === n.bulletLastUsed; if (!e.ordered) { const t = e.children ? e.children[0] : void 0; if ("*" !== a && "-" !== a || !t || t.children && t.children[0] || "list" !== n.stack[n.stack.length - 1] || "listItem" !== n.stack[n.stack.length - 2] || "list" !== n.stack[n.stack.length - 3] || "listItem" !== n.stack[n.stack.length - 4] || 0 !== n.indexStack[n.indexStack.length - 1] || 0 !== n.indexStack[n.indexStack.length - 2] || 0 !== n.indexStack[n.indexStack.length - 3] || (l = !0), Dg(n) === a && t) { let t = -1; for (; ++t < e.children.length;) { const n = e.children[t]; if (n && "listItem" === n.type && n.children && n.children[0] && "thematicBreak" === n.children[0].type) { l = !0; break } } } } l && (a = s), n.bulletCurrent = a; const c = n.containerFlow(e, r); return n.bulletLastUsed = a, n.bulletCurrent = o, i(), c }, listItem: function (e, t, n, r) { const i = function (e) { const t = e.options.listItemIndent || "one"; if ("tab" !== t && "one" !== t && "mixed" !== t) throw new Error("Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"); return t }(n); let o = n.bulletCurrent || Rg(n); t && "list" === t.type && t.ordered && (o = ("number" === typeof t.start && t.start > -1 ? t.start : 1) + (!1 === n.options.incrementListMarker ? 0 : t.children.indexOf(e)) + o); let a = o.length + 1; ("tab" === i || "mixed" === i && (t && "list" === t.type && t.spread || e.spread)) && (a = 4 * Math.ceil(a / 4)); const s = n.createTracker(r); s.move(o + " ".repeat(a - o.length)), s.shift(a); const l = n.enter("listItem"), c = n.indentLines(n.containerFlow(e, s.current()), (function (e, t, n) { if (t) return (n ? "" : " ".repeat(a)) + e; return (n ? o : o + " ".repeat(a - o.length)) + e })); return l(), c }, paragraph: function (e, t, n, r) { const i = n.enter("paragraph"), o = n.enter("phrasing"), a = n.containerPhrasing(e, r); return o(), i(), a }, root: function (e, t, n, r) { return (e.children.some((function (e) { return zg(e) })) ? n.containerPhrasing : n.containerFlow).call(n, e, r) }, strong: Og, text: function (e, t, n, r) { return n.safe(e.value, r) }, thematicBreak: function (e, t, n) { const r = (Dg(n) + (n.options.ruleSpaces ? " " : "")).repeat(function (e) { const t = e.options.ruleRepetition || 3; if (t < 3) throw new Error("Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"); return t }(n)); return n.options.ruleSpaces ? r.slice(0, -1) : r } }; function Fg(e) { const t = e._align; this.enter({ type: "table", align: t.map((function (e) { return "none" === e ? null : e })), children: [] }, e), this.data.inTable = !0 } function Vg(e) { this.exit(e), this.data.inTable = void 0 } function Ug(e) { this.enter({ type: "tableRow", children: [] }, e) } function Wg(e) { this.exit(e) } function Hg(e) { this.enter({ type: "tableCell", children: [] }, e) } function Yg(e) { let t = this.resume(); this.data.inTable && (t = t.replace(/\\([\\|])/g, Xg)); const n = this.stack[this.stack.length - 1]; n.type, n.value = t, this.exit(e) } function Xg(e, t) { return "|" === t ? t : e } function Qg(e) { const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, o = n ? " " : "|"; return { unsafe: [{ character: "\r", inConstruct: "tableCell" }, { character: "\n", inConstruct: "tableCell" }, { atBreak: !0, character: "|", after: "[\t :-]" }, { character: "|", inConstruct: "tableCell" }, { atBreak: !0, character: ":", after: "-" }, { atBreak: !0, character: "-", after: "[:|-]" }], handlers: { inlineCode: function (e, t, n) { let r = Bg.inlineCode(e, t, n); n.stack.includes("tableCell") && (r = r.replace(/\|/g, "\\$&")); return r }, table: function (e, t, n, r) { return s(function (e, t, n) { const r = e.children; let i = -1; const o = [], a = t.enter("table"); for (; ++i < r.length;)o[i] = l(r[i], t, n); return a(), o }(e, n, r), e.align) }, tableCell: a, tableRow: function (e, t, n, r) { const i = l(e, n, r), o = s([i]); return o.slice(0, o.indexOf("\n")) } } }; function a(e, t, n, r) { const i = n.enter("tableCell"), a = n.enter("phrasing"), s = n.containerPhrasing(e, { ...r, before: o, after: o }); return a(), i(), s } function s(e, t) { return function (e, t) { const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || vg, o = [], a = [], s = [], l = []; let c = 0, u = -1; for (; ++u < e.length;) { const t = [], r = []; let o = -1; for (e[u].length > c && (c = e[u].length); ++o < e[u].length;) { const a = null === (d = e[u][o]) || void 0 === d ? "" : String(d); if (!1 !== n.alignDelimiters) { const e = i(a); r[o] = e, (void 0 === l[o] || e > l[o]) && (l[o] = e) } t.push(a) } a[u] = t, s[u] = r } var d; let h = -1; if ("object" === typeof r && "length" in r) for (; ++h < c;)o[h] = yg(r[h]); else { const e = yg(r); for (; ++h < c;)o[h] = e } h = -1; const f = [], p = []; for (; ++h < c;) { const e = o[h]; let t = "", r = ""; 99 === e ? (t = ":", r = ":") : 108 === e ? t = ":" : 114 === e && (r = ":"); let i = !1 === n.alignDelimiters ? 1 : Math.max(1, l[h] - t.length - r.length); const a = t + "-".repeat(i) + r; !1 !== n.alignDelimiters && (i = t.length + i + r.length, i > l[h] && (l[h] = i), p[h] = i), f[h] = a } a.splice(1, 0, f), s.splice(1, 0, p), u = -1; const m = []; for (; ++u < a.length;) { const e = a[u], t = s[u]; h = -1; const r = []; for (; ++h < c;) { const i = e[h] || ""; let a = "", s = ""; if (!1 !== n.alignDelimiters) { const e = l[h] - (t[h] || 0), n = o[h]; 114 === n ? a = " ".repeat(e) : 99 === n ? e % 2 ? (a = " ".repeat(e / 2 + .5), s = " ".repeat(e / 2 - .5)) : (a = " ".repeat(e / 2), s = a) : s = " ".repeat(e) } !1 === n.delimiterStart || h || r.push("|"), !1 === n.padding || !1 === n.alignDelimiters && "" === i || !1 === n.delimiterStart && !h || r.push(" "), !1 !== n.alignDelimiters && r.push(a), r.push(i), !1 !== n.alignDelimiters && r.push(s), !1 !== n.padding && r.push(" "), !1 === n.delimiterEnd && h === c - 1 || r.push("|") } m.push(!1 === n.delimiterEnd ? r.join("").replace(/ +$/, "") : r.join("")) } return m.join("\n") }(e, { align: t, alignDelimiters: r, padding: n, stringLength: i }) } function l(e, t, n) { const r = e.children; let i = -1; const o = [], s = t.enter("tableRow"); for (; ++i < r.length;)o[i] = a(r[i], 0, t, n); return s(), o } } function qg(e) { const t = this.stack[this.stack.length - 2]; t.type, t.checked = "taskListCheckValueChecked" === e.type } function Zg(e) { const t = this.stack[this.stack.length - 2]; if (t && "listItem" === t.type && "boolean" === typeof t.checked) { const e = this.stack[this.stack.length - 1]; e.type; const n = e.children[0]; if (n && "text" === n.type) { const r = t.children; let i, o = -1; for (; ++o < r.length;) { const e = r[o]; if ("paragraph" === e.type) { i = e; break } } i === e && (n.value = n.value.slice(1), 0 === n.value.length ? e.children.shift() : e.position && n.position && "number" === typeof n.position.start.offset && (n.position.start.column++, n.position.start.offset++, e.position.start = Object.assign({}, n.position.start))) } } this.exit(e) } function Kg(e, t, n, r) { const i = e.children[0], o = "boolean" === typeof e.checked && i && "paragraph" === i.type, a = "[" + (e.checked ? "x" : " ") + "] ", s = n.createTracker(r); o && s.move(a); let l = Bg.listItem(e, t, n, { ...r, ...s.current() }); return o && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, (function (e) { return e + a }))), l } const Gg = { tokenize: function (e, t, n) { let r = 0; return function t(o) { if ((87 === o || 119 === o) && r < 3) return r++, e.consume(o), t; if (46 === o && 3 === r) return e.consume(o), i; return n(o) }; function i(e) { return null === e ? n(e) : t(e) } }, partial: !0 }, Jg = { tokenize: function (e, t, n) { let r, i, o; return a; function a(t) { return 46 === t || 95 === t ? e.check($g, l, s)(t) : null === t || Qh(t) || Kh(t) || 45 !== t && Zh(t) ? l(t) : (o = !0, e.consume(t), a) } function s(t) { return 95 === t ? r = !0 : (i = r, r = void 0), e.consume(t), a } function l(e) { return i || r || !o ? n(e) : t(e) } }, partial: !0 }, _g = { tokenize: function (e, t) { let n = 0, r = 0; return i; function i(a) { return 40 === a ? (n++, e.consume(a), i) : 41 === a && r < n ? o(a) : 33 === a || 34 === a || 38 === a || 39 === a || 41 === a || 42 === a || 44 === a || 46 === a || 58 === a || 59 === a || 60 === a || 63 === a || 93 === a || 95 === a || 126 === a ? e.check($g, t, o)(a) : null === a || Qh(a) || Kh(a) ? t(a) : (e.consume(a), i) } function o(t) { return 41 === t && r++, e.consume(t), i } }, partial: !0 }, $g = { tokenize: function (e, t, n) { return r; function r(a) { return 33 === a || 34 === a || 39 === a || 41 === a || 42 === a || 44 === a || 46 === a || 58 === a || 59 === a || 63 === a || 95 === a || 126 === a ? (e.consume(a), r) : 38 === a ? (e.consume(a), o) : 93 === a ? (e.consume(a), i) : 60 === a || null === a || Qh(a) || Kh(a) ? t(a) : n(a) } function i(e) { return null === e || 40 === e || 91 === e || Qh(e) || Kh(e) ? t(e) : r(e) } function o(e) { return Bh(e) ? a(e) : n(e) } function a(t) { return 59 === t ? (e.consume(t), r) : Bh(t) ? (e.consume(t), a) : n(t) } }, partial: !0 }, ev = { tokenize: function (e, t, n) { return function (t) { return e.consume(t), r }; function r(e) { return Fh(e) ? n(e) : t(e) } }, partial: !0 }, tv = { name: "wwwAutolink", tokenize: function (e, t, n) { const r = this; return function (t) { if (87 !== t && 119 !== t || !av.call(r, r.previous) || uv(r.events)) return n(t); return e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(Gg, e.attempt(Jg, e.attempt(_g, i), n), n)(t) }; function i(n) { return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(n) } }, previous: av }, nv = { name: "protocolAutolink", tokenize: function (e, t, n) { const r = this; let i = "", o = !1; return function (t) { if ((72 === t || 104 === t) && sv.call(r, r.previous) && !uv(r.events)) return e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(t), e.consume(t), a; return n(t) }; function a(t) { if (Bh(t) && i.length < 5) return i += String.fromCodePoint(t), e.consume(t), a; if (58 === t) { const n = i.toLowerCase(); if ("http" === n || "https" === n) return e.consume(t), s } return n(t) } function s(t) { return 47 === t ? (e.consume(t), o ? l : (o = !0, s)) : n(t) } function l(t) { return null === t || Uh(t) || Qh(t) || Kh(t) || Zh(t) ? n(t) : e.attempt(Jg, e.attempt(_g, c), n)(t) } function c(n) { return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(n) } }, previous: sv }, rv = { name: "emailAutolink", tokenize: function (e, t, n) { const r = this; let i, o; return function (t) { if (!cv(t) || !lv.call(r, r.previous) || uv(r.events)) return n(t); return e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), a(t) }; function a(t) { return cv(t) ? (e.consume(t), a) : 64 === t ? (e.consume(t), s) : n(t) } function s(t) { return 46 === t ? e.check(ev, c, l)(t) : 45 === t || 95 === t || Fh(t) ? (o = !0, e.consume(t), s) : c(t) } function l(t) { return e.consume(t), i = !0, s } function c(a) { return o && i && Bh(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(a)) : n(a) } }, previous: lv }, iv = {}; let ov = 48; for (; ov < 123;)iv[ov] = rv, ov++, 58 === ov ? ov = 65 : 91 === ov && (ov = 97); function av(e) { return null === e || 40 === e || 42 === e || 95 === e || 91 === e || 93 === e || 126 === e || Qh(e) } function sv(e) { return !Bh(e) } function lv(e) { return !(47 === e || cv(e)) } function cv(e) { return 43 === e || 45 === e || 46 === e || 95 === e || Fh(e) } function uv(e) { let t = e.length, n = !1; for (; t--;) { const r = e[t][1]; if (("labelLink" === r.type || "labelImage" === r.type) && !r._balanced) { n = !0; break } if (r._gfmAutolinkLiteralWalkedInto) { n = !1; break } } return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n } iv[43] = rv, iv[45] = rv, iv[46] = rv, iv[95] = rv, iv[72] = [rv, nv], iv[104] = [rv, nv], iv[87] = [rv, tv], iv[119] = [rv, tv]; const dv = { tokenize: function (e, t, n) { const r = this; return Jh(e, (function (e) { const i = r.events[r.events.length - 1]; return i && "gfmFootnoteDefinitionIndent" === i[1].type && 4 === i[2].sliceSerialize(i[1], !0).length ? t(e) : n(e) }), "gfmFootnoteDefinitionIndent", 5) }, partial: !0 }; function hv(e, t, n) { const r = this; let i = r.events.length; const o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let a; for (; i--;) { const e = r.events[i][1]; if ("labelImage" === e.type) { a = e; break } if ("gfmFootnoteCall" === e.type || "labelLink" === e.type || "label" === e.type || "image" === e.type || "link" === e.type) break } return function (i) { if (!a || !a._balanced) return n(i); const s = wf(r.sliceSerialize({ start: a.end, end: r.now() })); if (94 !== s.codePointAt(0) || !o.includes(s.slice(1))) return n(i); return e.enter("gfmFootnoteCallLabelMarker"), e.consume(i), e.exit("gfmFootnoteCallLabelMarker"), t(i) } } function fv(e, t) { let n, r = e.length; for (; r--;)if ("labelImage" === e[r][1].type && "enter" === e[r][0]) { n = e[r][1]; break } e[r + 1][1].type = "data", e[r + 3][1].type = "gfmFootnoteCallLabelMarker"; const i = { type: "gfmFootnoteCall", start: Object.assign({}, e[r + 3][1].start), end: Object.assign({}, e[e.length - 1][1].end) }, o = { type: "gfmFootnoteCallMarker", start: Object.assign({}, e[r + 3][1].end), end: Object.assign({}, e[r + 3][1].end) }; o.end.column++, o.end.offset++, o.end._bufferIndex++; const a = { type: "gfmFootnoteCallString", start: Object.assign({}, o.end), end: Object.assign({}, e[e.length - 1][1].start) }, s = { type: "chunkString", contentType: "string", start: Object.assign({}, a.start), end: Object.assign({}, a.end) }, l = [e[r + 1], e[r + 2], ["enter", i, t], e[r + 3], e[r + 4], ["enter", o, t], ["exit", o, t], ["enter", a, t], ["enter", s, t], ["exit", s, t], ["exit", a, t], e[e.length - 2], e[e.length - 1], ["exit", i, t]]; return e.splice(r, e.length - r + 1, ...l), e } function pv(e, t, n) { const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let o, a = 0; return function (t) { return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(t), e.exit("gfmFootnoteCallLabelMarker"), s }; function s(t) { return 94 !== t ? n(t) : (e.enter("gfmFootnoteCallMarker"), e.consume(t), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", l) } function l(s) { if (a > 999 || 93 === s && !o || null === s || 91 === s || Qh(s)) return n(s); if (93 === s) { e.exit("chunkString"); const o = e.exit("gfmFootnoteCallString"); return i.includes(wf(r.sliceSerialize(o))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(s), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(s) } return Qh(s) || (o = !0), a++, e.consume(s), 92 === s ? c : l } function c(t) { return 91 === t || 92 === t || 93 === t ? (e.consume(t), a++, l) : l(t) } } function mv(e, t, n) { const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let o, a, s = 0; return function (t) { return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(t), e.exit("gfmFootnoteDefinitionLabelMarker"), l }; function l(t) { return 94 === t ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(t), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", c) : n(t) } function c(t) { if (s > 999 || 93 === t && !a || null === t || 91 === t || Qh(t)) return n(t); if (93 === t) { e.exit("chunkString"); const n = e.exit("gfmFootnoteDefinitionLabelString"); return o = wf(r.sliceSerialize(n)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(t), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), d } return Qh(t) || (a = !0), s++, e.consume(t), 92 === t ? u : c } function u(t) { return 91 === t || 92 === t || 93 === t ? (e.consume(t), s++, c) : c(t) } function d(t) { return 58 === t ? (e.enter("definitionMarker"), e.consume(t), e.exit("definitionMarker"), i.includes(o) || i.push(o), Jh(e, h, "gfmFootnoteDefinitionWhitespace")) : n(t) } function h(e) { return t(e) } } function gv(e, t, n) { return e.check(tf, t, e.attempt(dv, t, n)) } function vv(e) { e.exit("gfmFootnoteDefinition") } function yv(e) { let t = (e || {}).singleTilde; const n = { name: "strikethrough", tokenize: function (e, n, r) { const i = this.previous, o = this.events; let a = 0; return function (t) { if (126 === i && "characterEscape" !== o[o.length - 1][1].type) return r(t); return e.enter("strikethroughSequenceTemporary"), s(t) }; function s(o) { const l = Qf(i); if (126 === o) return a > 1 ? r(o) : (e.consume(o), a++, s); if (a < 2 && !t) return r(o); const c = e.exit("strikethroughSequenceTemporary"), u = Qf(o); return c._open = !u || 2 === u && Boolean(l), c._close = !l || 2 === l && Boolean(u), n(o) } }, resolveAll: function (e, t) { let n = -1; for (; ++n < e.length;)if ("enter" === e[n][0] && "strikethroughSequenceTemporary" === e[n][1].type && e[n][1]._close) { let r = n; for (; r--;)if ("exit" === e[r][0] && "strikethroughSequenceTemporary" === e[r][1].type && e[r][1]._open && e[n][1].end.offset - e[n][1].start.offset === e[r][1].end.offset - e[r][1].start.offset) { e[n][1].type = "strikethroughSequence", e[r][1].type = "strikethroughSequence"; const i = { type: "strikethrough", start: Object.assign({}, e[r][1].start), end: Object.assign({}, e[n][1].end) }, o = { type: "strikethroughText", start: Object.assign({}, e[r][1].end), end: Object.assign({}, e[n][1].start) }, a = [["enter", i, t], ["enter", e[r][1], t], ["exit", e[r][1], t], ["enter", o, t]], s = t.parser.constructs.insideSpan.null; s && jh(a, a.length, 0, Vf(s, e.slice(r + 1, n), t)), jh(a, a.length, 0, [["exit", o, t], ["enter", e[n][1], t], ["exit", e[n][1], t], ["exit", i, t]]), jh(e, r - 1, n - r + 3, a), n = r + a.length - 2; break } } n = -1; for (; ++n < e.length;)"strikethroughSequenceTemporary" === e[n][1].type && (e[n][1].type = "data"); return e } }; return null !== t && void 0 !== t || (t = !0), { text: { 126: n }, insideSpan: { null: [n] }, attentionMarkers: { null: [126] } } } class bv { constructor() { this.map = [] } add(e, t, n) { !function (e, t, n, r) { let i = 0; if (0 === n && 0 === r.length) return; for (; i < e.map.length;) { if (e.map[i][0] === t) return e.map[i][1] += n, void e.map[i][2].push(...r); i += 1 } e.map.push([t, n, r]) }(this, e, t, n) } consume(e) { if (this.map.sort((function (e, t) { return e[0] - t[0] })), 0 === this.map.length) return; let t = this.map.length; const n = []; for (; t > 0;)t -= 1, n.push(e.slice(this.map[t][0] + this.map[t][1]), this.map[t][2]), e.length = this.map[t][0]; n.push(e.slice()), e.length = 0; let r = n.pop(); for (; r;) { for (const t of r) e.push(t); r = n.pop() } this.map.length = 0 } } function xv(e, t) { let n = !1; const r = []; for (; t < e.length;) { const i = e[t]; if (n) { if ("enter" === i[0]) "tableContent" === i[1].type && r.push("tableDelimiterMarker" === e[t + 1][1].type ? "left" : "none"); else if ("tableContent" === i[1].type) { if ("tableDelimiterMarker" === e[t - 1][1].type) { const e = r.length - 1; r[e] = "left" === r[e] ? "center" : "right" } } else if ("tableDelimiterRow" === i[1].type) break } else "enter" === i[0] && "tableDelimiterRow" === i[1].type && (n = !0); t += 1 } return r } function wv(e, t, n) { const r = this; let i, o = 0, a = 0; return function (e) { let t = r.events.length - 1; for (; t > -1;) { const e = r.events[t][1].type; if ("lineEnding" !== e && "linePrefix" !== e) break; t-- } const i = t > -1 ? r.events[t][1].type : null, o = "tableHead" === i || "tableRow" === i ? x : s; if (o === x && r.parser.lazy[r.now().line]) return n(e); return o(e) }; function s(t) { return e.enter("tableHead"), e.enter("tableRow"), function (e) { if (124 === e) return l(e); return i = !0, a += 1, l(e) }(t) } function l(t) { return null === t ? n(t) : Xh(t) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), d) : n(t) : qh(t) ? Jh(e, l, "whitespace")(t) : (a += 1, i && (i = !1, o += 1), 124 === t ? (e.enter("tableCellDivider"), e.consume(t), e.exit("tableCellDivider"), i = !0, l) : (e.enter("data"), c(t))) } function c(t) { return null === t || 124 === t || Qh(t) ? (e.exit("data"), l(t)) : (e.consume(t), 92 === t ? u : c) } function u(t) { return 92 === t || 124 === t ? (e.consume(t), c) : c(t) } function d(t) { return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(t) : (e.enter("tableDelimiterRow"), i = !1, qh(t) ? Jh(e, h, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : h(t)) } function h(t) { return 45 === t || 58 === t ? p(t) : 124 === t ? (i = !0, e.enter("tableCellDivider"), e.consume(t), e.exit("tableCellDivider"), f) : b(t) } function f(t) { return qh(t) ? Jh(e, p, "whitespace")(t) : p(t) } function p(t) { return 58 === t ? (a += 1, i = !0, e.enter("tableDelimiterMarker"), e.consume(t), e.exit("tableDelimiterMarker"), m) : 45 === t ? (a += 1, m(t)) : null === t || Xh(t) ? y(t) : b(t) } function m(t) { return 45 === t ? (e.enter("tableDelimiterFiller"), g(t)) : b(t) } function g(t) { return 45 === t ? (e.consume(t), g) : 58 === t ? (i = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(t), e.exit("tableDelimiterMarker"), v) : (e.exit("tableDelimiterFiller"), v(t)) } function v(t) { return qh(t) ? Jh(e, y, "whitespace")(t) : y(t) } function y(n) { return 124 === n ? h(n) : (null === n || Xh(n)) && i && o === a ? (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(n)) : b(n) } function b(e) { return n(e) } function x(t) { return e.enter("tableRow"), w(t) } function w(n) { return 124 === n ? (e.enter("tableCellDivider"), e.consume(n), e.exit("tableCellDivider"), w) : null === n || Xh(n) ? (e.exit("tableRow"), t(n)) : qh(n) ? Jh(e, w, "whitespace")(n) : (e.enter("data"), k(n)) } function k(t) { return null === t || 124 === t || Qh(t) ? (e.exit("data"), w(t)) : (e.consume(t), 92 === t ? S : k) } function S(t) { return 92 === t || 124 === t ? (e.consume(t), k) : k(t) } } function kv(e, t) { let n, r, i, o = -1, a = !0, s = 0, l = [0, 0, 0, 0], c = [0, 0, 0, 0], u = !1, d = 0; const h = new bv; for (; ++o < e.length;) { const f = e[o], p = f[1]; "enter" === f[0] ? "tableHead" === p.type ? (u = !1, 0 !== d && (Av(h, t, d, n, r), r = void 0, d = 0), n = { type: "table", start: Object.assign({}, p.start), end: Object.assign({}, p.end) }, h.add(o, 0, [["enter", n, t]])) : "tableRow" === p.type || "tableDelimiterRow" === p.type ? (a = !0, i = void 0, l = [0, 0, 0, 0], c = [0, o + 1, 0, 0], u && (u = !1, r = { type: "tableBody", start: Object.assign({}, p.start), end: Object.assign({}, p.end) }, h.add(o, 0, [["enter", r, t]])), s = "tableDelimiterRow" === p.type ? 2 : r ? 3 : 1) : !s || "data" !== p.type && "tableDelimiterMarker" !== p.type && "tableDelimiterFiller" !== p.type ? "tableCellDivider" === p.type && (a ? a = !1 : (0 !== l[1] && (c[0] = c[1], i = Sv(h, t, l, s, void 0, i)), l = c, c = [l[1], o, 0, 0])) : (a = !1, 0 === c[2] && (0 !== l[1] && (c[0] = c[1], i = Sv(h, t, l, s, void 0, i), l = [0, 0, 0, 0]), c[2] = o)) : "tableHead" === p.type ? (u = !0, d = o) : "tableRow" === p.type || "tableDelimiterRow" === p.type ? (d = o, 0 !== l[1] ? (c[0] = c[1], i = Sv(h, t, l, s, o, i)) : 0 !== c[1] && (i = Sv(h, t, c, s, o, i)), s = 0) : !s || "data" !== p.type && "tableDelimiterMarker" !== p.type && "tableDelimiterFiller" !== p.type || (c[3] = o) } for (0 !== d && Av(h, t, d, n, r), h.consume(t.events), o = -1; ++o < t.events.length;) { const e = t.events[o]; "enter" === e[0] && "table" === e[1].type && (e[1]._align = xv(t.events, o)) } return e } function Sv(e, t, n, r, i, o) { const a = 1 === r ? "tableHeader" : 2 === r ? "tableDelimiter" : "tableData"; 0 !== n[0] && (o.end = Object.assign({}, Ev(t.events, n[0])), e.add(n[0], 0, [["exit", o, t]])); const s = Ev(t.events, n[1]); if (o = { type: a, start: Object.assign({}, s), end: Object.assign({}, s) }, e.add(n[1], 0, [["enter", o, t]]), 0 !== n[2]) { const i = Ev(t.events, n[2]), o = Ev(t.events, n[3]), a = { type: "tableContent", start: Object.assign({}, i), end: Object.assign({}, o) }; if (e.add(n[2], 0, [["enter", a, t]]), 2 !== r) { const r = t.events[n[2]], i = t.events[n[3]]; if (r[1].end = Object.assign({}, i[1].end), r[1].type = "chunkText", r[1].contentType = "text", n[3] > n[2] + 1) { const t = n[2] + 1, r = n[3] - n[2] - 1; e.add(t, r, []) } } e.add(n[3] + 1, 0, [["exit", a, t]]) } return void 0 !== i && (o.end = Object.assign({}, Ev(t.events, i)), e.add(i, 0, [["exit", o, t]]), o = void 0), o } function Av(e, t, n, r, i) { const o = [], a = Ev(t.events, n); i && (i.end = Object.assign({}, a), o.push(["exit", i, t])), r.end = Object.assign({}, a), o.push(["exit", r, t]), e.add(n + 1, 0, o) } function Ev(e, t) { const n = e[t], r = "enter" === n[0] ? "start" : "end"; return n[1][r] } const Cv = { name: "tasklistCheck", tokenize: function (e, t, n) { const r = this; return function (t) { if (null !== r.previous || !r._gfmTasklistFirstContentOfListItem) return n(t); return e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(t), e.exit("taskListCheckMarker"), i }; function i(t) { return Qh(t) ? (e.enter("taskListCheckValueUnchecked"), e.consume(t), e.exit("taskListCheckValueUnchecked"), o) : 88 === t || 120 === t ? (e.enter("taskListCheckValueChecked"), e.consume(t), e.exit("taskListCheckValueChecked"), o) : n(t) } function o(t) { return 93 === t ? (e.enter("taskListCheckMarker"), e.consume(t), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), a) : n(t) } function a(r) { return Xh(r) ? t(r) : qh(r) ? e.check({ tokenize: Pv }, t, n)(r) : n(r) } } }; function Pv(e, t, n) { return Jh(e, (function (e) { return null === e ? n(e) : t(e) }), "whitespace") } const jv = {}; function Nv(e) { const t = e || jv, n = this.data(), r = n.micromarkExtensions || (n.micromarkExtensions = []), i = n.fromMarkdownExtensions || (n.fromMarkdownExtensions = []), o = n.toMarkdownExtensions || (n.toMarkdownExtensions = []); r.push(function (e) { return Dh([{ text: iv }, { document: { 91: { name: "gfmFootnoteDefinition", tokenize: mv, continuation: { tokenize: gv }, exit: vv } }, text: { 91: { name: "gfmFootnoteCall", tokenize: pv }, 93: { name: "gfmPotentialFootnoteCall", add: "after", tokenize: hv, resolveTo: fv } } }, yv(e), { flow: { null: { name: "table", tokenize: wv, resolveAll: kv } } }, { text: { 91: Cv } }]) }(t)), i.push([{ transforms: [Jm], enter: { literalAutolink: Xm, literalAutolinkEmail: Qm, literalAutolinkHttp: Qm, literalAutolinkWww: Qm }, exit: { literalAutolink: Gm, literalAutolinkEmail: Km, literalAutolinkHttp: qm, literalAutolinkWww: Zm } }, { enter: { gfmFootnoteCallString: tg, gfmFootnoteCall: ng, gfmFootnoteDefinitionLabelString: rg, gfmFootnoteDefinition: ig }, exit: { gfmFootnoteCallString: og, gfmFootnoteCall: ag, gfmFootnoteDefinitionLabelString: sg, gfmFootnoteDefinition: lg } }, { canContainEols: ["delete"], enter: { strikethrough: pg }, exit: { strikethrough: mg } }, { enter: { table: Fg, tableData: Hg, tableHeader: Hg, tableRow: Ug }, exit: { codeText: Yg, table: Vg, tableData: Wg, tableHeader: Wg, tableRow: Wg } }, { exit: { taskListCheckValueChecked: qg, taskListCheckValueUnchecked: qg, paragraph: Zg } }]), o.push(function (e) { return { extensions: [{ unsafe: [{ character: "@", before: "[+\\-.\\w]", after: "[\\-.\\w]", inConstruct: Hm, notInConstruct: Ym }, { character: ".", before: "[Ww]", after: "[\\-.\\w]", inConstruct: Hm, notInConstruct: Ym }, { character: ":", before: "[ps]", after: "\\/", inConstruct: Hm, notInConstruct: Ym }] }, ug(e), { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: fg }], handlers: { delete: gg } }, Qg(e), { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: Kg } }] } }(t)) } const Mv = e => ld.find((t => t.slug === e)); function Tv() { const { slug: e } = function () { let { matches: e } = i.useContext(J), t = e[e.length - 1]; return t ? t.params : {} }(), t = Mv(e); return (0, i.useLayoutEffect)((() => { document.title = t ? "".concat(t.title, " - Magmar Blog") : "Magmar Blog", window.scrollTo(0, 0) }), [e, t]), (0, Me.jsxs)("div", { className: "min-h-screen text-white", children: [(0, Me.jsx)(Xu, {}), (0, Me.jsx)("div", { className: "min-h-screen pt-[200px]", style: { backgroundImage: "url(".concat(oc, ")"), backgroundSize: "cover", backgroundPosition: "center", backgroundRepeat: "no-repeat", backgroundAttachment: "fixed" }, children: (0, Me.jsxs)("div", { className: "max-w-4xl px-5 pb-24 mx-auto", children: [(0, Me.jsxs)(Pe, { to: "/blog", className: "inline-flex items-center gap-2 mb-8 transition-colors text-white/70 hover:text-white", children: [(0, Me.jsx)("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: (0, Me.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15 19l-7-7 7-7" }) }), "Back to Blog"] }), (0, Me.jsxs)("article", { children: [(0, Me.jsxs)("header", { className: "mb-12", children: [(0, Me.jsx)("div", { className: "mb-6", children: (0, Me.jsx)("span", { className: "inline-flex items-center px-3 py-1 text-sm text-white bg-orange-500 rounded-full", children: t.category }) }), (0, Me.jsx)("h1", { className: "mb-6 text-4xl font-medium leading-tight md:text-5xl lg:text-6xl", children: t.title }), (0, Me.jsxs)("div", { className: "flex items-center gap-6 text-white/70", children: [(0, Me.jsxs)("span", { children: ["By ", t.author] }), (0, Me.jsx)("span", { children: "\u2022" }), (0, Me.jsx)("span", { children: t.date }), (0, Me.jsx)("span", { children: "\u2022" }), (0, Me.jsxs)("span", { children: [t.readTime, " read"] })] })] }), (0, Me.jsx)("div", { className: "aspect-square max-h-[600px] mx-auto relative rounded-lg mb-12 overflow-hidden", children: (0, Me.jsx)("img", { src: t.image, alt: t.title, className: "object-cover w-full h-full" }) }), (0, Me.jsx)("div", { className: "prose prose-lg prose-invert max-w-none text-white/90 leading-relaxed space-y-6 text-lg [&>h1]:text-3xl [&>h1]:md:text-4xl [&>h1]:font-medium [&>h1]:text-white [&>h1]:mb-6 [&>h1]:mt-10 [&>h2]:text-2xl [&>h2]:md:text-3xl [&>h2]:font-medium [&>h2]:text-orange-500 [&>h2]:mb-4 [&>h2]:mt-8 [&>h3]:text-xl [&>h3]:md:text-2xl [&>h3]:font-medium [&>h3]:text-white [&>h3]:mb-3 [&>h3]:mt-6 [&>p]:mb-4 [&>p]:leading-relaxed [&>p]:text-white/90 [&>ul]:list-disc [&>ul]:list-outside [&>ul]:space-y-2 [&>ul]:mb-4 [&>ul]:ml-6 [&>ol]:list-decimal [&>ol]:list-outside [&>ol]:space-y-2 [&>ol]:mb-4 [&>ol]:ml-6 [&>li]:text-white/80 [&>li]:mb-1 [&>blockquote]:border-l-4 [&>blockquote]:border-orange-500 [&>blockquote]:pl-4 [&>blockquote]:italic [&>blockquote]:text-white/70 [&>blockquote]:my-6 [&>code]:bg-white/10 [&>code]:px-2 [&>code]:py-1 [&>code]:rounded [&>code]:text-orange-500 [&>code]:text-sm [&>pre]:bg-white/10 [&>pre]:p-4 [&>pre]:rounded-lg [&>pre]:overflow-x-auto [&>pre]:mb-6 [&>strong]:text-white [&>strong]:font-semibold [&>em]:text-white/80 [&>em]:italic", children: (0, Me.jsx)(Rm, { remarkPlugins: [Nv], children: t.content }) }), (0, Me.jsx)("footer", { className: "pt-8 mt-16 border-t border-white/10", children: (0, Me.jsx)("div", { className: "flex items-center justify-between", children: (0, Me.jsxs)("div", { className: "flex items-center gap-4", children: [(0, Me.jsx)("img", { src: "/logo.png", alt: t.author, width: 48, height: 48, className: "rounded-full" }), (0, Me.jsxs)("div", { children: [(0, Me.jsx)("p", { className: "font-medium", children: t.author }), (0, Me.jsx)("p", { className: "text-sm text-white/70", children: "Author" })] })] }) }) })] })] }) })] }) } const Iv = function () { return (0, Me.jsx)("div", { children: (0, Me.jsx)(Ae, { children: (0, Me.jsxs)(ye, { children: [(0, Me.jsx)(ge, { path: "/", exact: !0, element: (0, Me.jsx)($u, {}) }), (0, Me.jsx)(ge, { path: "/terms-of-service", element: (0, Me.jsx)(od, {}) }), (0, Me.jsx)(ge, { path: "/privacy-policy", element: (0, Me.jsx)(id, {}) }), (0, Me.jsx)(ge, { path: "/faqs", element: (0, Me.jsx)(td, {}) }), (0, Me.jsx)(ge, { path: "/glossary", element: (0, Me.jsx)(rd, {}) }), (0, Me.jsx)(ge, { path: "/media-kit", element: (0, Me.jsx)(sd, {}) }), (0, Me.jsx)(ge, { path: "/blog", element: (0, Me.jsx)(cd, {}) }), (0, Me.jsx)(ge, { path: "/blog/:slug", element: (0, Me.jsx)(Tv, {}) })] }) }) }) }; const Lv = function () { return (0, Me.jsx)("div", { className: "", children: (0, Me.jsx)(Iv, {}) }) }, Rv = e => { e && e instanceof Function && n.e(453).then(n.bind(n, 453)).then((t => { let { getCLS: n, getFID: r, getFCP: i, getLCP: o, getTTFB: a } = t; n(e), r(e), i(e), o(e), a(e) })) }; a.createRoot(document.getElementById("root")).render((0, Me.jsx)(i.StrictMode, { children: (0, Me.jsx)(Lv, {}) })), Rv() })() })();
//# sourceMappingURL=main.9ff04849.js.map